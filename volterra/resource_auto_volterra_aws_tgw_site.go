//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_aws_tgw_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/aws_tgw_site"
)

// resourceVolterraAwsTgwSite is implementation of Volterra's AwsTgwSite resources
func resourceVolterraAwsTgwSite() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraAwsTgwSiteCreate,
		Read:   resourceVolterraAwsTgwSiteRead,
		Update: resourceVolterraAwsTgwSiteUpdate,
		Delete: resourceVolterraAwsTgwSiteDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"aws_parameters": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Required: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"admin_password": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"blindfold_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"location": {
													Type:     schema.TypeString,
													Required: true,
												},

												"store_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"clear_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"url": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},
								},
							},
						},

						"aws_region": {
							Type:     schema.TypeString,
							Required: true,
						},

						"az_nodes": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"aws_az_name": {
										Type:     schema.TypeString,
										Required: true,
									},

									"inside_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"existing_subnet_id": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"reserved_inside_subnet": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"outside_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"existing_subnet_id": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"workload_subnet": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"existing_subnet_id": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"subnet_param": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"ipv4": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"aws_cred": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"disk_size": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"instance_type": {
							Type:     schema.TypeString,
							Required: true,
						},

						"disable_internet_vip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"enable_internet_vip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"custom_security_group": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"inside_security_group_id": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"outside_security_group_id": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"f5xc_security_group": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"new_vpc": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"autogenerate": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"name_tag": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"primary_ipv4": {
										Type:     schema.TypeString,
										Required: true,
									},
								},
							},
						},

						"vpc_id": {

							Type:     schema.TypeString,
							Optional: true,
						},

						"ssh_key": {
							Type:     schema.TypeString,
							Required: true,
						},

						"existing_tgw": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"tgw_asn": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"tgw_id": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"volterra_site_asn": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"new_tgw": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"system_generated": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"user_assigned": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"tgw_asn": {
													Type:     schema.TypeInt,
													Optional: true,
												},

												"volterra_site_asn": {
													Type:     schema.TypeInt,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"reserved_tgw_cidr": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"tgw_cidr": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"ipv4": {
										Type:     schema.TypeString,
										Required: true,
									},

									"ipv6": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_worker_nodes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"nodes_per_az": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"total_nodes": {

							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},

			"block_all_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"blocked_services": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"blocked_sevice": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ssh": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"web_user_interface": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"network_type": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"default_blocked_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"coordinates": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"latitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},

						"longitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},
					},
				},
			},

			"custom_dns": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"inside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"inside_nameserver_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_nameserver_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"direct_connect_disabled": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"direct_connect_enabled": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"auto_asn": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"custom_asn": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"hosted_vifs": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"site_registration_over_direct_connect": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"cloudlink_network_name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"site_registration_over_internet": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"vif_list": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"vif_id": {
													Type:     schema.TypeString,
													Required: true,
												},

												"other_region": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"same_as_site_region": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"standard_vifs": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"private_connectivity": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"cloud_link": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:     schema.TypeString,
										Computed: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"inside": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"kubernetes_upgrade_drain": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"disable_upgrade_drain": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"enable_upgrade_drain": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"drain_max_unavailable_node_count": {

										Type:     schema.TypeInt,
										Optional: true,
									},

									"drain_node_timeout": {
										Type:     schema.TypeInt,
										Required: true,
									},
								},
							},
						},
					},
				},
			},

			"log_receiver": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"logs_streaming_disabled": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"offline_survivability_mode": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"enable_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"os": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_os_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"operating_system_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"performance_enhancement_mode": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"perf_mode_l3_enhanced": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"jumbo": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"no_jumbo": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"perf_mode_l7_enhanced": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"sw": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_sw_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"volterra_software_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"tags": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"tgw_security": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"active_east_west_service_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"service_policies": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"east_west_service_policy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_east_west_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_enhanced_firewall_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enhanced_firewall_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"vn_config": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"allowed_vip_port": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"custom_ports": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"port_ranges": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"disable_allowed_vip_port": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"use_http_https_port": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"use_http_port": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"use_https_port": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"allowed_vip_port_sli": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"custom_ports": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"port_ranges": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"disable_allowed_vip_port": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"use_http_https_port": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"use_http_port": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"use_https_port": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"dc_cluster_group_inside_vn": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"dc_cluster_group_outside_vn": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_dc_cluster_group": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"global_network_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"inside_static_routes": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_inside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_outside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_static_routes": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeList,
																						MaxItems: 1,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeList,
																			MaxItems: 1,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"vpc_attachments": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"vpc_list": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"vpc_id": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// resourceVolterraAwsTgwSiteCreate creates AwsTgwSite resource
func resourceVolterraAwsTgwSiteCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_aws_tgw_site.CreateSpecType{}
	createReq := &ves_io_schema_views_aws_tgw_site.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//aws_parameters
	if v, ok := d.GetOk("aws_parameters"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		awsParameters := &ves_io_schema_views_aws_tgw_site.ServicesVPCType{}
		createSpec.AwsParameters = awsParameters
		for _, set := range sl {
			if set != nil {
				awsParametersMapStrToI := set.(map[string]interface{})

				if v, ok := awsParametersMapStrToI["admin_password"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					adminPassword := &ves_io_schema.SecretType{}
					awsParameters.AdminPassword = adminPassword
					for _, set := range sl {
						if set != nil {
							adminPasswordMapStrToI := set.(map[string]interface{})

							secretInfoOneofTypeFound := false

							if v, ok := adminPasswordMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								adminPassword.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := adminPasswordMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								adminPassword.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if w, ok := awsParametersMapStrToI["aws_region"]; ok && !isIntfNil(w) {
					awsParameters.AwsRegion = w.(string)
				}

				if v, ok := awsParametersMapStrToI["az_nodes"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					azNodes := make([]*ves_io_schema_views.AWSVPCTwoInterfaceNodeType, len(sl))
					awsParameters.AzNodes = azNodes
					for i, set := range sl {
						if set != nil {
							azNodes[i] = &ves_io_schema_views.AWSVPCTwoInterfaceNodeType{}
							azNodesMapStrToI := set.(map[string]interface{})

							if w, ok := azNodesMapStrToI["aws_az_name"]; ok && !isIntfNil(w) {
								azNodes[i].AwsAzName = w.(string)
							}

							choiceTypeFound := false

							if v, ok := azNodesMapStrToI["inside_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.AWSVPCTwoInterfaceNodeType_InsideSubnet{}
								choiceInt.InsideSubnet = &ves_io_schema_views.CloudSubnetType{}
								azNodes[i].Choice = choiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := cs["existing_subnet_id"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceIntNew := &ves_io_schema_views.CloudSubnetType_ExistingSubnetId{}

											choiceInt.InsideSubnet.Choice = choiceIntNew

											choiceIntNew.ExistingSubnetId = v.(string)

										}

										if v, ok := cs["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceIntNew := &ves_io_schema_views.CloudSubnetType_SubnetParam{}
											choiceIntNew.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											choiceInt.InsideSubnet.Choice = choiceIntNew

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceIntNew.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceIntNew.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := azNodesMapStrToI["reserved_inside_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true

								if v.(bool) {
									choiceInt := &ves_io_schema_views.AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet{}
									choiceInt.ReservedInsideSubnet = &ves_io_schema.Empty{}
									azNodes[i].Choice = choiceInt
								}

							}

							if v, ok := azNodesMapStrToI["outside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								outsideSubnet := &ves_io_schema_views.CloudSubnetType{}
								azNodes[i].OutsideSubnet = outsideSubnet
								for _, set := range sl {
									if set != nil {
										outsideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := outsideSubnetMapStrToI["existing_subnet_id"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.CloudSubnetType_ExistingSubnetId{}

											outsideSubnet.Choice = choiceInt

											choiceInt.ExistingSubnetId = v.(string)

										}

										if v, ok := outsideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.CloudSubnetType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := azNodesMapStrToI["workload_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								workloadSubnet := &ves_io_schema_views.CloudSubnetType{}
								azNodes[i].WorkloadSubnet = workloadSubnet
								for _, set := range sl {
									if set != nil {
										workloadSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := workloadSubnetMapStrToI["existing_subnet_id"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.CloudSubnetType_ExistingSubnetId{}

											workloadSubnet.Choice = choiceInt

											choiceInt.ExistingSubnetId = v.(string)

										}

										if v, ok := workloadSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.CloudSubnetType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											workloadSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				deploymentTypeFound := false

				if v, ok := awsParametersMapStrToI["aws_cred"]; ok && !isIntfNil(v) && !deploymentTypeFound {

					deploymentTypeFound = true
					deploymentInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_AwsCred{}
					deploymentInt.AwsCred = &ves_io_schema_views.ObjectRefType{}
					awsParameters.Deployment = deploymentInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								deploymentInt.AwsCred.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								deploymentInt.AwsCred.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								deploymentInt.AwsCred.Tenant = v.(string)

							}

						}
					}

				}

				if w, ok := awsParametersMapStrToI["disk_size"]; ok && !isIntfNil(w) {
					awsParameters.DiskSize = uint32(w.(int))
				}

				if w, ok := awsParametersMapStrToI["instance_type"]; ok && !isIntfNil(w) {
					awsParameters.InstanceType = w.(string)
				}

				internetVipChoiceTypeFound := false

				if v, ok := awsParametersMapStrToI["disable_internet_vip"]; ok && !isIntfNil(v) && !internetVipChoiceTypeFound {

					internetVipChoiceTypeFound = true

					if v.(bool) {
						internetVipChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_DisableInternetVip{}
						internetVipChoiceInt.DisableInternetVip = &ves_io_schema.Empty{}
						awsParameters.InternetVipChoice = internetVipChoiceInt
					}

				}

				if v, ok := awsParametersMapStrToI["enable_internet_vip"]; ok && !isIntfNil(v) && !internetVipChoiceTypeFound {

					internetVipChoiceTypeFound = true

					if v.(bool) {
						internetVipChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_EnableInternetVip{}
						internetVipChoiceInt.EnableInternetVip = &ves_io_schema.Empty{}
						awsParameters.InternetVipChoice = internetVipChoiceInt
					}

				}

				securityGroupChoiceTypeFound := false

				if v, ok := awsParametersMapStrToI["custom_security_group"]; ok && !isIntfNil(v) && !securityGroupChoiceTypeFound {

					securityGroupChoiceTypeFound = true
					securityGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_CustomSecurityGroup{}
					securityGroupChoiceInt.CustomSecurityGroup = &ves_io_schema_views.SecurityGroupType{}
					awsParameters.SecurityGroupChoice = securityGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["inside_security_group_id"]; ok && !isIntfNil(v) {

								securityGroupChoiceInt.CustomSecurityGroup.InsideSecurityGroupId = v.(string)

							}

							if v, ok := cs["outside_security_group_id"]; ok && !isIntfNil(v) {

								securityGroupChoiceInt.CustomSecurityGroup.OutsideSecurityGroupId = v.(string)

							}

						}
					}

				}

				if v, ok := awsParametersMapStrToI["f5xc_security_group"]; ok && !isIntfNil(v) && !securityGroupChoiceTypeFound {

					securityGroupChoiceTypeFound = true

					if v.(bool) {
						securityGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_F5XcSecurityGroup{}
						securityGroupChoiceInt.F5XcSecurityGroup = &ves_io_schema.Empty{}
						awsParameters.SecurityGroupChoice = securityGroupChoiceInt
					}

				}

				serviceVpcChoiceTypeFound := false

				if v, ok := awsParametersMapStrToI["new_vpc"]; ok && !isIntfNil(v) && !serviceVpcChoiceTypeFound {

					serviceVpcChoiceTypeFound = true
					serviceVpcChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_NewVpc{}
					serviceVpcChoiceInt.NewVpc = &ves_io_schema_views.AWSVPCParamsType{}
					awsParameters.ServiceVpcChoice = serviceVpcChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							nameChoiceTypeFound := false

							if v, ok := cs["autogenerate"]; ok && !isIntfNil(v) && !nameChoiceTypeFound {

								nameChoiceTypeFound = true

								if v.(bool) {
									nameChoiceInt := &ves_io_schema_views.AWSVPCParamsType_Autogenerate{}
									nameChoiceInt.Autogenerate = &ves_io_schema.Empty{}
									serviceVpcChoiceInt.NewVpc.NameChoice = nameChoiceInt
								}

							}

							if v, ok := cs["name_tag"]; ok && !isIntfNil(v) && !nameChoiceTypeFound {

								nameChoiceTypeFound = true
								nameChoiceInt := &ves_io_schema_views.AWSVPCParamsType_NameTag{}

								serviceVpcChoiceInt.NewVpc.NameChoice = nameChoiceInt

								nameChoiceInt.NameTag = v.(string)

							}

							if v, ok := cs["primary_ipv4"]; ok && !isIntfNil(v) {

								serviceVpcChoiceInt.NewVpc.PrimaryIpv4 = v.(string)

							}

						}
					}

				}

				if v, ok := awsParametersMapStrToI["vpc_id"]; ok && !isIntfNil(v) && !serviceVpcChoiceTypeFound {

					serviceVpcChoiceTypeFound = true
					serviceVpcChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_VpcId{}

					awsParameters.ServiceVpcChoice = serviceVpcChoiceInt

					serviceVpcChoiceInt.VpcId = v.(string)

				}

				if w, ok := awsParametersMapStrToI["ssh_key"]; ok && !isIntfNil(w) {
					awsParameters.SshKey = w.(string)
				}

				tgwChoiceTypeFound := false

				if v, ok := awsParametersMapStrToI["existing_tgw"]; ok && !isIntfNil(v) && !tgwChoiceTypeFound {

					tgwChoiceTypeFound = true
					tgwChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_ExistingTgw{}
					tgwChoiceInt.ExistingTgw = &ves_io_schema_views.ExistingTGWType{}
					awsParameters.TgwChoice = tgwChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["tgw_asn"]; ok && !isIntfNil(v) {

								tgwChoiceInt.ExistingTgw.TgwAsn = uint32(v.(int))

							}

							if v, ok := cs["tgw_id"]; ok && !isIntfNil(v) {

								tgwChoiceInt.ExistingTgw.TgwId = v.(string)

							}

							if v, ok := cs["volterra_site_asn"]; ok && !isIntfNil(v) {

								tgwChoiceInt.ExistingTgw.VolterraSiteAsn = uint32(v.(int))

							}

						}
					}

				}

				if v, ok := awsParametersMapStrToI["new_tgw"]; ok && !isIntfNil(v) && !tgwChoiceTypeFound {

					tgwChoiceTypeFound = true
					tgwChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_NewTgw{}
					tgwChoiceInt.NewTgw = &ves_io_schema_views.TGWParamsType{}
					awsParameters.TgwChoice = tgwChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							asnChoiceTypeFound := false

							if v, ok := cs["system_generated"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

								asnChoiceTypeFound = true

								if v.(bool) {
									asnChoiceInt := &ves_io_schema_views.TGWParamsType_SystemGenerated{}
									asnChoiceInt.SystemGenerated = &ves_io_schema.Empty{}
									tgwChoiceInt.NewTgw.AsnChoice = asnChoiceInt
								}

							}

							if v, ok := cs["user_assigned"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

								asnChoiceTypeFound = true
								asnChoiceInt := &ves_io_schema_views.TGWParamsType_UserAssigned{}
								asnChoiceInt.UserAssigned = &ves_io_schema_views.TGWAssignedASNType{}
								tgwChoiceInt.NewTgw.AsnChoice = asnChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["tgw_asn"]; ok && !isIntfNil(v) {

											asnChoiceInt.UserAssigned.TgwAsn = uint32(v.(int))

										}

										if v, ok := cs["volterra_site_asn"]; ok && !isIntfNil(v) {

											asnChoiceInt.UserAssigned.VolterraSiteAsn = uint32(v.(int))

										}

									}
								}

							}

						}
					}

				}

				tgwCidrChoiceTypeFound := false

				if v, ok := awsParametersMapStrToI["reserved_tgw_cidr"]; ok && !isIntfNil(v) && !tgwCidrChoiceTypeFound {

					tgwCidrChoiceTypeFound = true

					if v.(bool) {
						tgwCidrChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_ReservedTgwCidr{}
						tgwCidrChoiceInt.ReservedTgwCidr = &ves_io_schema.Empty{}
						awsParameters.TgwCidrChoice = tgwCidrChoiceInt
					}

				}

				if v, ok := awsParametersMapStrToI["tgw_cidr"]; ok && !isIntfNil(v) && !tgwCidrChoiceTypeFound {

					tgwCidrChoiceTypeFound = true
					tgwCidrChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_TgwCidr{}
					tgwCidrChoiceInt.TgwCidr = &ves_io_schema_views.CloudSubnetParamType{}
					awsParameters.TgwCidrChoice = tgwCidrChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

								tgwCidrChoiceInt.TgwCidr.Ipv4 = v.(string)

							}

							if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

								tgwCidrChoiceInt.TgwCidr.Ipv6 = v.(string)

							}

						}
					}

				}

				workerNodesTypeFound := false

				if v, ok := awsParametersMapStrToI["no_worker_nodes"]; ok && !isIntfNil(v) && !workerNodesTypeFound {

					workerNodesTypeFound = true

					if v.(bool) {
						workerNodesInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_NoWorkerNodes{}
						workerNodesInt.NoWorkerNodes = &ves_io_schema.Empty{}
						awsParameters.WorkerNodes = workerNodesInt
					}

				}

				if v, ok := awsParametersMapStrToI["nodes_per_az"]; ok && !isIntfNil(v) && !workerNodesTypeFound {

					workerNodesTypeFound = true
					workerNodesInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_NodesPerAz{}

					awsParameters.WorkerNodes = workerNodesInt

					workerNodesInt.NodesPerAz = uint32(v.(int))

				}

				if v, ok := awsParametersMapStrToI["total_nodes"]; ok && !isIntfNil(v) && !workerNodesTypeFound {

					workerNodesTypeFound = true
					workerNodesInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCType_TotalNodes{}

					awsParameters.WorkerNodes = workerNodesInt

					workerNodesInt.TotalNodes = uint32(v.(int))

				}

			}
		}

	}

	//blocked_services_choice

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("block_all_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_aws_tgw_site.CreateSpecType_BlockAllServices{}
			blockedServicesChoiceInt.BlockAllServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("blocked_services"); ok && !isIntfNil(v) && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_aws_tgw_site.CreateSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		createSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
					blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
					for i, set := range sl {
						if set != nil {
							blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
							blockedSeviceMapStrToI := set.(map[string]interface{})

							blockedServicesValueTypeChoiceTypeFound := false

							if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
									blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
									blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
									blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

								blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_aws_tgw_site.CreateSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	//coordinates
	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		coordinates := &ves_io_schema_site.Coordinates{}
		createSpec.Coordinates = coordinates
		for _, set := range sl {
			if set != nil {
				coordinatesMapStrToI := set.(map[string]interface{})

				if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
					coordinates.Latitude = float32(w.(float64))
				}

				if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
					coordinates.Longitude = float32(w.(float64))
				}

			}
		}

	}

	//custom_dns
	if v, ok := d.GetOk("custom_dns"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		customDns := &ves_io_schema_views.CustomDNS{}
		createSpec.CustomDns = customDns
		for _, set := range sl {
			if set != nil {
				customDnsMapStrToI := set.(map[string]interface{})

				if w, ok := customDnsMapStrToI["inside_nameserver"]; ok && !isIntfNil(w) {
					customDns.InsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["inside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.InsideNameserverV6 = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserverV6 = w.(string)
				}

			}
		}

	}

	//direct_connect_choice

	directConnectChoiceTypeFound := false

	if v, ok := d.GetOk("direct_connect_disabled"); ok && !directConnectChoiceTypeFound {

		directConnectChoiceTypeFound = true

		if v.(bool) {
			directConnectChoiceInt := &ves_io_schema_views_aws_tgw_site.CreateSpecType_DirectConnectDisabled{}
			directConnectChoiceInt.DirectConnectDisabled = &ves_io_schema.Empty{}
			createSpec.DirectConnectChoice = directConnectChoiceInt
		}

	}

	if v, ok := d.GetOk("direct_connect_enabled"); ok && !isIntfNil(v) && !directConnectChoiceTypeFound {

		directConnectChoiceTypeFound = true
		directConnectChoiceInt := &ves_io_schema_views_aws_tgw_site.CreateSpecType_DirectConnectEnabled{}
		directConnectChoiceInt.DirectConnectEnabled = &ves_io_schema_views.DirectConnectConfigType{}
		createSpec.DirectConnectChoice = directConnectChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				asnChoiceTypeFound := false

				if v, ok := cs["auto_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

					asnChoiceTypeFound = true

					if v.(bool) {
						asnChoiceInt := &ves_io_schema_views.DirectConnectConfigType_AutoAsn{}
						asnChoiceInt.AutoAsn = &ves_io_schema.Empty{}
						directConnectChoiceInt.DirectConnectEnabled.AsnChoice = asnChoiceInt
					}

				}

				if v, ok := cs["custom_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

					asnChoiceTypeFound = true
					asnChoiceInt := &ves_io_schema_views.DirectConnectConfigType_CustomAsn{}

					directConnectChoiceInt.DirectConnectEnabled.AsnChoice = asnChoiceInt

					asnChoiceInt.CustomAsn = uint32(v.(int))

				}

				vifChoiceTypeFound := false

				if v, ok := cs["hosted_vifs"]; ok && !isIntfNil(v) && !vifChoiceTypeFound {

					vifChoiceTypeFound = true
					vifChoiceInt := &ves_io_schema_views.DirectConnectConfigType_HostedVifs{}
					vifChoiceInt.HostedVifs = &ves_io_schema_views.HostedVIFConfigType{}
					directConnectChoiceInt.DirectConnectEnabled.VifChoice = vifChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							connectivityOptionsTypeFound := false

							if v, ok := cs["site_registration_over_direct_connect"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

								connectivityOptionsTypeFound = true
								connectivityOptionsInt := &ves_io_schema_views.HostedVIFConfigType_SiteRegistrationOverDirectConnect{}
								connectivityOptionsInt.SiteRegistrationOverDirectConnect = &ves_io_schema_views.CloudLinkADNType{}
								vifChoiceInt.HostedVifs.ConnectivityOptions = connectivityOptionsInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["cloudlink_network_name"]; ok && !isIntfNil(v) {

											connectivityOptionsInt.SiteRegistrationOverDirectConnect.CloudlinkNetworkName = v.(string)

										}

									}
								}

							}

							if v, ok := cs["site_registration_over_internet"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

								connectivityOptionsTypeFound = true

								if v.(bool) {
									connectivityOptionsInt := &ves_io_schema_views.HostedVIFConfigType_SiteRegistrationOverInternet{}
									connectivityOptionsInt.SiteRegistrationOverInternet = &ves_io_schema.Empty{}
									vifChoiceInt.HostedVifs.ConnectivityOptions = connectivityOptionsInt
								}

							}

							if v, ok := cs["vif_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								vifList := make([]*ves_io_schema_views.VifRegionConfig, len(sl))
								vifChoiceInt.HostedVifs.VifList = vifList
								for i, set := range sl {
									if set != nil {
										vifList[i] = &ves_io_schema_views.VifRegionConfig{}
										vifListMapStrToI := set.(map[string]interface{})

										if w, ok := vifListMapStrToI["vif_id"]; ok && !isIntfNil(w) {
											vifList[i].VifId = w.(string)
										}

										vifRegionChoiceTypeFound := false

										if v, ok := vifListMapStrToI["other_region"]; ok && !isIntfNil(v) && !vifRegionChoiceTypeFound {

											vifRegionChoiceTypeFound = true
											vifRegionChoiceInt := &ves_io_schema_views.VifRegionConfig_OtherRegion{}

											vifList[i].VifRegionChoice = vifRegionChoiceInt

											vifRegionChoiceInt.OtherRegion = v.(string)

										}

										if v, ok := vifListMapStrToI["same_as_site_region"]; ok && !isIntfNil(v) && !vifRegionChoiceTypeFound {

											vifRegionChoiceTypeFound = true

											if v.(bool) {
												vifRegionChoiceInt := &ves_io_schema_views.VifRegionConfig_SameAsSiteRegion{}
												vifRegionChoiceInt.SameAsSiteRegion = &ves_io_schema.Empty{}
												vifList[i].VifRegionChoice = vifRegionChoiceInt
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["standard_vifs"]; ok && !isIntfNil(v) && !vifChoiceTypeFound {

					vifChoiceTypeFound = true

					if v.(bool) {
						vifChoiceInt := &ves_io_schema_views.DirectConnectConfigType_StandardVifs{}
						vifChoiceInt.StandardVifs = &ves_io_schema.Empty{}
						directConnectChoiceInt.DirectConnectEnabled.VifChoice = vifChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("private_connectivity"); ok && !isIntfNil(v) && !directConnectChoiceTypeFound {

		directConnectChoiceTypeFound = true
		directConnectChoiceInt := &ves_io_schema_views_aws_tgw_site.CreateSpecType_PrivateConnectivity{}
		directConnectChoiceInt.PrivateConnectivity = &ves_io_schema_views.PrivateConnectConfigType{}
		createSpec.DirectConnectChoice = directConnectChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["cloud_link"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					cloudLink := &ves_io_schema_views.ObjectRefType{}
					directConnectChoiceInt.PrivateConnectivity.CloudLink = cloudLink
					for _, set := range sl {
						if set != nil {
							cloudLinkMapStrToI := set.(map[string]interface{})

							if w, ok := cloudLinkMapStrToI["name"]; ok && !isIntfNil(w) {
								cloudLink.Name = w.(string)
							}

							if w, ok := cloudLinkMapStrToI["namespace"]; ok && !isIntfNil(w) {
								cloudLink.Namespace = w.(string)
							}

							if w, ok := cloudLinkMapStrToI["tenant"]; ok && !isIntfNil(w) {
								cloudLink.Tenant = w.(string)
							}

						}
					}

				}

				networkOptionsTypeFound := false

				if v, ok := cs["inside"]; ok && !isIntfNil(v) && !networkOptionsTypeFound {

					networkOptionsTypeFound = true

					if v.(bool) {
						networkOptionsInt := &ves_io_schema_views.PrivateConnectConfigType_Inside{}
						networkOptionsInt.Inside = &ves_io_schema.Empty{}
						directConnectChoiceInt.PrivateConnectivity.NetworkOptions = networkOptionsInt
					}

				}

				if v, ok := cs["outside"]; ok && !isIntfNil(v) && !networkOptionsTypeFound {

					networkOptionsTypeFound = true

					if v.(bool) {
						networkOptionsInt := &ves_io_schema_views.PrivateConnectConfigType_Outside{}
						networkOptionsInt.Outside = &ves_io_schema.Empty{}
						directConnectChoiceInt.PrivateConnectivity.NetworkOptions = networkOptionsInt
					}

				}

			}
		}

	}

	//kubernetes_upgrade_drain
	if v, ok := d.GetOk("kubernetes_upgrade_drain"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		kubernetesUpgradeDrain := &ves_io_schema_views.KubernetesUpgradeDrain{}
		createSpec.KubernetesUpgradeDrain = kubernetesUpgradeDrain
		for _, set := range sl {
			if set != nil {
				kubernetesUpgradeDrainMapStrToI := set.(map[string]interface{})

				kubernetesUpgradeDrainEnableChoiceTypeFound := false

				if v, ok := kubernetesUpgradeDrainMapStrToI["disable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true

					if v.(bool) {
						kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_DisableUpgradeDrain{}
						kubernetesUpgradeDrainEnableChoiceInt.DisableUpgradeDrain = &ves_io_schema.Empty{}
						kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt
					}

				}

				if v, ok := kubernetesUpgradeDrainMapStrToI["enable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true
					kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_EnableUpgradeDrain{}
					kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain = &ves_io_schema_views.KubernetesUpgradeDrainConfig{}
					kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							drainMaxUnavailableChoiceTypeFound := false

							if v, ok := cs["drain_max_unavailable_node_count"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodeCount = uint32(v.(int))

							}

							if v, ok := cs["drain_node_timeout"]; ok && !isIntfNil(v) {

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainNodeTimeout = uint32(v.(int))

							}

						}
					}

				}

			}
		}

	}

	//logs_receiver_choice

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !isIntfNil(v) && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_aws_tgw_site.CreateSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		createSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_aws_tgw_site.CreateSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			createSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	//offline_survivability_mode
	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		createSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			if set != nil {
				offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

				offlineSurvivabilityModeChoiceTypeFound := false

				if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

				if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

			}
		}

	}

	//os
	if v, ok := d.GetOk("os"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		os := &ves_io_schema_views.OperatingSystemType{}
		createSpec.Os = os
		for _, set := range sl {
			if set != nil {
				osMapStrToI := set.(map[string]interface{})

				operatingSystemVersionChoiceTypeFound := false

				if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

					operatingSystemVersionChoiceTypeFound = true

					if v.(bool) {
						operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
						operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
						os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
					}

				}

				if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

					operatingSystemVersionChoiceTypeFound = true
					operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

					os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

					operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

				}

			}
		}

	}

	//performance_enhancement_mode
	if v, ok := d.GetOk("performance_enhancement_mode"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
		createSpec.PerformanceEnhancementMode = performanceEnhancementMode
		for _, set := range sl {
			if set != nil {
				performanceEnhancementModeMapStrToI := set.(map[string]interface{})

				perfModeChoiceTypeFound := false

				if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

					perfModeChoiceTypeFound = true
					perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
					perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
					performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
									perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

							if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
									perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

						}
					}

				}

				if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

					perfModeChoiceTypeFound = true

					if v.(bool) {
						perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
						perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
						performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
					}

				}

			}
		}

	}

	//sw
	if v, ok := d.GetOk("sw"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		sw := &ves_io_schema_views.VolterraSoftwareType{}
		createSpec.Sw = sw
		for _, set := range sl {
			if set != nil {
				swMapStrToI := set.(map[string]interface{})

				volterraSwVersionChoiceTypeFound := false

				if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true

					if v.(bool) {
						volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
						volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
						sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
					}

				}

				if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

					sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

					volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

				}

			}
		}

	}

	//tags
	if v, ok := d.GetOk("tags"); ok && !isIntfNil(v) {

		ms := map[string]string{}
		for k, v := range v.(map[string]interface{}) {
			ms[k] = v.(string)
		}
		createSpec.Tags = ms
	}

	//tgw_security
	if v, ok := d.GetOk("tgw_security"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		tgwSecurity := &ves_io_schema_views_aws_tgw_site.SecurityConfigType{}
		createSpec.TgwSecurity = tgwSecurity
		for _, set := range sl {
			if set != nil {
				tgwSecurityMapStrToI := set.(map[string]interface{})

				eastWestServicePolicyChoiceTypeFound := false

				if v, ok := tgwSecurityMapStrToI["active_east_west_service_policies"]; ok && !isIntfNil(v) && !eastWestServicePolicyChoiceTypeFound {

					eastWestServicePolicyChoiceTypeFound = true
					eastWestServicePolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ActiveEastWestServicePolicies{}
					eastWestServicePolicyChoiceInt.ActiveEastWestServicePolicies = &ves_io_schema_views_aws_tgw_site.ActiveServicePoliciesType{}
					tgwSecurity.EastWestServicePolicyChoice = eastWestServicePolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["service_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								servicePoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								eastWestServicePolicyChoiceInt.ActiveEastWestServicePolicies.ServicePolicies = servicePoliciesInt
								for i, ps := range sl {

									spMapToStrVal := ps.(map[string]interface{})
									servicePoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := spMapToStrVal["name"]; ok && !isIntfNil(v) {
										servicePoliciesInt[i].Name = v.(string)
									}

									if v, ok := spMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										servicePoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := spMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										servicePoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := tgwSecurityMapStrToI["east_west_service_policy_allow_all"]; ok && !isIntfNil(v) && !eastWestServicePolicyChoiceTypeFound {

					eastWestServicePolicyChoiceTypeFound = true

					if v.(bool) {
						eastWestServicePolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_EastWestServicePolicyAllowAll{}
						eastWestServicePolicyChoiceInt.EastWestServicePolicyAllowAll = &ves_io_schema.Empty{}
						tgwSecurity.EastWestServicePolicyChoice = eastWestServicePolicyChoiceInt
					}

				}

				if v, ok := tgwSecurityMapStrToI["no_east_west_policy"]; ok && !isIntfNil(v) && !eastWestServicePolicyChoiceTypeFound {

					eastWestServicePolicyChoiceTypeFound = true

					if v.(bool) {
						eastWestServicePolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_NoEastWestPolicy{}
						eastWestServicePolicyChoiceInt.NoEastWestPolicy = &ves_io_schema.Empty{}
						tgwSecurity.EastWestServicePolicyChoice = eastWestServicePolicyChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := tgwSecurityMapStrToI["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					tgwSecurity.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := tgwSecurityMapStrToI["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						tgwSecurity.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := tgwSecurityMapStrToI["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						tgwSecurity.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := tgwSecurityMapStrToI["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					tgwSecurity.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := tgwSecurityMapStrToI["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					tgwSecurity.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := tgwSecurityMapStrToI["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						tgwSecurity.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

			}
		}

	}

	//vn_config
	if v, ok := d.GetOk("vn_config"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		vnConfig := &ves_io_schema_views_aws_tgw_site.VnConfiguration{}
		createSpec.VnConfig = vnConfig
		for _, set := range sl {
			if set != nil {
				vnConfigMapStrToI := set.(map[string]interface{})

				if v, ok := vnConfigMapStrToI["allowed_vip_port"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					allowedVipPort := &ves_io_schema_views.AllowedVIPPorts{}
					vnConfig.AllowedVipPort = allowedVipPort
					for _, set := range sl {
						if set != nil {
							allowedVipPortMapStrToI := set.(map[string]interface{})

							portChoiceTypeFound := false

							if v, ok := allowedVipPortMapStrToI["custom_ports"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true
								portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_CustomPorts{}
								portChoiceInt.CustomPorts = &ves_io_schema_views.CustomPorts{}
								allowedVipPort.PortChoice = portChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["port_ranges"]; ok && !isIntfNil(v) {

											portChoiceInt.CustomPorts.PortRanges = v.(string)

										}

									}
								}

							}

							if v, ok := allowedVipPortMapStrToI["disable_allowed_vip_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_DisableAllowedVipPort{}
									portChoiceInt.DisableAllowedVipPort = &ves_io_schema.Empty{}
									allowedVipPort.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortMapStrToI["use_http_https_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpHttpsPort{}
									portChoiceInt.UseHttpHttpsPort = &ves_io_schema.Empty{}
									allowedVipPort.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortMapStrToI["use_http_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpPort{}
									portChoiceInt.UseHttpPort = &ves_io_schema.Empty{}
									allowedVipPort.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortMapStrToI["use_https_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpsPort{}
									portChoiceInt.UseHttpsPort = &ves_io_schema.Empty{}
									allowedVipPort.PortChoice = portChoiceInt
								}

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["allowed_vip_port_sli"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					allowedVipPortSli := &ves_io_schema_views.AllowedVIPPorts{}
					vnConfig.AllowedVipPortSli = allowedVipPortSli
					for _, set := range sl {
						if set != nil {
							allowedVipPortSliMapStrToI := set.(map[string]interface{})

							portChoiceTypeFound := false

							if v, ok := allowedVipPortSliMapStrToI["custom_ports"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true
								portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_CustomPorts{}
								portChoiceInt.CustomPorts = &ves_io_schema_views.CustomPorts{}
								allowedVipPortSli.PortChoice = portChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["port_ranges"]; ok && !isIntfNil(v) {

											portChoiceInt.CustomPorts.PortRanges = v.(string)

										}

									}
								}

							}

							if v, ok := allowedVipPortSliMapStrToI["disable_allowed_vip_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_DisableAllowedVipPort{}
									portChoiceInt.DisableAllowedVipPort = &ves_io_schema.Empty{}
									allowedVipPortSli.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortSliMapStrToI["use_http_https_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpHttpsPort{}
									portChoiceInt.UseHttpHttpsPort = &ves_io_schema.Empty{}
									allowedVipPortSli.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortSliMapStrToI["use_http_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpPort{}
									portChoiceInt.UseHttpPort = &ves_io_schema.Empty{}
									allowedVipPortSli.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortSliMapStrToI["use_https_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpsPort{}
									portChoiceInt.UseHttpsPort = &ves_io_schema.Empty{}
									allowedVipPortSli.PortChoice = portChoiceInt
								}

							}

						}
					}

				}

				dcClusterGroupChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["dc_cluster_group_inside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_DcClusterGroupInsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupInsideVn = &ves_io_schema_views.ObjectRefType{}
					vnConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["dc_cluster_group_outside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_DcClusterGroupOutsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupOutsideVn = &ves_io_schema_views.ObjectRefType{}
					vnConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						vnConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					vnConfig.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						vnConfig.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				insideStaticRouteChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true
					insideStaticRouteChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_InsideStaticRoutes{}
					insideStaticRouteChoiceInt.InsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					vnConfig.InsideStaticRouteChoice = insideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								insideStaticRouteChoiceInt.InsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["no_inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						insideStaticRouteChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_NoInsideStaticRoutes{}
						insideStaticRouteChoiceInt.NoInsideStaticRoutes = &ves_io_schema.Empty{}
						vnConfig.InsideStaticRouteChoice = insideStaticRouteChoiceInt
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						vnConfig.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := vnConfigMapStrToI["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					vnConfig.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						vnConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := vnConfigMapStrToI["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						vnConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

			}
		}

	}

	//vpc_attachments
	if v, ok := d.GetOk("vpc_attachments"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		vpcAttachments := &ves_io_schema_views_aws_tgw_site.VPCAttachmentListType{}
		createSpec.VpcAttachments = vpcAttachments
		for _, set := range sl {
			if set != nil {
				vpcAttachmentsMapStrToI := set.(map[string]interface{})

				if v, ok := vpcAttachmentsMapStrToI["vpc_list"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					vpcList := make([]*ves_io_schema_views_aws_tgw_site.VPCAttachmentType, len(sl))
					vpcAttachments.VpcList = vpcList
					for i, set := range sl {
						if set != nil {
							vpcList[i] = &ves_io_schema_views_aws_tgw_site.VPCAttachmentType{}
							vpcListMapStrToI := set.(map[string]interface{})

							if w, ok := vpcListMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								vpcList[i].Labels = ms
							}

							if w, ok := vpcListMapStrToI["vpc_id"]; ok && !isIntfNil(w) {
								vpcList[i].VpcId = w.(string)
							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Creating Volterra AwsTgwSite object with struct: %+v", createReq)

	createAwsTgwSiteResp, err := client.CreateObject(context.Background(), ves_io_schema_views_aws_tgw_site.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating AwsTgwSite: %s", err)
	}
	d.SetId(createAwsTgwSiteResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraAwsTgwSiteRead(d, meta)
}

func resourceVolterraAwsTgwSiteRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_aws_tgw_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] AwsTgwSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra AwsTgwSite %q: %s", d.Id(), err)
	}
	return setAwsTgwSiteFields(client, d, resp)
}

func setAwsTgwSiteFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraAwsTgwSiteUpdate updates AwsTgwSite resource
func resourceVolterraAwsTgwSiteUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_aws_tgw_site.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_aws_tgw_site.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("aws_parameters"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		awsParameters := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType{}
		updateSpec.AwsParameters = awsParameters
		for _, set := range sl {
			if set != nil {
				awsParametersMapStrToI := set.(map[string]interface{})

				if w, ok := awsParametersMapStrToI["aws_region"]; ok && !isIntfNil(w) {
					awsParameters.AwsRegion = w.(string)
				}

				if v, ok := awsParametersMapStrToI["az_nodes"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					azNodes := make([]*ves_io_schema_views.AWSVPCTwoInterfaceNodeType, len(sl))
					awsParameters.AzNodes = azNodes
					for i, set := range sl {
						if set != nil {
							azNodes[i] = &ves_io_schema_views.AWSVPCTwoInterfaceNodeType{}
							azNodesMapStrToI := set.(map[string]interface{})

							if w, ok := azNodesMapStrToI["aws_az_name"]; ok && !isIntfNil(w) {
								azNodes[i].AwsAzName = w.(string)
							}

							choiceTypeFound := false

							if v, ok := azNodesMapStrToI["inside_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.AWSVPCTwoInterfaceNodeType_InsideSubnet{}
								choiceInt.InsideSubnet = &ves_io_schema_views.CloudSubnetType{}
								azNodes[i].Choice = choiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := cs["existing_subnet_id"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceIntNew := &ves_io_schema_views.CloudSubnetType_ExistingSubnetId{}

											choiceInt.InsideSubnet.Choice = choiceIntNew

											choiceIntNew.ExistingSubnetId = v.(string)

										}

										if v, ok := cs["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceIntNew := &ves_io_schema_views.CloudSubnetType_SubnetParam{}
											choiceIntNew.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											choiceInt.InsideSubnet.Choice = choiceIntNew

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceIntNew.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceIntNew.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := azNodesMapStrToI["reserved_inside_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true

								if v.(bool) {
									choiceInt := &ves_io_schema_views.AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet{}
									choiceInt.ReservedInsideSubnet = &ves_io_schema.Empty{}
									azNodes[i].Choice = choiceInt
								}

							}

							if v, ok := azNodesMapStrToI["outside_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								outsideSubnet := &ves_io_schema_views.CloudSubnetType{}
								azNodes[i].OutsideSubnet = outsideSubnet
								for _, set := range sl {
									if set != nil {
										outsideSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := outsideSubnetMapStrToI["existing_subnet_id"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.CloudSubnetType_ExistingSubnetId{}

											outsideSubnet.Choice = choiceInt

											choiceInt.ExistingSubnetId = v.(string)

										}

										if v, ok := outsideSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.CloudSubnetType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											outsideSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := azNodesMapStrToI["workload_subnet"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								workloadSubnet := &ves_io_schema_views.CloudSubnetType{}
								azNodes[i].WorkloadSubnet = workloadSubnet
								for _, set := range sl {
									if set != nil {
										workloadSubnetMapStrToI := set.(map[string]interface{})

										choiceTypeFound := false

										if v, ok := workloadSubnetMapStrToI["existing_subnet_id"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.CloudSubnetType_ExistingSubnetId{}

											workloadSubnet.Choice = choiceInt

											choiceInt.ExistingSubnetId = v.(string)

										}

										if v, ok := workloadSubnetMapStrToI["subnet_param"]; ok && !isIntfNil(v) && !choiceTypeFound {

											choiceTypeFound = true
											choiceInt := &ves_io_schema_views.CloudSubnetType_SubnetParam{}
											choiceInt.SubnetParam = &ves_io_schema_views.CloudSubnetParamType{}
											workloadSubnet.Choice = choiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["ipv4"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv4 = v.(string)

													}

													if v, ok := cs["ipv6"]; ok && !isIntfNil(v) {

														choiceInt.SubnetParam.Ipv6 = v.(string)

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				deploymentTypeFound := false

				if v, ok := awsParametersMapStrToI["aws_cred"]; ok && !isIntfNil(v) && !deploymentTypeFound {

					deploymentTypeFound = true
					deploymentInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_AwsCred{}
					deploymentInt.AwsCred = &ves_io_schema_views.ObjectRefType{}
					awsParameters.Deployment = deploymentInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								deploymentInt.AwsCred.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								deploymentInt.AwsCred.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								deploymentInt.AwsCred.Tenant = v.(string)

							}

						}
					}

				}

				if w, ok := awsParametersMapStrToI["disk_size"]; ok && !isIntfNil(w) {
					awsParameters.DiskSize = uint32(w.(int))
				}

				if w, ok := awsParametersMapStrToI["instance_type"]; ok && !isIntfNil(w) {
					awsParameters.InstanceType = w.(string)
				}

				internetVipChoiceTypeFound := false

				if v, ok := awsParametersMapStrToI["disable_internet_vip"]; ok && !isIntfNil(v) && !internetVipChoiceTypeFound {

					internetVipChoiceTypeFound = true

					if v.(bool) {
						internetVipChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_DisableInternetVip{}
						internetVipChoiceInt.DisableInternetVip = &ves_io_schema.Empty{}
						awsParameters.InternetVipChoice = internetVipChoiceInt
					}

				}

				if v, ok := awsParametersMapStrToI["enable_internet_vip"]; ok && !isIntfNil(v) && !internetVipChoiceTypeFound {

					internetVipChoiceTypeFound = true

					if v.(bool) {
						internetVipChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_EnableInternetVip{}
						internetVipChoiceInt.EnableInternetVip = &ves_io_schema.Empty{}
						awsParameters.InternetVipChoice = internetVipChoiceInt
					}

				}

				securityGroupChoiceTypeFound := false

				if v, ok := awsParametersMapStrToI["custom_security_group"]; ok && !isIntfNil(v) && !securityGroupChoiceTypeFound {

					securityGroupChoiceTypeFound = true
					securityGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_CustomSecurityGroup{}
					securityGroupChoiceInt.CustomSecurityGroup = &ves_io_schema_views.SecurityGroupType{}
					awsParameters.SecurityGroupChoice = securityGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["inside_security_group_id"]; ok && !isIntfNil(v) {

								securityGroupChoiceInt.CustomSecurityGroup.InsideSecurityGroupId = v.(string)

							}

							if v, ok := cs["outside_security_group_id"]; ok && !isIntfNil(v) {

								securityGroupChoiceInt.CustomSecurityGroup.OutsideSecurityGroupId = v.(string)

							}

						}
					}

				}

				if v, ok := awsParametersMapStrToI["f5xc_security_group"]; ok && !isIntfNil(v) && !securityGroupChoiceTypeFound {

					securityGroupChoiceTypeFound = true

					if v.(bool) {
						securityGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_F5XcSecurityGroup{}
						securityGroupChoiceInt.F5XcSecurityGroup = &ves_io_schema.Empty{}
						awsParameters.SecurityGroupChoice = securityGroupChoiceInt
					}

				}

				serviceVpcChoiceTypeFound := false

				if v, ok := awsParametersMapStrToI["new_vpc"]; ok && !isIntfNil(v) && !serviceVpcChoiceTypeFound {

					serviceVpcChoiceTypeFound = true
					serviceVpcChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_NewVpc{}
					serviceVpcChoiceInt.NewVpc = &ves_io_schema_views.AWSVPCParamsType{}
					awsParameters.ServiceVpcChoice = serviceVpcChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							nameChoiceTypeFound := false

							if v, ok := cs["autogenerate"]; ok && !isIntfNil(v) && !nameChoiceTypeFound {

								nameChoiceTypeFound = true

								if v.(bool) {
									nameChoiceInt := &ves_io_schema_views.AWSVPCParamsType_Autogenerate{}
									nameChoiceInt.Autogenerate = &ves_io_schema.Empty{}
									serviceVpcChoiceInt.NewVpc.NameChoice = nameChoiceInt
								}

							}

							if v, ok := cs["name_tag"]; ok && !isIntfNil(v) && !nameChoiceTypeFound {

								nameChoiceTypeFound = true
								nameChoiceInt := &ves_io_schema_views.AWSVPCParamsType_NameTag{}

								serviceVpcChoiceInt.NewVpc.NameChoice = nameChoiceInt

								nameChoiceInt.NameTag = v.(string)

							}

							if v, ok := cs["primary_ipv4"]; ok && !isIntfNil(v) {

								serviceVpcChoiceInt.NewVpc.PrimaryIpv4 = v.(string)

							}

						}
					}

				}

				if v, ok := awsParametersMapStrToI["vpc_id"]; ok && !isIntfNil(v) && !serviceVpcChoiceTypeFound {

					serviceVpcChoiceTypeFound = true
					serviceVpcChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_VpcId{}

					awsParameters.ServiceVpcChoice = serviceVpcChoiceInt

					serviceVpcChoiceInt.VpcId = v.(string)

				}

				if w, ok := awsParametersMapStrToI["ssh_key"]; ok && !isIntfNil(w) {
					awsParameters.SshKey = w.(string)
				}

				tgwChoiceTypeFound := false

				if v, ok := awsParametersMapStrToI["existing_tgw"]; ok && !isIntfNil(v) && !tgwChoiceTypeFound {

					tgwChoiceTypeFound = true
					tgwChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_ExistingTgw{}
					tgwChoiceInt.ExistingTgw = &ves_io_schema_views.ExistingTGWType{}
					awsParameters.TgwChoice = tgwChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["tgw_asn"]; ok && !isIntfNil(v) {

								tgwChoiceInt.ExistingTgw.TgwAsn = uint32(v.(int))

							}

							if v, ok := cs["tgw_id"]; ok && !isIntfNil(v) {

								tgwChoiceInt.ExistingTgw.TgwId = v.(string)

							}

							if v, ok := cs["volterra_site_asn"]; ok && !isIntfNil(v) {

								tgwChoiceInt.ExistingTgw.VolterraSiteAsn = uint32(v.(int))

							}

						}
					}

				}

				if v, ok := awsParametersMapStrToI["new_tgw"]; ok && !isIntfNil(v) && !tgwChoiceTypeFound {

					tgwChoiceTypeFound = true
					tgwChoiceInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_NewTgw{}
					tgwChoiceInt.NewTgw = &ves_io_schema_views.TGWParamsType{}
					awsParameters.TgwChoice = tgwChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							asnChoiceTypeFound := false

							if v, ok := cs["system_generated"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

								asnChoiceTypeFound = true

								if v.(bool) {
									asnChoiceInt := &ves_io_schema_views.TGWParamsType_SystemGenerated{}
									asnChoiceInt.SystemGenerated = &ves_io_schema.Empty{}
									tgwChoiceInt.NewTgw.AsnChoice = asnChoiceInt
								}

							}

							if v, ok := cs["user_assigned"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

								asnChoiceTypeFound = true
								asnChoiceInt := &ves_io_schema_views.TGWParamsType_UserAssigned{}
								asnChoiceInt.UserAssigned = &ves_io_schema_views.TGWAssignedASNType{}
								tgwChoiceInt.NewTgw.AsnChoice = asnChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["tgw_asn"]; ok && !isIntfNil(v) {

											asnChoiceInt.UserAssigned.TgwAsn = uint32(v.(int))

										}

										if v, ok := cs["volterra_site_asn"]; ok && !isIntfNil(v) {

											asnChoiceInt.UserAssigned.VolterraSiteAsn = uint32(v.(int))

										}

									}
								}

							}

						}
					}

				}

				workerNodesTypeFound := false

				if v, ok := awsParametersMapStrToI["no_worker_nodes"]; ok && !isIntfNil(v) && !workerNodesTypeFound {

					workerNodesTypeFound = true

					if v.(bool) {
						workerNodesInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_NoWorkerNodes{}
						workerNodesInt.NoWorkerNodes = &ves_io_schema.Empty{}
						awsParameters.WorkerNodes = workerNodesInt
					}

				}

				if v, ok := awsParametersMapStrToI["nodes_per_az"]; ok && !isIntfNil(v) && !workerNodesTypeFound {

					workerNodesTypeFound = true
					workerNodesInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_NodesPerAz{}

					awsParameters.WorkerNodes = workerNodesInt

					workerNodesInt.NodesPerAz = uint32(v.(int))

				}

				if v, ok := awsParametersMapStrToI["total_nodes"]; ok && !isIntfNil(v) && !workerNodesTypeFound {

					workerNodesTypeFound = true
					workerNodesInt := &ves_io_schema_views_aws_tgw_site.ServicesVPCReplaceType_TotalNodes{}

					awsParameters.WorkerNodes = workerNodesInt

					workerNodesInt.TotalNodes = uint32(v.(int))

				}

			}
		}

	}

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("block_all_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_aws_tgw_site.ReplaceSpecType_BlockAllServices{}
			blockedServicesChoiceInt.BlockAllServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("blocked_services"); ok && !isIntfNil(v) && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_aws_tgw_site.ReplaceSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		updateSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
					blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
					for i, set := range sl {
						if set != nil {
							blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
							blockedSeviceMapStrToI := set.(map[string]interface{})

							blockedServicesValueTypeChoiceTypeFound := false

							if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
									blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
									blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

								blockedServicesValueTypeChoiceTypeFound = true

								if v.(bool) {
									blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
									blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
									blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
								}

							}

							if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

								blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_aws_tgw_site.ReplaceSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		coordinates := &ves_io_schema_site.Coordinates{}
		updateSpec.Coordinates = coordinates
		for _, set := range sl {
			if set != nil {
				coordinatesMapStrToI := set.(map[string]interface{})

				if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
					coordinates.Latitude = float32(w.(float64))
				}

				if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
					coordinates.Longitude = float32(w.(float64))
				}

			}
		}

	}

	if v, ok := d.GetOk("custom_dns"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		customDns := &ves_io_schema_views.CustomDNS{}
		updateSpec.CustomDns = customDns
		for _, set := range sl {
			if set != nil {
				customDnsMapStrToI := set.(map[string]interface{})

				if w, ok := customDnsMapStrToI["inside_nameserver"]; ok && !isIntfNil(w) {
					customDns.InsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["inside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.InsideNameserverV6 = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserver = w.(string)
				}

				if w, ok := customDnsMapStrToI["outside_nameserver_v6"]; ok && !isIntfNil(w) {
					customDns.OutsideNameserverV6 = w.(string)
				}

			}
		}

	}

	directConnectChoiceTypeFound := false

	if v, ok := d.GetOk("direct_connect_disabled"); ok && !directConnectChoiceTypeFound {

		directConnectChoiceTypeFound = true

		if v.(bool) {
			directConnectChoiceInt := &ves_io_schema_views_aws_tgw_site.ReplaceSpecType_DirectConnectDisabled{}
			directConnectChoiceInt.DirectConnectDisabled = &ves_io_schema.Empty{}
			updateSpec.DirectConnectChoice = directConnectChoiceInt
		}

	}

	if v, ok := d.GetOk("direct_connect_enabled"); ok && !isIntfNil(v) && !directConnectChoiceTypeFound {

		directConnectChoiceTypeFound = true
		directConnectChoiceInt := &ves_io_schema_views_aws_tgw_site.ReplaceSpecType_DirectConnectEnabled{}
		directConnectChoiceInt.DirectConnectEnabled = &ves_io_schema_views.DirectConnectConfigType{}
		updateSpec.DirectConnectChoice = directConnectChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				asnChoiceTypeFound := false

				if v, ok := cs["auto_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

					asnChoiceTypeFound = true

					if v.(bool) {
						asnChoiceInt := &ves_io_schema_views.DirectConnectConfigType_AutoAsn{}
						asnChoiceInt.AutoAsn = &ves_io_schema.Empty{}
						directConnectChoiceInt.DirectConnectEnabled.AsnChoice = asnChoiceInt
					}

				}

				if v, ok := cs["custom_asn"]; ok && !isIntfNil(v) && !asnChoiceTypeFound {

					asnChoiceTypeFound = true
					asnChoiceInt := &ves_io_schema_views.DirectConnectConfigType_CustomAsn{}

					directConnectChoiceInt.DirectConnectEnabled.AsnChoice = asnChoiceInt

					asnChoiceInt.CustomAsn = uint32(v.(int))

				}

				vifChoiceTypeFound := false

				if v, ok := cs["hosted_vifs"]; ok && !isIntfNil(v) && !vifChoiceTypeFound {

					vifChoiceTypeFound = true
					vifChoiceInt := &ves_io_schema_views.DirectConnectConfigType_HostedVifs{}
					vifChoiceInt.HostedVifs = &ves_io_schema_views.HostedVIFConfigType{}
					directConnectChoiceInt.DirectConnectEnabled.VifChoice = vifChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							connectivityOptionsTypeFound := false

							if v, ok := cs["site_registration_over_direct_connect"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

								connectivityOptionsTypeFound = true
								connectivityOptionsInt := &ves_io_schema_views.HostedVIFConfigType_SiteRegistrationOverDirectConnect{}
								connectivityOptionsInt.SiteRegistrationOverDirectConnect = &ves_io_schema_views.CloudLinkADNType{}
								vifChoiceInt.HostedVifs.ConnectivityOptions = connectivityOptionsInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["cloudlink_network_name"]; ok && !isIntfNil(v) {

											connectivityOptionsInt.SiteRegistrationOverDirectConnect.CloudlinkNetworkName = v.(string)

										}

									}
								}

							}

							if v, ok := cs["site_registration_over_internet"]; ok && !isIntfNil(v) && !connectivityOptionsTypeFound {

								connectivityOptionsTypeFound = true

								if v.(bool) {
									connectivityOptionsInt := &ves_io_schema_views.HostedVIFConfigType_SiteRegistrationOverInternet{}
									connectivityOptionsInt.SiteRegistrationOverInternet = &ves_io_schema.Empty{}
									vifChoiceInt.HostedVifs.ConnectivityOptions = connectivityOptionsInt
								}

							}

							if v, ok := cs["vif_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								vifList := make([]*ves_io_schema_views.VifRegionConfig, len(sl))
								vifChoiceInt.HostedVifs.VifList = vifList
								for i, set := range sl {
									if set != nil {
										vifList[i] = &ves_io_schema_views.VifRegionConfig{}
										vifListMapStrToI := set.(map[string]interface{})

										if w, ok := vifListMapStrToI["vif_id"]; ok && !isIntfNil(w) {
											vifList[i].VifId = w.(string)
										}

										vifRegionChoiceTypeFound := false

										if v, ok := vifListMapStrToI["other_region"]; ok && !isIntfNil(v) && !vifRegionChoiceTypeFound {

											vifRegionChoiceTypeFound = true
											vifRegionChoiceInt := &ves_io_schema_views.VifRegionConfig_OtherRegion{}

											vifList[i].VifRegionChoice = vifRegionChoiceInt

											vifRegionChoiceInt.OtherRegion = v.(string)

										}

										if v, ok := vifListMapStrToI["same_as_site_region"]; ok && !isIntfNil(v) && !vifRegionChoiceTypeFound {

											vifRegionChoiceTypeFound = true

											if v.(bool) {
												vifRegionChoiceInt := &ves_io_schema_views.VifRegionConfig_SameAsSiteRegion{}
												vifRegionChoiceInt.SameAsSiteRegion = &ves_io_schema.Empty{}
												vifList[i].VifRegionChoice = vifRegionChoiceInt
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["standard_vifs"]; ok && !isIntfNil(v) && !vifChoiceTypeFound {

					vifChoiceTypeFound = true

					if v.(bool) {
						vifChoiceInt := &ves_io_schema_views.DirectConnectConfigType_StandardVifs{}
						vifChoiceInt.StandardVifs = &ves_io_schema.Empty{}
						directConnectChoiceInt.DirectConnectEnabled.VifChoice = vifChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("private_connectivity"); ok && !isIntfNil(v) && !directConnectChoiceTypeFound {

		directConnectChoiceTypeFound = true
		directConnectChoiceInt := &ves_io_schema_views_aws_tgw_site.ReplaceSpecType_PrivateConnectivity{}
		directConnectChoiceInt.PrivateConnectivity = &ves_io_schema_views.PrivateConnectConfigType{}
		updateSpec.DirectConnectChoice = directConnectChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["cloud_link"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					cloudLink := &ves_io_schema_views.ObjectRefType{}
					directConnectChoiceInt.PrivateConnectivity.CloudLink = cloudLink
					for _, set := range sl {
						if set != nil {
							cloudLinkMapStrToI := set.(map[string]interface{})

							if w, ok := cloudLinkMapStrToI["name"]; ok && !isIntfNil(w) {
								cloudLink.Name = w.(string)
							}

							if w, ok := cloudLinkMapStrToI["namespace"]; ok && !isIntfNil(w) {
								cloudLink.Namespace = w.(string)
							}

							if w, ok := cloudLinkMapStrToI["tenant"]; ok && !isIntfNil(w) {
								cloudLink.Tenant = w.(string)
							}

						}
					}

				}

				networkOptionsTypeFound := false

				if v, ok := cs["inside"]; ok && !isIntfNil(v) && !networkOptionsTypeFound {

					networkOptionsTypeFound = true

					if v.(bool) {
						networkOptionsInt := &ves_io_schema_views.PrivateConnectConfigType_Inside{}
						networkOptionsInt.Inside = &ves_io_schema.Empty{}
						directConnectChoiceInt.PrivateConnectivity.NetworkOptions = networkOptionsInt
					}

				}

				if v, ok := cs["outside"]; ok && !isIntfNil(v) && !networkOptionsTypeFound {

					networkOptionsTypeFound = true

					if v.(bool) {
						networkOptionsInt := &ves_io_schema_views.PrivateConnectConfigType_Outside{}
						networkOptionsInt.Outside = &ves_io_schema.Empty{}
						directConnectChoiceInt.PrivateConnectivity.NetworkOptions = networkOptionsInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("kubernetes_upgrade_drain"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		kubernetesUpgradeDrain := &ves_io_schema_views.KubernetesUpgradeDrain{}
		updateSpec.KubernetesUpgradeDrain = kubernetesUpgradeDrain
		for _, set := range sl {
			if set != nil {
				kubernetesUpgradeDrainMapStrToI := set.(map[string]interface{})

				kubernetesUpgradeDrainEnableChoiceTypeFound := false

				if v, ok := kubernetesUpgradeDrainMapStrToI["disable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true

					if v.(bool) {
						kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_DisableUpgradeDrain{}
						kubernetesUpgradeDrainEnableChoiceInt.DisableUpgradeDrain = &ves_io_schema.Empty{}
						kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt
					}

				}

				if v, ok := kubernetesUpgradeDrainMapStrToI["enable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

					kubernetesUpgradeDrainEnableChoiceTypeFound = true
					kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_EnableUpgradeDrain{}
					kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain = &ves_io_schema_views.KubernetesUpgradeDrainConfig{}
					kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							drainMaxUnavailableChoiceTypeFound := false

							if v, ok := cs["drain_max_unavailable_node_count"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodeCount = uint32(v.(int))

							}

							if v, ok := cs["drain_node_timeout"]; ok && !isIntfNil(v) {

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainNodeTimeout = uint32(v.(int))

							}

						}
					}

				}

			}
		}

	}

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !isIntfNil(v) && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_aws_tgw_site.ReplaceSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		updateSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["name"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Name = v.(string)

				}

				if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

				}

				if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

					logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_aws_tgw_site.ReplaceSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			updateSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		updateSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			if set != nil {
				offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

				offlineSurvivabilityModeChoiceTypeFound := false

				if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

				if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

					offlineSurvivabilityModeChoiceTypeFound = true

					if v.(bool) {
						offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
						offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
						offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("performance_enhancement_mode"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
		updateSpec.PerformanceEnhancementMode = performanceEnhancementMode
		for _, set := range sl {
			if set != nil {
				performanceEnhancementModeMapStrToI := set.(map[string]interface{})

				perfModeChoiceTypeFound := false

				if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

					perfModeChoiceTypeFound = true
					perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
					perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
					performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
									perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

							if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
									perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

						}
					}

				}

				if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

					perfModeChoiceTypeFound = true

					if v.(bool) {
						perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
						perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
						performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("tgw_security"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		tgwSecurity := &ves_io_schema_views_aws_tgw_site.SecurityConfigType{}
		updateSpec.TgwSecurity = tgwSecurity
		for _, set := range sl {
			if set != nil {
				tgwSecurityMapStrToI := set.(map[string]interface{})

				eastWestServicePolicyChoiceTypeFound := false

				if v, ok := tgwSecurityMapStrToI["active_east_west_service_policies"]; ok && !isIntfNil(v) && !eastWestServicePolicyChoiceTypeFound {

					eastWestServicePolicyChoiceTypeFound = true
					eastWestServicePolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ActiveEastWestServicePolicies{}
					eastWestServicePolicyChoiceInt.ActiveEastWestServicePolicies = &ves_io_schema_views_aws_tgw_site.ActiveServicePoliciesType{}
					tgwSecurity.EastWestServicePolicyChoice = eastWestServicePolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["service_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								servicePoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								eastWestServicePolicyChoiceInt.ActiveEastWestServicePolicies.ServicePolicies = servicePoliciesInt
								for i, ps := range sl {

									spMapToStrVal := ps.(map[string]interface{})
									servicePoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := spMapToStrVal["name"]; ok && !isIntfNil(v) {
										servicePoliciesInt[i].Name = v.(string)
									}

									if v, ok := spMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										servicePoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := spMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										servicePoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := tgwSecurityMapStrToI["east_west_service_policy_allow_all"]; ok && !isIntfNil(v) && !eastWestServicePolicyChoiceTypeFound {

					eastWestServicePolicyChoiceTypeFound = true

					if v.(bool) {
						eastWestServicePolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_EastWestServicePolicyAllowAll{}
						eastWestServicePolicyChoiceInt.EastWestServicePolicyAllowAll = &ves_io_schema.Empty{}
						tgwSecurity.EastWestServicePolicyChoice = eastWestServicePolicyChoiceInt
					}

				}

				if v, ok := tgwSecurityMapStrToI["no_east_west_policy"]; ok && !isIntfNil(v) && !eastWestServicePolicyChoiceTypeFound {

					eastWestServicePolicyChoiceTypeFound = true

					if v.(bool) {
						eastWestServicePolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_NoEastWestPolicy{}
						eastWestServicePolicyChoiceInt.NoEastWestPolicy = &ves_io_schema.Empty{}
						tgwSecurity.EastWestServicePolicyChoice = eastWestServicePolicyChoiceInt
					}

				}

				forwardProxyChoiceTypeFound := false

				if v, ok := tgwSecurityMapStrToI["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true
					forwardProxyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ActiveForwardProxyPolicies{}
					forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
					tgwSecurity.ForwardProxyChoice = forwardProxyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
								for i, ps := range sl {

									fppMapToStrVal := ps.(map[string]interface{})
									forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Name = v.(string)
									}

									if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										forwardProxyPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := tgwSecurityMapStrToI["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ForwardProxyAllowAll{}
						forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
						tgwSecurity.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				if v, ok := tgwSecurityMapStrToI["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

					forwardProxyChoiceTypeFound = true

					if v.(bool) {
						forwardProxyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_NoForwardProxy{}
						forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
						tgwSecurity.ForwardProxyChoice = forwardProxyChoiceInt
					}

				}

				networkPolicyChoiceTypeFound := false

				if v, ok := tgwSecurityMapStrToI["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ActiveEnhancedFirewallPolicies{}
					networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
					tgwSecurity.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
								for i, ps := range sl {

									efpMapToStrVal := ps.(map[string]interface{})
									enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Name = v.(string)
									}

									if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										enhancedFirewallPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := tgwSecurityMapStrToI["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true
					networkPolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_ActiveNetworkPolicies{}
					networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
					tgwSecurity.NetworkPolicyChoice = networkPolicyChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
								networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
								for i, ps := range sl {

									npMapToStrVal := ps.(map[string]interface{})
									networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

									if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Name = v.(string)
									}

									if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Namespace = v.(string)
									}

									if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										networkPoliciesInt[i].Tenant = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := tgwSecurityMapStrToI["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

					networkPolicyChoiceTypeFound = true

					if v.(bool) {
						networkPolicyChoiceInt := &ves_io_schema_views_aws_tgw_site.SecurityConfigType_NoNetworkPolicy{}
						networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
						tgwSecurity.NetworkPolicyChoice = networkPolicyChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("vn_config"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		vnConfig := &ves_io_schema_views_aws_tgw_site.VnConfiguration{}
		updateSpec.VnConfig = vnConfig
		for _, set := range sl {
			if set != nil {
				vnConfigMapStrToI := set.(map[string]interface{})

				if v, ok := vnConfigMapStrToI["allowed_vip_port"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					allowedVipPort := &ves_io_schema_views.AllowedVIPPorts{}
					vnConfig.AllowedVipPort = allowedVipPort
					for _, set := range sl {
						if set != nil {
							allowedVipPortMapStrToI := set.(map[string]interface{})

							portChoiceTypeFound := false

							if v, ok := allowedVipPortMapStrToI["custom_ports"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true
								portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_CustomPorts{}
								portChoiceInt.CustomPorts = &ves_io_schema_views.CustomPorts{}
								allowedVipPort.PortChoice = portChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["port_ranges"]; ok && !isIntfNil(v) {

											portChoiceInt.CustomPorts.PortRanges = v.(string)

										}

									}
								}

							}

							if v, ok := allowedVipPortMapStrToI["disable_allowed_vip_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_DisableAllowedVipPort{}
									portChoiceInt.DisableAllowedVipPort = &ves_io_schema.Empty{}
									allowedVipPort.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortMapStrToI["use_http_https_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpHttpsPort{}
									portChoiceInt.UseHttpHttpsPort = &ves_io_schema.Empty{}
									allowedVipPort.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortMapStrToI["use_http_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpPort{}
									portChoiceInt.UseHttpPort = &ves_io_schema.Empty{}
									allowedVipPort.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortMapStrToI["use_https_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpsPort{}
									portChoiceInt.UseHttpsPort = &ves_io_schema.Empty{}
									allowedVipPort.PortChoice = portChoiceInt
								}

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["allowed_vip_port_sli"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					allowedVipPortSli := &ves_io_schema_views.AllowedVIPPorts{}
					vnConfig.AllowedVipPortSli = allowedVipPortSli
					for _, set := range sl {
						if set != nil {
							allowedVipPortSliMapStrToI := set.(map[string]interface{})

							portChoiceTypeFound := false

							if v, ok := allowedVipPortSliMapStrToI["custom_ports"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true
								portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_CustomPorts{}
								portChoiceInt.CustomPorts = &ves_io_schema_views.CustomPorts{}
								allowedVipPortSli.PortChoice = portChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["port_ranges"]; ok && !isIntfNil(v) {

											portChoiceInt.CustomPorts.PortRanges = v.(string)

										}

									}
								}

							}

							if v, ok := allowedVipPortSliMapStrToI["disable_allowed_vip_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_DisableAllowedVipPort{}
									portChoiceInt.DisableAllowedVipPort = &ves_io_schema.Empty{}
									allowedVipPortSli.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortSliMapStrToI["use_http_https_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpHttpsPort{}
									portChoiceInt.UseHttpHttpsPort = &ves_io_schema.Empty{}
									allowedVipPortSli.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortSliMapStrToI["use_http_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpPort{}
									portChoiceInt.UseHttpPort = &ves_io_schema.Empty{}
									allowedVipPortSli.PortChoice = portChoiceInt
								}

							}

							if v, ok := allowedVipPortSliMapStrToI["use_https_port"]; ok && !isIntfNil(v) && !portChoiceTypeFound {

								portChoiceTypeFound = true

								if v.(bool) {
									portChoiceInt := &ves_io_schema_views.AllowedVIPPorts_UseHttpsPort{}
									portChoiceInt.UseHttpsPort = &ves_io_schema.Empty{}
									allowedVipPortSli.PortChoice = portChoiceInt
								}

							}

						}
					}

				}

				dcClusterGroupChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["dc_cluster_group_inside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_DcClusterGroupInsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupInsideVn = &ves_io_schema_views.ObjectRefType{}
					vnConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["dc_cluster_group_outside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true
					dcClusterGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_DcClusterGroupOutsideVn{}
					dcClusterGroupChoiceInt.DcClusterGroupOutsideVn = &ves_io_schema_views.ObjectRefType{}
					vnConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Tenant = v.(string)

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

					dcClusterGroupChoiceTypeFound = true

					if v.(bool) {
						dcClusterGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_NoDcClusterGroup{}
						dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
						vnConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
					}

				}

				globalNetworkChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true
					globalNetworkChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_GlobalNetworkList{}
					globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
					vnConfig.GlobalNetworkChoice = globalNetworkChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
								globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
								for i, set := range sl {
									if set != nil {
										globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
										globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

										connectionChoiceTypeFound := false

										if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
											connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

										if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

											connectionChoiceTypeFound = true
											connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
											connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
											globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														globalVn := &ves_io_schema_views.ObjectRefType{}
														connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
														for _, set := range sl {
															if set != nil {
																globalVnMapStrToI := set.(map[string]interface{})

																if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
																	globalVn.Name = w.(string)
																}

																if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
																	globalVn.Namespace = w.(string)
																}

																if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
																	globalVn.Tenant = w.(string)
																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

					globalNetworkChoiceTypeFound = true

					if v.(bool) {
						globalNetworkChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_NoGlobalNetwork{}
						globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
						vnConfig.GlobalNetworkChoice = globalNetworkChoiceInt
					}

				}

				insideStaticRouteChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true
					insideStaticRouteChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_InsideStaticRoutes{}
					insideStaticRouteChoiceInt.InsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					vnConfig.InsideStaticRouteChoice = insideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								insideStaticRouteChoiceInt.InsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := vnConfigMapStrToI["no_inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

					insideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						insideStaticRouteChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_NoInsideStaticRoutes{}
						insideStaticRouteChoiceInt.NoInsideStaticRoutes = &ves_io_schema.Empty{}
						vnConfig.InsideStaticRouteChoice = insideStaticRouteChoiceInt
					}

				}

				outsideStaticRouteChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true

					if v.(bool) {
						outsideStaticRouteChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_NoOutsideStaticRoutes{}
						outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
						vnConfig.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
					}

				}

				if v, ok := vnConfigMapStrToI["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

					outsideStaticRouteChoiceTypeFound = true
					outsideStaticRouteChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_OutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
					vnConfig.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
								outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
								for i, set := range sl {
									if set != nil {
										staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
										staticRouteListMapStrToI := set.(map[string]interface{})

										configModeChoiceTypeFound := false

										if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
											configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

														attrsList := []ves_io_schema.RouteAttrType{}
														for _, j := range v.([]interface{}) {
															if j == nil {
																return fmt.Errorf("please provide valid non-empty enum value of field attrs")
															}
															attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
														}
														configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

													}

													if v, ok := cs["labels"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														configModeChoiceInt.CustomStaticRoute.Labels = ms
													}

													if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														nexthop := &ves_io_schema.NextHopType{}
														configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
														for _, set := range sl {
															if set != nil {
																nexthopMapStrToI := set.(map[string]interface{})

																if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
																	nexthop.Interface = intfInt
																	for i, ps := range sl {

																		iMapToStrVal := ps.(map[string]interface{})
																		intfInt[i] = &ves_io_schema.ObjectRefType{}

																		intfInt[i].Kind = "network_interface"

																		if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
																			intfInt[i].Name = v.(string)
																		}

																		if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																			intfInt[i].Namespace = v.(string)
																		}

																		if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																			intfInt[i].Tenant = v.(string)
																		}

																		if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
																			intfInt[i].Uid = v.(string)
																		}

																	}

																}

																if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

																	sl := v.([]interface{})
																	nexthopAddress := &ves_io_schema.IpAddressType{}
																	nexthop.NexthopAddress = nexthopAddress
																	for _, set := range sl {
																		if set != nil {
																			nexthopAddressMapStrToI := set.(map[string]interface{})

																			verTypeFound := false

																			if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv4{}
																				verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv4.Addr = v.(string)

																						}

																					}
																				}

																			}

																			if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																				verTypeFound = true
																				verInt := &ves_io_schema.IpAddressType_Ipv6{}
																				verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
																				nexthopAddress.Ver = verInt

																				sl := v.([]interface{})
																				for _, set := range sl {
																					if set != nil {
																						cs := set.(map[string]interface{})

																						if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																							verInt.Ipv6.Addr = v.(string)

																						}

																					}
																				}

																			}

																		}
																	}

																}

																if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

																	nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

																}

															}
														}

													}

													if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
														configModeChoiceInt.CustomStaticRoute.Subnets = subnets
														for i, set := range sl {
															if set != nil {
																subnets[i] = &ves_io_schema.IpSubnetType{}
																subnetsMapStrToI := set.(map[string]interface{})

																verTypeFound := false

																if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv4{}
																	verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv4.Prefix = v.(string)

																			}

																		}
																	}

																}

																if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

																	verTypeFound = true
																	verInt := &ves_io_schema.IpSubnetType_Ipv6{}
																	verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
																	subnets[i].Ver = verInt

																	sl := v.([]interface{})
																	for _, set := range sl {
																		if set != nil {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["plen"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Plen = uint32(v.(int))

																			}

																			if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

																				verInt.Ipv6.Prefix = v.(string)

																			}

																		}
																	}

																}

															}
														}

													}

												}
											}

										}

										if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

											configModeChoiceTypeFound = true
											configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

											staticRouteList[i].ConfigModeChoice = configModeChoiceInt

											configModeChoiceInt.SimpleStaticRoute = v.(string)

										}

									}
								}

							}

						}
					}

				}

				siteMeshGroupChoiceTypeFound := false

				if v, ok := vnConfigMapStrToI["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_SmConnectionPublicIp{}
						siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
						vnConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

				if v, ok := vnConfigMapStrToI["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

					siteMeshGroupChoiceTypeFound = true

					if v.(bool) {
						siteMeshGroupChoiceInt := &ves_io_schema_views_aws_tgw_site.VnConfiguration_SmConnectionPvtIp{}
						siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
						vnConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("vpc_attachments"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		vpcAttachments := &ves_io_schema_views_aws_tgw_site.VPCAttachmentListType{}
		updateSpec.VpcAttachments = vpcAttachments
		for _, set := range sl {
			if set != nil {
				vpcAttachmentsMapStrToI := set.(map[string]interface{})

				if v, ok := vpcAttachmentsMapStrToI["vpc_list"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					vpcList := make([]*ves_io_schema_views_aws_tgw_site.VPCAttachmentType, len(sl))
					vpcAttachments.VpcList = vpcList
					for i, set := range sl {
						if set != nil {
							vpcList[i] = &ves_io_schema_views_aws_tgw_site.VPCAttachmentType{}
							vpcListMapStrToI := set.(map[string]interface{})

							if w, ok := vpcListMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								vpcList[i].Labels = ms
							}

							if w, ok := vpcListMapStrToI["vpc_id"]; ok && !isIntfNil(w) {
								vpcList[i].VpcId = w.(string)
							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Updating Volterra AwsTgwSite obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_aws_tgw_site.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating AwsTgwSite: %s", err)
	}

	return resourceVolterraAwsTgwSiteRead(d, meta)
}

func resourceVolterraAwsTgwSiteDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_aws_tgw_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] AwsTgwSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra AwsTgwSite before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra AwsTgwSite obj with name %+v in namespace %+v", name, namespace)
	opts := []vesapi.CallOpt{
		vesapi.WithFailIfReferred(),
	}
	return client.DeleteObject(context.Background(), ves_io_schema_views_aws_tgw_site.ObjectType, namespace, name, opts...)
}
