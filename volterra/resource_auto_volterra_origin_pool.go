//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_cluster "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/cluster"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_origin_pool "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/origin_pool"
)

// resourceVolterraOriginPool is implementation of Volterra's OriginPool resources
func resourceVolterraOriginPool() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraOriginPoolCreate,
		Read:   resourceVolterraOriginPoolRead,
		Update: resourceVolterraOriginPoolUpdate,
		Delete: resourceVolterraOriginPoolDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"advanced_options": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"circuit_breaker": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"connection_limit": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_requests": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"pending_requests": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"priority": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"retries": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"disable_circuit_breaker": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"connection_timeout": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"http2_options": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enabled": {
										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"http_idle_timeout": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"disable_outlier_detection": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outlier_detection": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"base_ejection_time": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"consecutive_5xx": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"consecutive_gateway_failure": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"interval": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_ejection_percent": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"no_panic_threshold": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"panic_threshold": {

							Type:     schema.TypeInt,
							Optional: true,
						},

						"disable_subsets": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"enable_subsets": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"endpoint_subsets": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"keys": {

													Type: schema.TypeList,

													Optional: true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},

									"any_endpoint": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"default_subset": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"default_subset": {
													Type:     schema.TypeMap,
													Optional: true,
												},
											},
										},
									},

									"fail_request": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"endpoint_selection": {
				Type:     schema.TypeString,
				Required: true,
			},

			"health_check_port": {

				Type:     schema.TypeInt,
				Optional: true,
			},

			"same_as_endpoint_port": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"healthcheck": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"loadbalancer_algorithm": {
				Type:     schema.TypeString,
				Required: true,
			},

			"origin_servers": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"consul_service": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"inside_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"outside_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"service_name": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"site_locator": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"site": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"virtual_site": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"custom_endpoint_object": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"endpoint": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"k8s_service": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"inside_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"outside_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"vk8s_networks": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"service_name": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"site_locator": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"site": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"virtual_site": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"private_ip": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"ip": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"inside_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"outside_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"site_locator": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"site": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"virtual_site": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"private_name": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns_name": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"inside_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"outside_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"site_locator": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"site": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"virtual_site": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"public_ip": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"ip": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"public_name": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns_name": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"vn_private_ip": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"ip": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"virtual_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"vn_private_name": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns_name": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"private_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"labels": {
							Type:     schema.TypeMap,
							Optional: true,
						},
					},
				},
			},

			"port": {
				Type:     schema.TypeInt,
				Required: true,
			},

			"no_tls": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"use_tls": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"no_mtls": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"use_mtls": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"tls_certificates": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"certificate_url": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"description": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"private_key": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"blindfold_secret_info": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"url": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"secret_encoding": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"version": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"skip_server_verification": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"use_server_verification": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"trusted_ca_url": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"volterra_trusted_ca": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"disable_sni": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sni": {

							Type:     schema.TypeString,
							Optional: true,
						},

						"use_host_header_as_sni": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"tls_config": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"custom_security": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"cipher_suites": {

													Type: schema.TypeList,

													Required: true,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},

												"max_version": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"min_version": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"default_security": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"low_security": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"medium_security": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// resourceVolterraOriginPoolCreate creates OriginPool resource
func resourceVolterraOriginPoolCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_origin_pool.CreateSpecType{}
	createReq := &ves_io_schema_views_origin_pool.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//advanced_options
	if v, ok := d.GetOk("advanced_options"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		advancedOptions := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions{}
		createSpec.AdvancedOptions = advancedOptions
		for _, set := range sl {
			advancedOptionsMapStrToI := set.(map[string]interface{})

			circuitBreakerChoiceTypeFound := false

			if v, ok := advancedOptionsMapStrToI["circuit_breaker"]; ok && !isIntfNil(v) && !circuitBreakerChoiceTypeFound {

				circuitBreakerChoiceTypeFound = true
				circuitBreakerChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_CircuitBreaker{}
				circuitBreakerChoiceInt.CircuitBreaker = &ves_io_schema_cluster.CircuitBreaker{}
				advancedOptions.CircuitBreakerChoice = circuitBreakerChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["connection_limit"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.ConnectionLimit = uint32(v.(int))

					}

					if v, ok := cs["max_requests"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.MaxRequests = uint32(v.(int))

					}

					if v, ok := cs["pending_requests"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.PendingRequests = uint32(v.(int))

					}

					if v, ok := cs["priority"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.Priority = ves_io_schema.RoutingPriority(ves_io_schema.RoutingPriority_value[v.(string)])

					}

					if v, ok := cs["retries"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.Retries = uint32(v.(int))

					}

				}

			}

			if v, ok := advancedOptionsMapStrToI["disable_circuit_breaker"]; ok && !isIntfNil(v) && !circuitBreakerChoiceTypeFound {

				circuitBreakerChoiceTypeFound = true

				if v.(bool) {
					circuitBreakerChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_DisableCircuitBreaker{}
					circuitBreakerChoiceInt.DisableCircuitBreaker = &ves_io_schema.Empty{}
					advancedOptions.CircuitBreakerChoice = circuitBreakerChoiceInt
				}

			}

			if w, ok := advancedOptionsMapStrToI["connection_timeout"]; ok && !isIntfNil(w) {
				advancedOptions.ConnectionTimeout = uint32(w.(int))
			}

			if v, ok := advancedOptionsMapStrToI["http2_options"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				http2Options := &ves_io_schema_cluster.Http2ProtocolOptions{}
				advancedOptions.Http2Options = http2Options
				for _, set := range sl {
					http2OptionsMapStrToI := set.(map[string]interface{})

					if w, ok := http2OptionsMapStrToI["enabled"]; ok && !isIntfNil(w) {
						http2Options.Enabled = w.(bool)
					}

				}

			}

			if w, ok := advancedOptionsMapStrToI["http_idle_timeout"]; ok && !isIntfNil(w) {
				advancedOptions.HttpIdleTimeout = uint32(w.(int))
			}

			outlierDetectionChoiceTypeFound := false

			if v, ok := advancedOptionsMapStrToI["disable_outlier_detection"]; ok && !isIntfNil(v) && !outlierDetectionChoiceTypeFound {

				outlierDetectionChoiceTypeFound = true

				if v.(bool) {
					outlierDetectionChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_DisableOutlierDetection{}
					outlierDetectionChoiceInt.DisableOutlierDetection = &ves_io_schema.Empty{}
					advancedOptions.OutlierDetectionChoice = outlierDetectionChoiceInt
				}

			}

			if v, ok := advancedOptionsMapStrToI["outlier_detection"]; ok && !isIntfNil(v) && !outlierDetectionChoiceTypeFound {

				outlierDetectionChoiceTypeFound = true
				outlierDetectionChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_OutlierDetection{}
				outlierDetectionChoiceInt.OutlierDetection = &ves_io_schema_cluster.OutlierDetectionType{}
				advancedOptions.OutlierDetectionChoice = outlierDetectionChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["base_ejection_time"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.BaseEjectionTime = uint32(v.(int))

					}

					if v, ok := cs["consecutive_5xx"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.Consecutive_5Xx = uint32(v.(int))

					}

					if v, ok := cs["consecutive_gateway_failure"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.ConsecutiveGatewayFailure = uint32(v.(int))

					}

					if v, ok := cs["interval"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.Interval = uint32(v.(int))

					}

					if v, ok := cs["max_ejection_percent"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.MaxEjectionPercent = uint32(v.(int))

					}

				}

			}

			panicThresholdTypeTypeFound := false

			if v, ok := advancedOptionsMapStrToI["no_panic_threshold"]; ok && !isIntfNil(v) && !panicThresholdTypeTypeFound {

				panicThresholdTypeTypeFound = true

				if v.(bool) {
					panicThresholdTypeInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_NoPanicThreshold{}
					panicThresholdTypeInt.NoPanicThreshold = &ves_io_schema.Empty{}
					advancedOptions.PanicThresholdType = panicThresholdTypeInt
				}

			}

			if v, ok := advancedOptionsMapStrToI["panic_threshold"]; ok && !isIntfNil(v) && !panicThresholdTypeTypeFound {

				panicThresholdTypeTypeFound = true
				panicThresholdTypeInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_PanicThreshold{}

				advancedOptions.PanicThresholdType = panicThresholdTypeInt

				panicThresholdTypeInt.PanicThreshold = uint32(v.(int))

			}

			subsetChoiceTypeFound := false

			if v, ok := advancedOptionsMapStrToI["disable_subsets"]; ok && !isIntfNil(v) && !subsetChoiceTypeFound {

				subsetChoiceTypeFound = true

				if v.(bool) {
					subsetChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_DisableSubsets{}
					subsetChoiceInt.DisableSubsets = &ves_io_schema.Empty{}
					advancedOptions.SubsetChoice = subsetChoiceInt
				}

			}

			if v, ok := advancedOptionsMapStrToI["enable_subsets"]; ok && !isIntfNil(v) && !subsetChoiceTypeFound {

				subsetChoiceTypeFound = true
				subsetChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_EnableSubsets{}
				subsetChoiceInt.EnableSubsets = &ves_io_schema_views_origin_pool.OriginPoolSubsets{}
				advancedOptions.SubsetChoice = subsetChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["endpoint_subsets"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						endpointSubsets := make([]*ves_io_schema_cluster.EndpointSubsetSelectorType, len(sl))
						subsetChoiceInt.EnableSubsets.EndpointSubsets = endpointSubsets
						for i, set := range sl {
							endpointSubsets[i] = &ves_io_schema_cluster.EndpointSubsetSelectorType{}
							endpointSubsetsMapStrToI := set.(map[string]interface{})

							if w, ok := endpointSubsetsMapStrToI["keys"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								endpointSubsets[i].Keys = ls
							}

						}

					}

					fallbackPolicyChoiceTypeFound := false

					if v, ok := cs["any_endpoint"]; ok && !isIntfNil(v) && !fallbackPolicyChoiceTypeFound {

						fallbackPolicyChoiceTypeFound = true

						if v.(bool) {
							fallbackPolicyChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolSubsets_AnyEndpoint{}
							fallbackPolicyChoiceInt.AnyEndpoint = &ves_io_schema.Empty{}
							subsetChoiceInt.EnableSubsets.FallbackPolicyChoice = fallbackPolicyChoiceInt
						}

					}

					if v, ok := cs["default_subset"]; ok && !isIntfNil(v) && !fallbackPolicyChoiceTypeFound {

						fallbackPolicyChoiceTypeFound = true
						fallbackPolicyChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolSubsets_DefaultSubset{}
						fallbackPolicyChoiceInt.DefaultSubset = &ves_io_schema_views_origin_pool.OriginPoolDefaultSubset{}
						subsetChoiceInt.EnableSubsets.FallbackPolicyChoice = fallbackPolicyChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["default_subset"]; ok && !isIntfNil(v) {

								ms := map[string]string{}
								for k, v := range v.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								fallbackPolicyChoiceInt.DefaultSubset.DefaultSubset = ms
							}

						}

					}

					if v, ok := cs["fail_request"]; ok && !isIntfNil(v) && !fallbackPolicyChoiceTypeFound {

						fallbackPolicyChoiceTypeFound = true

						if v.(bool) {
							fallbackPolicyChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolSubsets_FailRequest{}
							fallbackPolicyChoiceInt.FailRequest = &ves_io_schema.Empty{}
							subsetChoiceInt.EnableSubsets.FallbackPolicyChoice = fallbackPolicyChoiceInt
						}

					}

				}

			}

		}

	}

	//endpoint_selection
	if v, ok := d.GetOk("endpoint_selection"); ok && !isIntfNil(v) {

		createSpec.EndpointSelection = ves_io_schema_cluster.EndpointSelectionPolicy(ves_io_schema_cluster.EndpointSelectionPolicy_value[v.(string)])

	}

	//health_check_port_choice

	healthCheckPortChoiceTypeFound := false

	if v, ok := d.GetOk("health_check_port"); ok && !healthCheckPortChoiceTypeFound {

		healthCheckPortChoiceTypeFound = true
		healthCheckPortChoiceInt := &ves_io_schema_views_origin_pool.CreateSpecType_HealthCheckPort{}

		createSpec.HealthCheckPortChoice = healthCheckPortChoiceInt

		healthCheckPortChoiceInt.HealthCheckPort = uint32(v.(int))

	}

	if v, ok := d.GetOk("same_as_endpoint_port"); ok && !healthCheckPortChoiceTypeFound {

		healthCheckPortChoiceTypeFound = true

		if v.(bool) {
			healthCheckPortChoiceInt := &ves_io_schema_views_origin_pool.CreateSpecType_SameAsEndpointPort{}
			healthCheckPortChoiceInt.SameAsEndpointPort = &ves_io_schema.Empty{}
			createSpec.HealthCheckPortChoice = healthCheckPortChoiceInt
		}

	}

	//healthcheck
	if v, ok := d.GetOk("healthcheck"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		healthcheckInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
		createSpec.Healthcheck = healthcheckInt
		for i, ps := range sl {

			hMapToStrVal := ps.(map[string]interface{})
			healthcheckInt[i] = &ves_io_schema_views.ObjectRefType{}

			if v, ok := hMapToStrVal["name"]; ok && !isIntfNil(v) {
				healthcheckInt[i].Name = v.(string)
			}

			if v, ok := hMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				healthcheckInt[i].Namespace = v.(string)
			}

			if v, ok := hMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				healthcheckInt[i].Tenant = v.(string)
			}

		}

	}

	//loadbalancer_algorithm
	if v, ok := d.GetOk("loadbalancer_algorithm"); ok && !isIntfNil(v) {

		createSpec.LoadbalancerAlgorithm = ves_io_schema_cluster.LoadbalancerAlgorithm(ves_io_schema_cluster.LoadbalancerAlgorithm_value[v.(string)])

	}

	//origin_servers
	if v, ok := d.GetOk("origin_servers"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		originServers := make([]*ves_io_schema_views_origin_pool.OriginServerType, len(sl))
		createSpec.OriginServers = originServers
		for i, set := range sl {
			originServers[i] = &ves_io_schema_views_origin_pool.OriginServerType{}
			originServersMapStrToI := set.(map[string]interface{})

			choiceTypeFound := false

			if v, ok := originServersMapStrToI["consul_service"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_ConsulService{}
				choiceInt.ConsulService = &ves_io_schema_views_origin_pool.OriginServerConsulService{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					networkChoiceTypeFound := false

					if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerConsulService_InsideNetwork{}
							networkChoiceInt.InsideNetwork = &ves_io_schema.Empty{}
							choiceInt.ConsulService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["outside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerConsulService_OutsideNetwork{}
							networkChoiceInt.OutsideNetwork = &ves_io_schema.Empty{}
							choiceInt.ConsulService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["service_name"]; ok && !isIntfNil(v) {

						choiceInt.ConsulService.ServiceName = v.(string)

					}

					if v, ok := cs["site_locator"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						siteLocator := &ves_io_schema_views.SiteLocator{}
						choiceInt.ConsulService.SiteLocator = siteLocator
						for _, set := range sl {
							siteLocatorMapStrToI := set.(map[string]interface{})

							choiceTypeFound := false

							if v, ok := siteLocatorMapStrToI["site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_Site{}
								choiceInt.Site = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.Site.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.Site.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.Site.Tenant = v.(string)

									}

								}

							}

							if v, ok := siteLocatorMapStrToI["virtual_site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_VirtualSite{}
								choiceInt.VirtualSite = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Tenant = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := originServersMapStrToI["custom_endpoint_object"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_CustomEndpointObject{}
				choiceInt.CustomEndpointObject = &ves_io_schema_views_origin_pool.OriginServerCustomEndpoint{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["endpoint"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						endpointInt := &ves_io_schema_views.ObjectRefType{}
						choiceInt.CustomEndpointObject.Endpoint = endpointInt

						for _, set := range sl {
							eMapToStrVal := set.(map[string]interface{})
							if val, ok := eMapToStrVal["name"]; ok && !isIntfNil(v) {
								endpointInt.Name = val.(string)
							}
							if val, ok := eMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								endpointInt.Namespace = val.(string)
							}

							if val, ok := eMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								endpointInt.Tenant = val.(string)
							}
						}

					}

				}

			}

			if v, ok := originServersMapStrToI["k8s_service"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_K8SService{}
				choiceInt.K8SService = &ves_io_schema_views_origin_pool.OriginServerK8SService{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					networkChoiceTypeFound := false

					if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerK8SService_InsideNetwork{}
							networkChoiceInt.InsideNetwork = &ves_io_schema.Empty{}
							choiceInt.K8SService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["outside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerK8SService_OutsideNetwork{}
							networkChoiceInt.OutsideNetwork = &ves_io_schema.Empty{}
							choiceInt.K8SService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["vk8s_networks"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerK8SService_Vk8SNetworks{}
							networkChoiceInt.Vk8SNetworks = &ves_io_schema.Empty{}
							choiceInt.K8SService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["service_name"]; ok && !isIntfNil(v) {

						choiceInt.K8SService.ServiceName = v.(string)

					}

					if v, ok := cs["site_locator"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						siteLocator := &ves_io_schema_views.SiteLocator{}
						choiceInt.K8SService.SiteLocator = siteLocator
						for _, set := range sl {
							siteLocatorMapStrToI := set.(map[string]interface{})

							choiceTypeFound := false

							if v, ok := siteLocatorMapStrToI["site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_Site{}
								choiceInt.Site = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.Site.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.Site.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.Site.Tenant = v.(string)

									}

								}

							}

							if v, ok := siteLocatorMapStrToI["virtual_site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_VirtualSite{}
								choiceInt.VirtualSite = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Tenant = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := originServersMapStrToI["private_ip"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_PrivateIp{}
				choiceInt.PrivateIp = &ves_io_schema_views_origin_pool.OriginServerPrivateIP{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["ip"]; ok && !isIntfNil(v) {

						choiceInt.PrivateIp.Ip = v.(string)

					}

					networkChoiceTypeFound := false

					if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerPrivateIP_InsideNetwork{}
							networkChoiceInt.InsideNetwork = &ves_io_schema.Empty{}
							choiceInt.PrivateIp.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["outside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerPrivateIP_OutsideNetwork{}
							networkChoiceInt.OutsideNetwork = &ves_io_schema.Empty{}
							choiceInt.PrivateIp.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["site_locator"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						siteLocator := &ves_io_schema_views.SiteLocator{}
						choiceInt.PrivateIp.SiteLocator = siteLocator
						for _, set := range sl {
							siteLocatorMapStrToI := set.(map[string]interface{})

							choiceTypeFound := false

							if v, ok := siteLocatorMapStrToI["site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_Site{}
								choiceInt.Site = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.Site.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.Site.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.Site.Tenant = v.(string)

									}

								}

							}

							if v, ok := siteLocatorMapStrToI["virtual_site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_VirtualSite{}
								choiceInt.VirtualSite = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Tenant = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := originServersMapStrToI["private_name"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_PrivateName{}
				choiceInt.PrivateName = &ves_io_schema_views_origin_pool.OriginServerPrivateName{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["dns_name"]; ok && !isIntfNil(v) {

						choiceInt.PrivateName.DnsName = v.(string)

					}

					networkChoiceTypeFound := false

					if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerPrivateName_InsideNetwork{}
							networkChoiceInt.InsideNetwork = &ves_io_schema.Empty{}
							choiceInt.PrivateName.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["outside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerPrivateName_OutsideNetwork{}
							networkChoiceInt.OutsideNetwork = &ves_io_schema.Empty{}
							choiceInt.PrivateName.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["site_locator"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						siteLocator := &ves_io_schema_views.SiteLocator{}
						choiceInt.PrivateName.SiteLocator = siteLocator
						for _, set := range sl {
							siteLocatorMapStrToI := set.(map[string]interface{})

							choiceTypeFound := false

							if v, ok := siteLocatorMapStrToI["site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_Site{}
								choiceInt.Site = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.Site.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.Site.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.Site.Tenant = v.(string)

									}

								}

							}

							if v, ok := siteLocatorMapStrToI["virtual_site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_VirtualSite{}
								choiceInt.VirtualSite = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Tenant = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := originServersMapStrToI["public_ip"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_PublicIp{}
				choiceInt.PublicIp = &ves_io_schema_views_origin_pool.OriginServerPublicIP{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["ip"]; ok && !isIntfNil(v) {

						choiceInt.PublicIp.Ip = v.(string)

					}

				}

			}

			if v, ok := originServersMapStrToI["public_name"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_PublicName{}
				choiceInt.PublicName = &ves_io_schema_views_origin_pool.OriginServerPublicName{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["dns_name"]; ok && !isIntfNil(v) {

						choiceInt.PublicName.DnsName = v.(string)

					}

				}

			}

			if v, ok := originServersMapStrToI["vn_private_ip"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_VnPrivateIp{}
				choiceInt.VnPrivateIp = &ves_io_schema_views_origin_pool.OriginServerVirtualNetworkIP{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["ip"]; ok && !isIntfNil(v) {

						choiceInt.VnPrivateIp.Ip = v.(string)

					}

					if v, ok := cs["virtual_network"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						virtualNetworkInt := &ves_io_schema_views.ObjectRefType{}
						choiceInt.VnPrivateIp.VirtualNetwork = virtualNetworkInt

						for _, set := range sl {
							vnMapToStrVal := set.(map[string]interface{})
							if val, ok := vnMapToStrVal["name"]; ok && !isIntfNil(v) {
								virtualNetworkInt.Name = val.(string)
							}
							if val, ok := vnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								virtualNetworkInt.Namespace = val.(string)
							}

							if val, ok := vnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								virtualNetworkInt.Tenant = val.(string)
							}
						}

					}

				}

			}

			if v, ok := originServersMapStrToI["vn_private_name"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_VnPrivateName{}
				choiceInt.VnPrivateName = &ves_io_schema_views_origin_pool.OriginServerVirtualNetworkName{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["dns_name"]; ok && !isIntfNil(v) {

						choiceInt.VnPrivateName.DnsName = v.(string)

					}

					if v, ok := cs["private_network"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						privateNetworkInt := &ves_io_schema_views.ObjectRefType{}
						choiceInt.VnPrivateName.PrivateNetwork = privateNetworkInt

						for _, set := range sl {
							pnMapToStrVal := set.(map[string]interface{})
							if val, ok := pnMapToStrVal["name"]; ok && !isIntfNil(v) {
								privateNetworkInt.Name = val.(string)
							}
							if val, ok := pnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								privateNetworkInt.Namespace = val.(string)
							}

							if val, ok := pnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								privateNetworkInt.Tenant = val.(string)
							}
						}

					}

				}

			}

			if w, ok := originServersMapStrToI["labels"]; ok && !isIntfNil(w) {
				ms := map[string]string{}
				for k, v := range w.(map[string]interface{}) {
					ms[k] = v.(string)
				}
				originServers[i].Labels = ms
			}

		}

	}

	//port
	if v, ok := d.GetOk("port"); ok && !isIntfNil(v) {

		createSpec.Port =
			uint32(v.(int))

	}

	//tls_choice

	tlsChoiceTypeFound := false

	if v, ok := d.GetOk("no_tls"); ok && !tlsChoiceTypeFound {

		tlsChoiceTypeFound = true

		if v.(bool) {
			tlsChoiceInt := &ves_io_schema_views_origin_pool.CreateSpecType_NoTls{}
			tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
			createSpec.TlsChoice = tlsChoiceInt
		}

	}

	if v, ok := d.GetOk("use_tls"); ok && !tlsChoiceTypeFound {

		tlsChoiceTypeFound = true
		tlsChoiceInt := &ves_io_schema_views_origin_pool.CreateSpecType_UseTls{}
		tlsChoiceInt.UseTls = &ves_io_schema_views_origin_pool.UpstreamTlsParameters{}
		createSpec.TlsChoice = tlsChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			mtlsChoiceTypeFound := false

			if v, ok := cs["no_mtls"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

				mtlsChoiceTypeFound = true

				if v.(bool) {
					mtlsChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_NoMtls{}
					mtlsChoiceInt.NoMtls = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
				}

			}

			if v, ok := cs["use_mtls"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

				mtlsChoiceTypeFound = true
				mtlsChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_UseMtls{}
				mtlsChoiceInt.UseMtls = &ves_io_schema_views_origin_pool.TlsCertificatesType{}
				tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["tls_certificates"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						tlsCertificates := make([]*ves_io_schema.TlsCertificateType, len(sl))
						mtlsChoiceInt.UseMtls.TlsCertificates = tlsCertificates
						for i, set := range sl {
							tlsCertificates[i] = &ves_io_schema.TlsCertificateType{}
							tlsCertificatesMapStrToI := set.(map[string]interface{})

							if w, ok := tlsCertificatesMapStrToI["certificate_url"]; ok && !isIntfNil(w) {
								tlsCertificates[i].CertificateUrl = w.(string)
							}

							if w, ok := tlsCertificatesMapStrToI["description"]; ok && !isIntfNil(w) {
								tlsCertificates[i].Description = w.(string)
							}

							if v, ok := tlsCertificatesMapStrToI["private_key"]; ok && !isIntfNil(v) {

								sl := v.(*schema.Set).List()
								privateKey := &ves_io_schema.SecretType{}
								tlsCertificates[i].PrivateKey = privateKey
								for _, set := range sl {
									privateKeyMapStrToI := set.(map[string]interface{})

									if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
										privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
										for _, set := range sl {
											blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

											if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
												blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
											}

											if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
												blindfoldSecretInfoInternal.Location = w.(string)
											}

											if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
												blindfoldSecretInfoInternal.StoreProvider = w.(string)
											}

										}

									}

									if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

										privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

									}

									secretInfoOneofTypeFound := false

									if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

										secretInfoOneofTypeFound = true
										secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
										secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
										privateKey.SecretInfoOneof = secretInfoOneofInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

											}

											if v, ok := cs["location"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

											}

											if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

											}

										}

									}

									if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

										secretInfoOneofTypeFound = true
										secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
										secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
										privateKey.SecretInfoOneof = secretInfoOneofInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["provider"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

											}

											if v, ok := cs["url"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

											}

										}

									}

									if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

										secretInfoOneofTypeFound = true
										secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
										secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
										privateKey.SecretInfoOneof = secretInfoOneofInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["key"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

											}

											if v, ok := cs["location"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

											}

											if v, ok := cs["provider"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

											}

											if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

											}

											if v, ok := cs["version"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

											}

										}

									}

									if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

										secretInfoOneofTypeFound = true
										secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
										secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
										privateKey.SecretInfoOneof = secretInfoOneofInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

											}

										}

									}

								}

							}

						}

					}

				}

			}

			serverValidationChoiceTypeFound := false

			if v, ok := cs["skip_server_verification"]; ok && !isIntfNil(v) && !serverValidationChoiceTypeFound {

				serverValidationChoiceTypeFound = true

				if v.(bool) {
					serverValidationChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_SkipServerVerification{}
					serverValidationChoiceInt.SkipServerVerification = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.ServerValidationChoice = serverValidationChoiceInt
				}

			}

			if v, ok := cs["use_server_verification"]; ok && !isIntfNil(v) && !serverValidationChoiceTypeFound {

				serverValidationChoiceTypeFound = true
				serverValidationChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_UseServerVerification{}
				serverValidationChoiceInt.UseServerVerification = &ves_io_schema_views_origin_pool.UpstreamTlsValidationContext{}
				tlsChoiceInt.UseTls.ServerValidationChoice = serverValidationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) {

						serverValidationChoiceInt.UseServerVerification.TrustedCaUrl = v.(string)

					}

				}

			}

			if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !serverValidationChoiceTypeFound {

				serverValidationChoiceTypeFound = true

				if v.(bool) {
					serverValidationChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_VolterraTrustedCa{}
					serverValidationChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.ServerValidationChoice = serverValidationChoiceInt
				}

			}

			sniChoiceTypeFound := false

			if v, ok := cs["disable_sni"]; ok && !isIntfNil(v) && !sniChoiceTypeFound {

				sniChoiceTypeFound = true

				if v.(bool) {
					sniChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_DisableSni{}
					sniChoiceInt.DisableSni = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.SniChoice = sniChoiceInt
				}

			}

			if v, ok := cs["sni"]; ok && !isIntfNil(v) && !sniChoiceTypeFound {

				sniChoiceTypeFound = true
				sniChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_Sni{}

				tlsChoiceInt.UseTls.SniChoice = sniChoiceInt

				sniChoiceInt.Sni = v.(string)

			}

			if v, ok := cs["use_host_header_as_sni"]; ok && !isIntfNil(v) && !sniChoiceTypeFound {

				sniChoiceTypeFound = true

				if v.(bool) {
					sniChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_UseHostHeaderAsSni{}
					sniChoiceInt.UseHostHeaderAsSni = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.SniChoice = sniChoiceInt
				}

			}

			if v, ok := cs["tls_config"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				tlsConfig := &ves_io_schema_views.TlsConfig{}
				tlsChoiceInt.UseTls.TlsConfig = tlsConfig
				for _, set := range sl {
					tlsConfigMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := tlsConfigMapStrToI["custom_security"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.TlsConfig_CustomSecurity{}
						choiceInt.CustomSecurity = &ves_io_schema_views.CustomCiphers{}
						tlsConfig.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["cipher_suites"]; ok && !isIntfNil(v) {

								ls := make([]string, len(v.([]interface{})))
								for i, v := range v.([]interface{}) {
									ls[i] = v.(string)
								}
								choiceInt.CustomSecurity.CipherSuites = ls

							}

							if v, ok := cs["max_version"]; ok && !isIntfNil(v) {

								choiceInt.CustomSecurity.MaxVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

							}

							if v, ok := cs["min_version"]; ok && !isIntfNil(v) {

								choiceInt.CustomSecurity.MinVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

							}

						}

					}

					if v, ok := tlsConfigMapStrToI["default_security"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true

						if v.(bool) {
							choiceInt := &ves_io_schema_views.TlsConfig_DefaultSecurity{}
							choiceInt.DefaultSecurity = &ves_io_schema.Empty{}
							tlsConfig.Choice = choiceInt
						}

					}

					if v, ok := tlsConfigMapStrToI["low_security"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true

						if v.(bool) {
							choiceInt := &ves_io_schema_views.TlsConfig_LowSecurity{}
							choiceInt.LowSecurity = &ves_io_schema.Empty{}
							tlsConfig.Choice = choiceInt
						}

					}

					if v, ok := tlsConfigMapStrToI["medium_security"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true

						if v.(bool) {
							choiceInt := &ves_io_schema_views.TlsConfig_MediumSecurity{}
							choiceInt.MediumSecurity = &ves_io_schema.Empty{}
							tlsConfig.Choice = choiceInt
						}

					}

				}

			}

		}

	}

	log.Printf("[DEBUG] Creating Volterra OriginPool object with struct: %+v", createReq)

	createOriginPoolResp, err := client.CreateObject(context.Background(), ves_io_schema_views_origin_pool.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating OriginPool: %s", err)
	}
	d.SetId(createOriginPoolResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraOriginPoolRead(d, meta)
}

func resourceVolterraOriginPoolRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_origin_pool.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] OriginPool %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra OriginPool %q: %s", d.Id(), err)
	}
	return setOriginPoolFields(client, d, resp)
}

func setOriginPoolFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraOriginPoolUpdate updates OriginPool resource
func resourceVolterraOriginPoolUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_origin_pool.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_origin_pool.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}
	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("advanced_options"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		advancedOptions := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions{}
		updateSpec.AdvancedOptions = advancedOptions
		for _, set := range sl {
			advancedOptionsMapStrToI := set.(map[string]interface{})

			circuitBreakerChoiceTypeFound := false

			if v, ok := advancedOptionsMapStrToI["circuit_breaker"]; ok && !isIntfNil(v) && !circuitBreakerChoiceTypeFound {

				circuitBreakerChoiceTypeFound = true
				circuitBreakerChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_CircuitBreaker{}
				circuitBreakerChoiceInt.CircuitBreaker = &ves_io_schema_cluster.CircuitBreaker{}
				advancedOptions.CircuitBreakerChoice = circuitBreakerChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["connection_limit"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.ConnectionLimit = uint32(v.(int))

					}

					if v, ok := cs["max_requests"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.MaxRequests = uint32(v.(int))

					}

					if v, ok := cs["pending_requests"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.PendingRequests = uint32(v.(int))

					}

					if v, ok := cs["priority"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.Priority = ves_io_schema.RoutingPriority(ves_io_schema.RoutingPriority_value[v.(string)])

					}

					if v, ok := cs["retries"]; ok && !isIntfNil(v) {

						circuitBreakerChoiceInt.CircuitBreaker.Retries = uint32(v.(int))

					}

				}

			}

			if v, ok := advancedOptionsMapStrToI["disable_circuit_breaker"]; ok && !isIntfNil(v) && !circuitBreakerChoiceTypeFound {

				circuitBreakerChoiceTypeFound = true

				if v.(bool) {
					circuitBreakerChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_DisableCircuitBreaker{}
					circuitBreakerChoiceInt.DisableCircuitBreaker = &ves_io_schema.Empty{}
					advancedOptions.CircuitBreakerChoice = circuitBreakerChoiceInt
				}

			}

			if w, ok := advancedOptionsMapStrToI["connection_timeout"]; ok && !isIntfNil(w) {
				advancedOptions.ConnectionTimeout = uint32(w.(int))
			}

			if v, ok := advancedOptionsMapStrToI["http2_options"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				http2Options := &ves_io_schema_cluster.Http2ProtocolOptions{}
				advancedOptions.Http2Options = http2Options
				for _, set := range sl {
					http2OptionsMapStrToI := set.(map[string]interface{})

					if w, ok := http2OptionsMapStrToI["enabled"]; ok && !isIntfNil(w) {
						http2Options.Enabled = w.(bool)
					}

				}

			}

			if w, ok := advancedOptionsMapStrToI["http_idle_timeout"]; ok && !isIntfNil(w) {
				advancedOptions.HttpIdleTimeout = uint32(w.(int))
			}

			outlierDetectionChoiceTypeFound := false

			if v, ok := advancedOptionsMapStrToI["disable_outlier_detection"]; ok && !isIntfNil(v) && !outlierDetectionChoiceTypeFound {

				outlierDetectionChoiceTypeFound = true

				if v.(bool) {
					outlierDetectionChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_DisableOutlierDetection{}
					outlierDetectionChoiceInt.DisableOutlierDetection = &ves_io_schema.Empty{}
					advancedOptions.OutlierDetectionChoice = outlierDetectionChoiceInt
				}

			}

			if v, ok := advancedOptionsMapStrToI["outlier_detection"]; ok && !isIntfNil(v) && !outlierDetectionChoiceTypeFound {

				outlierDetectionChoiceTypeFound = true
				outlierDetectionChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_OutlierDetection{}
				outlierDetectionChoiceInt.OutlierDetection = &ves_io_schema_cluster.OutlierDetectionType{}
				advancedOptions.OutlierDetectionChoice = outlierDetectionChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["base_ejection_time"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.BaseEjectionTime = uint32(v.(int))

					}

					if v, ok := cs["consecutive_5xx"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.Consecutive_5Xx = uint32(v.(int))

					}

					if v, ok := cs["consecutive_gateway_failure"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.ConsecutiveGatewayFailure = uint32(v.(int))

					}

					if v, ok := cs["interval"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.Interval = uint32(v.(int))

					}

					if v, ok := cs["max_ejection_percent"]; ok && !isIntfNil(v) {

						outlierDetectionChoiceInt.OutlierDetection.MaxEjectionPercent = uint32(v.(int))

					}

				}

			}

			panicThresholdTypeTypeFound := false

			if v, ok := advancedOptionsMapStrToI["no_panic_threshold"]; ok && !isIntfNil(v) && !panicThresholdTypeTypeFound {

				panicThresholdTypeTypeFound = true

				if v.(bool) {
					panicThresholdTypeInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_NoPanicThreshold{}
					panicThresholdTypeInt.NoPanicThreshold = &ves_io_schema.Empty{}
					advancedOptions.PanicThresholdType = panicThresholdTypeInt
				}

			}

			if v, ok := advancedOptionsMapStrToI["panic_threshold"]; ok && !isIntfNil(v) && !panicThresholdTypeTypeFound {

				panicThresholdTypeTypeFound = true
				panicThresholdTypeInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_PanicThreshold{}

				advancedOptions.PanicThresholdType = panicThresholdTypeInt

				panicThresholdTypeInt.PanicThreshold = uint32(v.(int))

			}

			subsetChoiceTypeFound := false

			if v, ok := advancedOptionsMapStrToI["disable_subsets"]; ok && !isIntfNil(v) && !subsetChoiceTypeFound {

				subsetChoiceTypeFound = true

				if v.(bool) {
					subsetChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_DisableSubsets{}
					subsetChoiceInt.DisableSubsets = &ves_io_schema.Empty{}
					advancedOptions.SubsetChoice = subsetChoiceInt
				}

			}

			if v, ok := advancedOptionsMapStrToI["enable_subsets"]; ok && !isIntfNil(v) && !subsetChoiceTypeFound {

				subsetChoiceTypeFound = true
				subsetChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolAdvancedOptions_EnableSubsets{}
				subsetChoiceInt.EnableSubsets = &ves_io_schema_views_origin_pool.OriginPoolSubsets{}
				advancedOptions.SubsetChoice = subsetChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["endpoint_subsets"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						endpointSubsets := make([]*ves_io_schema_cluster.EndpointSubsetSelectorType, len(sl))
						subsetChoiceInt.EnableSubsets.EndpointSubsets = endpointSubsets
						for i, set := range sl {
							endpointSubsets[i] = &ves_io_schema_cluster.EndpointSubsetSelectorType{}
							endpointSubsetsMapStrToI := set.(map[string]interface{})

							if w, ok := endpointSubsetsMapStrToI["keys"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								endpointSubsets[i].Keys = ls
							}

						}

					}

					fallbackPolicyChoiceTypeFound := false

					if v, ok := cs["any_endpoint"]; ok && !isIntfNil(v) && !fallbackPolicyChoiceTypeFound {

						fallbackPolicyChoiceTypeFound = true

						if v.(bool) {
							fallbackPolicyChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolSubsets_AnyEndpoint{}
							fallbackPolicyChoiceInt.AnyEndpoint = &ves_io_schema.Empty{}
							subsetChoiceInt.EnableSubsets.FallbackPolicyChoice = fallbackPolicyChoiceInt
						}

					}

					if v, ok := cs["default_subset"]; ok && !isIntfNil(v) && !fallbackPolicyChoiceTypeFound {

						fallbackPolicyChoiceTypeFound = true
						fallbackPolicyChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolSubsets_DefaultSubset{}
						fallbackPolicyChoiceInt.DefaultSubset = &ves_io_schema_views_origin_pool.OriginPoolDefaultSubset{}
						subsetChoiceInt.EnableSubsets.FallbackPolicyChoice = fallbackPolicyChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["default_subset"]; ok && !isIntfNil(v) {

								ms := map[string]string{}
								for k, v := range v.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								fallbackPolicyChoiceInt.DefaultSubset.DefaultSubset = ms
							}

						}

					}

					if v, ok := cs["fail_request"]; ok && !isIntfNil(v) && !fallbackPolicyChoiceTypeFound {

						fallbackPolicyChoiceTypeFound = true

						if v.(bool) {
							fallbackPolicyChoiceInt := &ves_io_schema_views_origin_pool.OriginPoolSubsets_FailRequest{}
							fallbackPolicyChoiceInt.FailRequest = &ves_io_schema.Empty{}
							subsetChoiceInt.EnableSubsets.FallbackPolicyChoice = fallbackPolicyChoiceInt
						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("endpoint_selection"); ok && !isIntfNil(v) {

		updateSpec.EndpointSelection = ves_io_schema_cluster.EndpointSelectionPolicy(ves_io_schema_cluster.EndpointSelectionPolicy_value[v.(string)])

	}

	healthCheckPortChoiceTypeFound := false

	if v, ok := d.GetOk("health_check_port"); ok && !healthCheckPortChoiceTypeFound {

		healthCheckPortChoiceTypeFound = true
		healthCheckPortChoiceInt := &ves_io_schema_views_origin_pool.ReplaceSpecType_HealthCheckPort{}

		updateSpec.HealthCheckPortChoice = healthCheckPortChoiceInt

		healthCheckPortChoiceInt.HealthCheckPort = uint32(v.(int))

	}

	if v, ok := d.GetOk("same_as_endpoint_port"); ok && !healthCheckPortChoiceTypeFound {

		healthCheckPortChoiceTypeFound = true

		if v.(bool) {
			healthCheckPortChoiceInt := &ves_io_schema_views_origin_pool.ReplaceSpecType_SameAsEndpointPort{}
			healthCheckPortChoiceInt.SameAsEndpointPort = &ves_io_schema.Empty{}
			updateSpec.HealthCheckPortChoice = healthCheckPortChoiceInt
		}

	}

	if v, ok := d.GetOk("healthcheck"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		healthcheckInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
		updateSpec.Healthcheck = healthcheckInt
		for i, ps := range sl {

			hMapToStrVal := ps.(map[string]interface{})
			healthcheckInt[i] = &ves_io_schema_views.ObjectRefType{}

			if v, ok := hMapToStrVal["name"]; ok && !isIntfNil(v) {
				healthcheckInt[i].Name = v.(string)
			}

			if v, ok := hMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				healthcheckInt[i].Namespace = v.(string)
			}

			if v, ok := hMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				healthcheckInt[i].Tenant = v.(string)
			}

		}

	}

	if v, ok := d.GetOk("loadbalancer_algorithm"); ok && !isIntfNil(v) {

		updateSpec.LoadbalancerAlgorithm = ves_io_schema_cluster.LoadbalancerAlgorithm(ves_io_schema_cluster.LoadbalancerAlgorithm_value[v.(string)])

	}

	if v, ok := d.GetOk("origin_servers"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		originServers := make([]*ves_io_schema_views_origin_pool.OriginServerType, len(sl))
		updateSpec.OriginServers = originServers
		for i, set := range sl {
			originServers[i] = &ves_io_schema_views_origin_pool.OriginServerType{}
			originServersMapStrToI := set.(map[string]interface{})

			choiceTypeFound := false

			if v, ok := originServersMapStrToI["consul_service"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_ConsulService{}
				choiceInt.ConsulService = &ves_io_schema_views_origin_pool.OriginServerConsulService{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					networkChoiceTypeFound := false

					if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerConsulService_InsideNetwork{}
							networkChoiceInt.InsideNetwork = &ves_io_schema.Empty{}
							choiceInt.ConsulService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["outside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerConsulService_OutsideNetwork{}
							networkChoiceInt.OutsideNetwork = &ves_io_schema.Empty{}
							choiceInt.ConsulService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["service_name"]; ok && !isIntfNil(v) {

						choiceInt.ConsulService.ServiceName = v.(string)

					}

					if v, ok := cs["site_locator"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						siteLocator := &ves_io_schema_views.SiteLocator{}
						choiceInt.ConsulService.SiteLocator = siteLocator
						for _, set := range sl {
							siteLocatorMapStrToI := set.(map[string]interface{})

							choiceTypeFound := false

							if v, ok := siteLocatorMapStrToI["site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_Site{}
								choiceInt.Site = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.Site.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.Site.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.Site.Tenant = v.(string)

									}

								}

							}

							if v, ok := siteLocatorMapStrToI["virtual_site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_VirtualSite{}
								choiceInt.VirtualSite = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Tenant = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := originServersMapStrToI["custom_endpoint_object"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_CustomEndpointObject{}
				choiceInt.CustomEndpointObject = &ves_io_schema_views_origin_pool.OriginServerCustomEndpoint{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["endpoint"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						endpointInt := &ves_io_schema_views.ObjectRefType{}
						choiceInt.CustomEndpointObject.Endpoint = endpointInt

						for _, set := range sl {
							eMapToStrVal := set.(map[string]interface{})
							if val, ok := eMapToStrVal["name"]; ok && !isIntfNil(v) {
								endpointInt.Name = val.(string)
							}
							if val, ok := eMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								endpointInt.Namespace = val.(string)
							}

							if val, ok := eMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								endpointInt.Tenant = val.(string)
							}
						}

					}

				}

			}

			if v, ok := originServersMapStrToI["k8s_service"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_K8SService{}
				choiceInt.K8SService = &ves_io_schema_views_origin_pool.OriginServerK8SService{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					networkChoiceTypeFound := false

					if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerK8SService_InsideNetwork{}
							networkChoiceInt.InsideNetwork = &ves_io_schema.Empty{}
							choiceInt.K8SService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["outside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerK8SService_OutsideNetwork{}
							networkChoiceInt.OutsideNetwork = &ves_io_schema.Empty{}
							choiceInt.K8SService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["vk8s_networks"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerK8SService_Vk8SNetworks{}
							networkChoiceInt.Vk8SNetworks = &ves_io_schema.Empty{}
							choiceInt.K8SService.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["service_name"]; ok && !isIntfNil(v) {

						choiceInt.K8SService.ServiceName = v.(string)

					}

					if v, ok := cs["site_locator"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						siteLocator := &ves_io_schema_views.SiteLocator{}
						choiceInt.K8SService.SiteLocator = siteLocator
						for _, set := range sl {
							siteLocatorMapStrToI := set.(map[string]interface{})

							choiceTypeFound := false

							if v, ok := siteLocatorMapStrToI["site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_Site{}
								choiceInt.Site = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.Site.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.Site.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.Site.Tenant = v.(string)

									}

								}

							}

							if v, ok := siteLocatorMapStrToI["virtual_site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_VirtualSite{}
								choiceInt.VirtualSite = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Tenant = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := originServersMapStrToI["private_ip"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_PrivateIp{}
				choiceInt.PrivateIp = &ves_io_schema_views_origin_pool.OriginServerPrivateIP{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["ip"]; ok && !isIntfNil(v) {

						choiceInt.PrivateIp.Ip = v.(string)

					}

					networkChoiceTypeFound := false

					if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerPrivateIP_InsideNetwork{}
							networkChoiceInt.InsideNetwork = &ves_io_schema.Empty{}
							choiceInt.PrivateIp.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["outside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerPrivateIP_OutsideNetwork{}
							networkChoiceInt.OutsideNetwork = &ves_io_schema.Empty{}
							choiceInt.PrivateIp.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["site_locator"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						siteLocator := &ves_io_schema_views.SiteLocator{}
						choiceInt.PrivateIp.SiteLocator = siteLocator
						for _, set := range sl {
							siteLocatorMapStrToI := set.(map[string]interface{})

							choiceTypeFound := false

							if v, ok := siteLocatorMapStrToI["site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_Site{}
								choiceInt.Site = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.Site.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.Site.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.Site.Tenant = v.(string)

									}

								}

							}

							if v, ok := siteLocatorMapStrToI["virtual_site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_VirtualSite{}
								choiceInt.VirtualSite = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Tenant = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := originServersMapStrToI["private_name"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_PrivateName{}
				choiceInt.PrivateName = &ves_io_schema_views_origin_pool.OriginServerPrivateName{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["dns_name"]; ok && !isIntfNil(v) {

						choiceInt.PrivateName.DnsName = v.(string)

					}

					networkChoiceTypeFound := false

					if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerPrivateName_InsideNetwork{}
							networkChoiceInt.InsideNetwork = &ves_io_schema.Empty{}
							choiceInt.PrivateName.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["outside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

						networkChoiceTypeFound = true

						if v.(bool) {
							networkChoiceInt := &ves_io_schema_views_origin_pool.OriginServerPrivateName_OutsideNetwork{}
							networkChoiceInt.OutsideNetwork = &ves_io_schema.Empty{}
							choiceInt.PrivateName.NetworkChoice = networkChoiceInt
						}

					}

					if v, ok := cs["site_locator"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						siteLocator := &ves_io_schema_views.SiteLocator{}
						choiceInt.PrivateName.SiteLocator = siteLocator
						for _, set := range sl {
							siteLocatorMapStrToI := set.(map[string]interface{})

							choiceTypeFound := false

							if v, ok := siteLocatorMapStrToI["site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_Site{}
								choiceInt.Site = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.Site.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.Site.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.Site.Tenant = v.(string)

									}

								}

							}

							if v, ok := siteLocatorMapStrToI["virtual_site"]; ok && !isIntfNil(v) && !choiceTypeFound {

								choiceTypeFound = true
								choiceInt := &ves_io_schema_views.SiteLocator_VirtualSite{}
								choiceInt.VirtualSite = &ves_io_schema_views.ObjectRefType{}
								siteLocator.Choice = choiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Name = v.(string)

									}

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Namespace = v.(string)

									}

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										choiceInt.VirtualSite.Tenant = v.(string)

									}

								}

							}

						}

					}

				}

			}

			if v, ok := originServersMapStrToI["public_ip"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_PublicIp{}
				choiceInt.PublicIp = &ves_io_schema_views_origin_pool.OriginServerPublicIP{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["ip"]; ok && !isIntfNil(v) {

						choiceInt.PublicIp.Ip = v.(string)

					}

				}

			}

			if v, ok := originServersMapStrToI["public_name"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_PublicName{}
				choiceInt.PublicName = &ves_io_schema_views_origin_pool.OriginServerPublicName{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["dns_name"]; ok && !isIntfNil(v) {

						choiceInt.PublicName.DnsName = v.(string)

					}

				}

			}

			if v, ok := originServersMapStrToI["vn_private_ip"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_VnPrivateIp{}
				choiceInt.VnPrivateIp = &ves_io_schema_views_origin_pool.OriginServerVirtualNetworkIP{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["ip"]; ok && !isIntfNil(v) {

						choiceInt.VnPrivateIp.Ip = v.(string)

					}

					if v, ok := cs["virtual_network"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						virtualNetworkInt := &ves_io_schema_views.ObjectRefType{}
						choiceInt.VnPrivateIp.VirtualNetwork = virtualNetworkInt

						for _, set := range sl {
							vnMapToStrVal := set.(map[string]interface{})
							if val, ok := vnMapToStrVal["name"]; ok && !isIntfNil(v) {
								virtualNetworkInt.Name = val.(string)
							}
							if val, ok := vnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								virtualNetworkInt.Namespace = val.(string)
							}

							if val, ok := vnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								virtualNetworkInt.Tenant = val.(string)
							}
						}

					}

				}

			}

			if v, ok := originServersMapStrToI["vn_private_name"]; ok && !isIntfNil(v) && !choiceTypeFound {

				choiceTypeFound = true
				choiceInt := &ves_io_schema_views_origin_pool.OriginServerType_VnPrivateName{}
				choiceInt.VnPrivateName = &ves_io_schema_views_origin_pool.OriginServerVirtualNetworkName{}
				originServers[i].Choice = choiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["dns_name"]; ok && !isIntfNil(v) {

						choiceInt.VnPrivateName.DnsName = v.(string)

					}

					if v, ok := cs["private_network"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						privateNetworkInt := &ves_io_schema_views.ObjectRefType{}
						choiceInt.VnPrivateName.PrivateNetwork = privateNetworkInt

						for _, set := range sl {
							pnMapToStrVal := set.(map[string]interface{})
							if val, ok := pnMapToStrVal["name"]; ok && !isIntfNil(v) {
								privateNetworkInt.Name = val.(string)
							}
							if val, ok := pnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								privateNetworkInt.Namespace = val.(string)
							}

							if val, ok := pnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								privateNetworkInt.Tenant = val.(string)
							}
						}

					}

				}

			}

			if w, ok := originServersMapStrToI["labels"]; ok && !isIntfNil(w) {
				ms := map[string]string{}
				for k, v := range w.(map[string]interface{}) {
					ms[k] = v.(string)
				}
				originServers[i].Labels = ms
			}

		}

	}

	if v, ok := d.GetOk("port"); ok && !isIntfNil(v) {

		updateSpec.Port =
			uint32(v.(int))

	}

	tlsChoiceTypeFound := false

	if v, ok := d.GetOk("no_tls"); ok && !tlsChoiceTypeFound {

		tlsChoiceTypeFound = true

		if v.(bool) {
			tlsChoiceInt := &ves_io_schema_views_origin_pool.ReplaceSpecType_NoTls{}
			tlsChoiceInt.NoTls = &ves_io_schema.Empty{}
			updateSpec.TlsChoice = tlsChoiceInt
		}

	}

	if v, ok := d.GetOk("use_tls"); ok && !tlsChoiceTypeFound {

		tlsChoiceTypeFound = true
		tlsChoiceInt := &ves_io_schema_views_origin_pool.ReplaceSpecType_UseTls{}
		tlsChoiceInt.UseTls = &ves_io_schema_views_origin_pool.UpstreamTlsParameters{}
		updateSpec.TlsChoice = tlsChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			mtlsChoiceTypeFound := false

			if v, ok := cs["no_mtls"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

				mtlsChoiceTypeFound = true

				if v.(bool) {
					mtlsChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_NoMtls{}
					mtlsChoiceInt.NoMtls = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt
				}

			}

			if v, ok := cs["use_mtls"]; ok && !isIntfNil(v) && !mtlsChoiceTypeFound {

				mtlsChoiceTypeFound = true
				mtlsChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_UseMtls{}
				mtlsChoiceInt.UseMtls = &ves_io_schema_views_origin_pool.TlsCertificatesType{}
				tlsChoiceInt.UseTls.MtlsChoice = mtlsChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["tls_certificates"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						tlsCertificates := make([]*ves_io_schema.TlsCertificateType, len(sl))
						mtlsChoiceInt.UseMtls.TlsCertificates = tlsCertificates
						for i, set := range sl {
							tlsCertificates[i] = &ves_io_schema.TlsCertificateType{}
							tlsCertificatesMapStrToI := set.(map[string]interface{})

							if w, ok := tlsCertificatesMapStrToI["certificate_url"]; ok && !isIntfNil(w) {
								tlsCertificates[i].CertificateUrl = w.(string)
							}

							if w, ok := tlsCertificatesMapStrToI["description"]; ok && !isIntfNil(w) {
								tlsCertificates[i].Description = w.(string)
							}

							if v, ok := tlsCertificatesMapStrToI["private_key"]; ok && !isIntfNil(v) {

								sl := v.(*schema.Set).List()
								privateKey := &ves_io_schema.SecretType{}
								tlsCertificates[i].PrivateKey = privateKey
								for _, set := range sl {
									privateKeyMapStrToI := set.(map[string]interface{})

									if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
										privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
										for _, set := range sl {
											blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

											if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
												blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
											}

											if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
												blindfoldSecretInfoInternal.Location = w.(string)
											}

											if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
												blindfoldSecretInfoInternal.StoreProvider = w.(string)
											}

										}

									}

									if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

										privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

									}

									secretInfoOneofTypeFound := false

									if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

										secretInfoOneofTypeFound = true
										secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
										secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
										privateKey.SecretInfoOneof = secretInfoOneofInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

											}

											if v, ok := cs["location"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

											}

											if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

											}

										}

									}

									if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

										secretInfoOneofTypeFound = true
										secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
										secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
										privateKey.SecretInfoOneof = secretInfoOneofInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["provider"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

											}

											if v, ok := cs["url"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

											}

										}

									}

									if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

										secretInfoOneofTypeFound = true
										secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
										secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
										privateKey.SecretInfoOneof = secretInfoOneofInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["key"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

											}

											if v, ok := cs["location"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

											}

											if v, ok := cs["provider"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

											}

											if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

											}

											if v, ok := cs["version"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

											}

										}

									}

									if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

										secretInfoOneofTypeFound = true
										secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
										secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
										privateKey.SecretInfoOneof = secretInfoOneofInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

											}

										}

									}

								}

							}

						}

					}

				}

			}

			serverValidationChoiceTypeFound := false

			if v, ok := cs["skip_server_verification"]; ok && !isIntfNil(v) && !serverValidationChoiceTypeFound {

				serverValidationChoiceTypeFound = true

				if v.(bool) {
					serverValidationChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_SkipServerVerification{}
					serverValidationChoiceInt.SkipServerVerification = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.ServerValidationChoice = serverValidationChoiceInt
				}

			}

			if v, ok := cs["use_server_verification"]; ok && !isIntfNil(v) && !serverValidationChoiceTypeFound {

				serverValidationChoiceTypeFound = true
				serverValidationChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_UseServerVerification{}
				serverValidationChoiceInt.UseServerVerification = &ves_io_schema_views_origin_pool.UpstreamTlsValidationContext{}
				tlsChoiceInt.UseTls.ServerValidationChoice = serverValidationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) {

						serverValidationChoiceInt.UseServerVerification.TrustedCaUrl = v.(string)

					}

				}

			}

			if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !serverValidationChoiceTypeFound {

				serverValidationChoiceTypeFound = true

				if v.(bool) {
					serverValidationChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_VolterraTrustedCa{}
					serverValidationChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.ServerValidationChoice = serverValidationChoiceInt
				}

			}

			sniChoiceTypeFound := false

			if v, ok := cs["disable_sni"]; ok && !isIntfNil(v) && !sniChoiceTypeFound {

				sniChoiceTypeFound = true

				if v.(bool) {
					sniChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_DisableSni{}
					sniChoiceInt.DisableSni = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.SniChoice = sniChoiceInt
				}

			}

			if v, ok := cs["sni"]; ok && !isIntfNil(v) && !sniChoiceTypeFound {

				sniChoiceTypeFound = true
				sniChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_Sni{}

				tlsChoiceInt.UseTls.SniChoice = sniChoiceInt

				sniChoiceInt.Sni = v.(string)

			}

			if v, ok := cs["use_host_header_as_sni"]; ok && !isIntfNil(v) && !sniChoiceTypeFound {

				sniChoiceTypeFound = true

				if v.(bool) {
					sniChoiceInt := &ves_io_schema_views_origin_pool.UpstreamTlsParameters_UseHostHeaderAsSni{}
					sniChoiceInt.UseHostHeaderAsSni = &ves_io_schema.Empty{}
					tlsChoiceInt.UseTls.SniChoice = sniChoiceInt
				}

			}

			if v, ok := cs["tls_config"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				tlsConfig := &ves_io_schema_views.TlsConfig{}
				tlsChoiceInt.UseTls.TlsConfig = tlsConfig
				for _, set := range sl {
					tlsConfigMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := tlsConfigMapStrToI["custom_security"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.TlsConfig_CustomSecurity{}
						choiceInt.CustomSecurity = &ves_io_schema_views.CustomCiphers{}
						tlsConfig.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["cipher_suites"]; ok && !isIntfNil(v) {

								ls := make([]string, len(v.([]interface{})))
								for i, v := range v.([]interface{}) {
									ls[i] = v.(string)
								}
								choiceInt.CustomSecurity.CipherSuites = ls

							}

							if v, ok := cs["max_version"]; ok && !isIntfNil(v) {

								choiceInt.CustomSecurity.MaxVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

							}

							if v, ok := cs["min_version"]; ok && !isIntfNil(v) {

								choiceInt.CustomSecurity.MinVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

							}

						}

					}

					if v, ok := tlsConfigMapStrToI["default_security"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true

						if v.(bool) {
							choiceInt := &ves_io_schema_views.TlsConfig_DefaultSecurity{}
							choiceInt.DefaultSecurity = &ves_io_schema.Empty{}
							tlsConfig.Choice = choiceInt
						}

					}

					if v, ok := tlsConfigMapStrToI["low_security"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true

						if v.(bool) {
							choiceInt := &ves_io_schema_views.TlsConfig_LowSecurity{}
							choiceInt.LowSecurity = &ves_io_schema.Empty{}
							tlsConfig.Choice = choiceInt
						}

					}

					if v, ok := tlsConfigMapStrToI["medium_security"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true

						if v.(bool) {
							choiceInt := &ves_io_schema_views.TlsConfig_MediumSecurity{}
							choiceInt.MediumSecurity = &ves_io_schema.Empty{}
							tlsConfig.Choice = choiceInt
						}

					}

				}

			}

		}

	}

	log.Printf("[DEBUG] Updating Volterra OriginPool obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_origin_pool.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating OriginPool: %s", err)
	}

	return resourceVolterraOriginPoolRead(d, meta)
}

func resourceVolterraOriginPoolDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_origin_pool.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] OriginPool %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra OriginPool before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra OriginPool obj with name %+v in namespace %+v", name, namespace)
	return client.DeleteObject(context.Background(), ves_io_schema_views_origin_pool.ObjectType, namespace, name)
}
