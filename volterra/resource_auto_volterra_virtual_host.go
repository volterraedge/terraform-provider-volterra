//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_authentication "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/authentication"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_virtual_host "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host"
)

// resourceVolterraVirtualHost is implementation of Volterra's VirtualHost resources
func resourceVolterraVirtualHost() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraVirtualHostCreate,
		Read:   resourceVolterraVirtualHostRead,
		Update: resourceVolterraVirtualHostUpdate,
		Delete: resourceVolterraVirtualHostDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"add_location": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"advertise_policies": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"kind": {
							Type:     schema.TypeString,
							Computed: true,
						},

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"api_spec": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"api_definition": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"disable_open_api_validation": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"enable_open_api_validation": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"allow_only_specified_headers": {
										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"allow_only_specified_query_params": {
										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"fail_close": {
										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"fail_oversized_body_validation": {
										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},
					},
				},
			},

			"authentication": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"auth_config": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:     schema.TypeString,
										Computed: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"cookie_params": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"cookie_expiry": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"cookie_refresh_interval": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"auth_hmac": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"prim_key": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"blindfold_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"url": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"provider": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"secret_encoding": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"version": {
																			Type:       schema.TypeInt,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},

												"prim_key_expiry": {
													Type:     schema.TypeString,
													Required: true,
												},

												"sec_key": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"blindfold_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"location": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"store_provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:     schema.TypeList,
																MaxItems: 1,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"url": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"provider": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"secret_encoding": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"version": {
																			Type:       schema.TypeInt,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},

												"sec_key_expiry": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"kms_key_hmac": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"auth_hmac_kms": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"namespace": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"tenant": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"session_expiry": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"use_auth_object_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"redirect_dynamic": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"redirect_url": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"no_authentication": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"buffer_policy": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"disabled": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"max_request_bytes": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"max_request_time": {
							Type:       schema.TypeInt,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"captcha_challenge": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"cookie_expiry": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"custom_page": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"js_challenge": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"cookie_expiry": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"custom_page": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"js_script_delay": {
							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},

			"no_challenge": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"coalescing_options": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_coalescing": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"strict_coalescing": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"compression_params": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"content_length": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"content_type": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"disable_on_etag_header": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"remove_accept_encoding_header": {
							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"connection_idle_timeout": {
				Type:     schema.TypeInt,
				Optional: true,
			},

			"cookies_to_modify": {

				Type:       schema.TypeList,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"disable_tampering_protection": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"enable_tampering_protection": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"add_httponly": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"ignore_httponly": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"ignore_max_age": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"max_age_value": {

							Type:       schema.TypeInt,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"name": {
							Type:       schema.TypeString,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"ignore_samesite": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"samesite_lax": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"samesite_none": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"samesite_strict": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"add_secure": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"ignore_secure": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"cors_policy": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"allow_credentials": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"allow_headers": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"allow_methods": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"allow_origin": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"allow_origin_regex": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"disabled": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"expose_headers": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"max_age": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"maximum_age": {
							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},

			"csrf_policy": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"all_load_balancer_domains": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"custom_domain_list": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"domains": {

										Type: schema.TypeList,

										Required: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},

						"disabled": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"custom_errors": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"default_loadbalancer": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"non_default_loadbalancer": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"disable_default_error_pages": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"disable_dns_resolve": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"dns_proxy_configuration": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"cache_profile": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"cache_size": {

										Type:       schema.TypeInt,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"disable_cache_profile": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"ddos_profile": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"disable_ddos_mitigation": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"enable_ddos_mitigation": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"irules": {

							Type:       schema.TypeList,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"protocol_inspection": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},
					},
				},
			},

			"domain_cert_map": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:       schema.TypeString,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
						"value": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"ecdsa_certificates": {

										Type:       schema.TypeList,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"kind": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"name": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"namespace": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"tenant": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"uid": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"rsa_certificates": {

										Type:       schema.TypeList,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"kind": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"name": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"namespace": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"tenant": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"uid": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"domains": {

				Type: schema.TypeList,

				Optional: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"dynamic_reverse_proxy": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"connection_timeout": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"resolution_network": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:     schema.TypeString,
										Computed: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"resolution_network_type": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"resolve_endpoint_dynamically": {
							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"header_transformation_type": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_header_transformation": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"legacy_header_transformation": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"preserve_case_header_transformation": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"proper_case_header_transformation": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"http_protocol_options": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"http_protocol_enable_v1_only": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"header_transformation": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"default_header_transformation": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"legacy_header_transformation": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"preserve_case_header_transformation": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"proper_case_header_transformation": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"http_protocol_enable_v1_v2": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"http_protocol_enable_v2_only": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"idle_timeout": {
				Type:     schema.TypeInt,
				Optional: true,
			},

			"masking_config": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"disable_masking": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"enable_masking": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"max_direct_response_body_size": {
				Type:       schema.TypeInt,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
			},

			"max_request_header_size": {
				Type:     schema.TypeInt,
				Optional: true,
			},

			"disable_path_normalize": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"enable_path_normalize": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"proxy": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"rate_limiter_allowed_prefixes": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"kind": {
							Type:     schema.TypeString,
							Computed: true,
						},

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"request_headers_to_add": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"append": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"name": {
							Type:     schema.TypeString,
							Required: true,
						},

						"secret_value": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"blindfold_secret_info_internal": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"store_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"secret_encoding_type": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"blindfold_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"location": {
													Type:     schema.TypeString,
													Required: true,
												},

												"store_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"clear_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"url": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"vault_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"key": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"provider": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"secret_encoding": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"version": {
													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"wingman_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"value": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"request_headers_to_remove": {

				Type: schema.TypeList,

				Optional: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"response_headers_to_add": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"append": {
							Type:     schema.TypeBool,
							Optional: true,
						},

						"name": {
							Type:     schema.TypeString,
							Required: true,
						},

						"secret_value": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"blindfold_secret_info_internal": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"store_provider": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"secret_encoding_type": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"blindfold_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"decryption_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"location": {
													Type:     schema.TypeString,
													Required: true,
												},

												"store_provider": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"clear_secret_info": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"provider": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"url": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"vault_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"key": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"location": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"provider": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"secret_encoding": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"version": {
													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"wingman_secret_info": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"value": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"response_headers_to_remove": {

				Type: schema.TypeList,

				Optional: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"retry_policy": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"back_off": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"base_interval": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"max_interval": {
										Type:     schema.TypeInt,
										Optional: true,
									},
								},
							},
						},

						"num_retries": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"per_try_timeout": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"retriable_status_codes": {

							Type: schema.TypeList,

							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeInt,
							},
						},

						"retry_condition": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"retry_on": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"routes": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"kind": {
							Type:     schema.TypeString,
							Computed: true,
						},

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"sensitive_data_policy": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"kind": {
							Type:     schema.TypeString,
							Computed: true,
						},

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"append_server_name": {

				Type:     schema.TypeString,
				Optional: true,
			},

			"default_header": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"pass_through": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"server_name": {

				Type:     schema.TypeString,
				Optional: true,
			},

			"slow_ddos_mitigation": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"request_headers_timeout": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"disable_request_timeout": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"request_timeout": {

							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},

			"additional_domains": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"domains": {

							Type: schema.TypeList,

							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"enable_strict_sni_host_header_check": {

				Type:       schema.TypeBool,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
			},

			"temporary_user_blocking": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"custom_page": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},
					},
				},
			},

			"tls_cert_params": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"certificates": {

							Type:       schema.TypeList,
							Required:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:       schema.TypeString,
										Computed:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"cipher_suites": {

							Type: schema.TypeList,

							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"client_certificate_optional": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},

						"client_certificate_required": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},

						"no_client_certificate": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},

						"crl": {

							Type:       schema.TypeList,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:       schema.TypeString,
										Computed:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"maximum_protocol_version": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"minimum_protocol_version": {
							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"require_client_certificate": {
							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"validation_params": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"skip_hostname_verification": {
										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"trusted_ca": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"trusted_ca_list": {

													Type:       schema.TypeList,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:       schema.TypeString,
																Computed:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"name": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"namespace": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"tenant": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"trusted_ca_url": {

										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"use_volterra_trusted_ca_url": {
										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"verify_subject_alt_names": {

										Type: schema.TypeList,

										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},

						"xfcc_header_elements": {

							Type: schema.TypeList,

							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"tls_parameters": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"client_certificate_optional": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},

						"client_certificate_required": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},

						"no_client_certificate": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},

						"common_params": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"cipher_suites": {

										Type: schema.TypeList,

										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"maximum_protocol_version": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"minimum_protocol_version": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"tls_certificates": {

										Type:       schema.TypeList,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"certificate_url": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"description": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"custom_hash_algorithms": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"hash_algorithms": {

																Type: schema.TypeList,

																Required:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},

												"disable_ocsp_stapling": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},

												"use_system_defaults": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{},
													},
												},

												"private_key": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"blindfold_secret_info_internal": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"secret_encoding_type": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"blindfold_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"decryption_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"store_provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"clear_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"provider": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"url": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"vault_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"key": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"location": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"provider": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"secret_encoding": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"version": {
																			Type:       schema.TypeInt,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"wingman_secret_info": {

																Type:       schema.TypeList,
																MaxItems:   1,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:       schema.TypeString,
																			Required:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},

									"trusted_ca_url": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"validation_params": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"skip_hostname_verification": {
													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"trusted_ca": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"trusted_ca_list": {

																Type:       schema.TypeList,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:       schema.TypeString,
																			Computed:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"name": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"namespace": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																		"tenant": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},
														},
													},
												},

												"trusted_ca_url": {

													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"use_volterra_trusted_ca_url": {
													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"verify_subject_alt_names": {

													Type: schema.TypeList,

													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
								},
							},
						},

						"crl": {

							Type:       schema.TypeList,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:       schema.TypeString,
										Computed:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"require_client_certificate": {
							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"xfcc_header_elements": {

							Type: schema.TypeList,

							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"user_identification": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"kind": {
							Type:     schema.TypeString,
							Computed: true,
						},

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"waf_type": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"app_firewall": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"app_firewall": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"kind": {
													Type:     schema.TypeString,
													Computed: true,
												},

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"disable_waf": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"inherit_waf": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"ztna_proxy_configurations": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"ztna_application_config": {

							Type:       schema.TypeList,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:       schema.TypeString,
										Computed:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"ztna_policy_config": {

							Type:       schema.TypeList,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:       schema.TypeString,
										Computed:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// resourceVolterraVirtualHostCreate creates VirtualHost resource
func resourceVolterraVirtualHostCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_virtual_host.CreateSpecType{}
	createReq := &ves_io_schema_virtual_host.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//add_location
	if v, ok := d.GetOk("add_location"); ok && !isIntfNil(v) {

		createSpec.AddLocation =
			v.(bool)

	}

	//advertise_policies
	if v, ok := d.GetOk("advertise_policies"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		advertisePoliciesInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		createSpec.AdvertisePolicies = advertisePoliciesInt
		for i, ps := range sl {

			apMapToStrVal := ps.(map[string]interface{})
			advertisePoliciesInt[i] = &ves_io_schema.ObjectRefType{}

			advertisePoliciesInt[i].Kind = "advertise_policy"

			if v, ok := apMapToStrVal["name"]; ok && !isIntfNil(v) {
				advertisePoliciesInt[i].Name = v.(string)
			}

			if v, ok := apMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				advertisePoliciesInt[i].Namespace = v.(string)
			}

			if v, ok := apMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				advertisePoliciesInt[i].Tenant = v.(string)
			}

			if v, ok := apMapToStrVal["uid"]; ok && !isIntfNil(v) {
				advertisePoliciesInt[i].Uid = v.(string)
			}

		}

	}

	//api_spec
	if v, ok := d.GetOk("api_spec"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		apiSpec := &ves_io_schema_virtual_host.ApiSpec{}
		createSpec.ApiSpec = apiSpec
		for _, set := range sl {
			if set != nil {
				apiSpecMapStrToI := set.(map[string]interface{})

				if v, ok := apiSpecMapStrToI["api_definition"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					apiDefinitionInt := &ves_io_schema_views.ObjectRefType{}
					apiSpec.ApiDefinition = apiDefinitionInt

					for _, set := range sl {
						if set != nil {
							adMapToStrVal := set.(map[string]interface{})
							if val, ok := adMapToStrVal["name"]; ok && !isIntfNil(v) {
								apiDefinitionInt.Name = val.(string)
							}
							if val, ok := adMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								apiDefinitionInt.Namespace = val.(string)
							}

							if val, ok := adMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								apiDefinitionInt.Tenant = val.(string)
							}
						}
					}

				}

				openApiValidationChoiceTypeFound := false

				if v, ok := apiSpecMapStrToI["disable_open_api_validation"]; ok && !isIntfNil(v) && !openApiValidationChoiceTypeFound {

					openApiValidationChoiceTypeFound = true

					if v.(bool) {
						openApiValidationChoiceInt := &ves_io_schema_virtual_host.ApiSpec_DisableOpenApiValidation{}
						openApiValidationChoiceInt.DisableOpenApiValidation = &ves_io_schema.Empty{}
						apiSpec.OpenApiValidationChoice = openApiValidationChoiceInt
					}

				}

				if v, ok := apiSpecMapStrToI["enable_open_api_validation"]; ok && !isIntfNil(v) && !openApiValidationChoiceTypeFound {

					openApiValidationChoiceTypeFound = true
					openApiValidationChoiceInt := &ves_io_schema_virtual_host.ApiSpec_EnableOpenApiValidation{}
					openApiValidationChoiceInt.EnableOpenApiValidation = &ves_io_schema_virtual_host.OpenApiValidationSettings{}
					apiSpec.OpenApiValidationChoice = openApiValidationChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["allow_only_specified_headers"]; ok && !isIntfNil(v) {

								openApiValidationChoiceInt.EnableOpenApiValidation.AllowOnlySpecifiedHeaders = v.(bool)

							}

							if v, ok := cs["allow_only_specified_query_params"]; ok && !isIntfNil(v) {

								openApiValidationChoiceInt.EnableOpenApiValidation.AllowOnlySpecifiedQueryParams = v.(bool)

							}

							if v, ok := cs["fail_close"]; ok && !isIntfNil(v) {

								openApiValidationChoiceInt.EnableOpenApiValidation.FailClose = v.(bool)

							}

							if v, ok := cs["fail_oversized_body_validation"]; ok && !isIntfNil(v) {

								openApiValidationChoiceInt.EnableOpenApiValidation.FailOversizedBodyValidation = v.(bool)

							}

						}
					}

				}

			}
		}

	}

	//authentication_choice

	authenticationChoiceTypeFound := false

	if v, ok := d.GetOk("authentication"); ok && !authenticationChoiceTypeFound {

		authenticationChoiceTypeFound = true
		authenticationChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_Authentication{}
		authenticationChoiceInt.Authentication = &ves_io_schema_virtual_host.AuthenticationDetails{}
		createSpec.AuthenticationChoice = authenticationChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["auth_config"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					authConfigInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					authenticationChoiceInt.Authentication.AuthConfig = authConfigInt
					for i, ps := range sl {

						acMapToStrVal := ps.(map[string]interface{})
						authConfigInt[i] = &ves_io_schema.ObjectRefType{}

						authConfigInt[i].Kind = "authentication"

						if v, ok := acMapToStrVal["name"]; ok && !isIntfNil(v) {
							authConfigInt[i].Name = v.(string)
						}

						if v, ok := acMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							authConfigInt[i].Namespace = v.(string)
						}

						if v, ok := acMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							authConfigInt[i].Tenant = v.(string)
						}

						if v, ok := acMapToStrVal["uid"]; ok && !isIntfNil(v) {
							authConfigInt[i].Uid = v.(string)
						}

					}

				}

				cookieParamsChoiceTypeFound := false

				if v, ok := cs["cookie_params"]; ok && !isIntfNil(v) && !cookieParamsChoiceTypeFound {

					cookieParamsChoiceTypeFound = true
					cookieParamsChoiceInt := &ves_io_schema_virtual_host.AuthenticationDetails_CookieParams{}
					cookieParamsChoiceInt.CookieParams = &ves_io_schema_authentication.CookieParams{}
					authenticationChoiceInt.Authentication.CookieParamsChoice = cookieParamsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["cookie_expiry"]; ok && !isIntfNil(v) {

								cookieParamsChoiceInt.CookieParams.CookieExpiry = uint32(v.(int))

							}

							if v, ok := cs["cookie_refresh_interval"]; ok && !isIntfNil(v) {

								cookieParamsChoiceInt.CookieParams.CookieRefreshInterval = uint32(v.(int))

							}

							secretChoiceTypeFound := false

							if v, ok := cs["auth_hmac"]; ok && !isIntfNil(v) && !secretChoiceTypeFound {

								secretChoiceTypeFound = true
								secretChoiceInt := &ves_io_schema_authentication.CookieParams_AuthHmac{}
								secretChoiceInt.AuthHmac = &ves_io_schema_authentication.HMACKeyPair{}
								cookieParamsChoiceInt.CookieParams.SecretChoice = secretChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["prim_key"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											primKey := &ves_io_schema.SecretType{}
											secretChoiceInt.AuthHmac.PrimKey = primKey
											for _, set := range sl {
												if set != nil {
													primKeyMapStrToI := set.(map[string]interface{})

													if v, ok := primKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														primKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := primKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														primKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := primKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														primKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := primKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														primKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := primKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														primKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := primKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														primKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

										if v, ok := cs["prim_key_expiry"]; ok && !isIntfNil(v) {

											ts, err := parseTime(v.(string))
											if err != nil {
												return fmt.Errorf("error creating PrimKeyExpiry, timestamp format is wrong: %s", err)
											}
											secretChoiceInt.AuthHmac.PrimKeyExpiry = ts
										}

										if v, ok := cs["sec_key"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											secKey := &ves_io_schema.SecretType{}
											secretChoiceInt.AuthHmac.SecKey = secKey
											for _, set := range sl {
												if set != nil {
													secKeyMapStrToI := set.(map[string]interface{})

													if v, ok := secKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														secKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := secKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														secKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := secKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														secKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := secKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														secKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := secKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														secKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := secKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														secKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

										if v, ok := cs["sec_key_expiry"]; ok && !isIntfNil(v) {

											ts, err := parseTime(v.(string))
											if err != nil {
												return fmt.Errorf("error creating SecKeyExpiry, timestamp format is wrong: %s", err)
											}
											secretChoiceInt.AuthHmac.SecKeyExpiry = ts
										}

									}
								}

							}

							if v, ok := cs["kms_key_hmac"]; ok && !isIntfNil(v) && !secretChoiceTypeFound {

								secretChoiceTypeFound = true
								secretChoiceInt := &ves_io_schema_authentication.CookieParams_KmsKeyHmac{}
								secretChoiceInt.KmsKeyHmac = &ves_io_schema_authentication.KMSKeyRefType{}
								cookieParamsChoiceInt.CookieParams.SecretChoice = secretChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["auth_hmac_kms"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											authHmacKmsInt := &ves_io_schema_views.ObjectRefType{}
											secretChoiceInt.KmsKeyHmac.AuthHmacKms = authHmacKmsInt

											for _, set := range sl {
												if set != nil {
													ahkMapToStrVal := set.(map[string]interface{})
													if val, ok := ahkMapToStrVal["name"]; ok && !isIntfNil(v) {
														authHmacKmsInt.Name = val.(string)
													}
													if val, ok := ahkMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														authHmacKmsInt.Namespace = val.(string)
													}

													if val, ok := ahkMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														authHmacKmsInt.Tenant = val.(string)
													}
												}
											}

										}

									}
								}

							}

							if v, ok := cs["session_expiry"]; ok && !isIntfNil(v) {

								cookieParamsChoiceInt.CookieParams.SessionExpiry = uint32(v.(int))

							}

						}
					}

				}

				if v, ok := cs["use_auth_object_config"]; ok && !isIntfNil(v) && !cookieParamsChoiceTypeFound {

					cookieParamsChoiceTypeFound = true

					if v.(bool) {
						cookieParamsChoiceInt := &ves_io_schema_virtual_host.AuthenticationDetails_UseAuthObjectConfig{}
						cookieParamsChoiceInt.UseAuthObjectConfig = &ves_io_schema.Empty{}
						authenticationChoiceInt.Authentication.CookieParamsChoice = cookieParamsChoiceInt
					}

				}

				redirectUrlChoiceTypeFound := false

				if v, ok := cs["redirect_dynamic"]; ok && !isIntfNil(v) && !redirectUrlChoiceTypeFound {

					redirectUrlChoiceTypeFound = true

					if v.(bool) {
						redirectUrlChoiceInt := &ves_io_schema_virtual_host.AuthenticationDetails_RedirectDynamic{}
						redirectUrlChoiceInt.RedirectDynamic = &ves_io_schema.Empty{}
						authenticationChoiceInt.Authentication.RedirectUrlChoice = redirectUrlChoiceInt
					}

				}

				if v, ok := cs["redirect_url"]; ok && !isIntfNil(v) && !redirectUrlChoiceTypeFound {

					redirectUrlChoiceTypeFound = true
					redirectUrlChoiceInt := &ves_io_schema_virtual_host.AuthenticationDetails_RedirectUrl{}

					authenticationChoiceInt.Authentication.RedirectUrlChoice = redirectUrlChoiceInt

					redirectUrlChoiceInt.RedirectUrl = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("no_authentication"); ok && !authenticationChoiceTypeFound {

		authenticationChoiceTypeFound = true

		if v.(bool) {
			authenticationChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_NoAuthentication{}
			authenticationChoiceInt.NoAuthentication = &ves_io_schema.Empty{}
			createSpec.AuthenticationChoice = authenticationChoiceInt
		}

	}

	//buffer_policy
	if v, ok := d.GetOk("buffer_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		bufferPolicy := &ves_io_schema.BufferConfigType{}
		createSpec.BufferPolicy = bufferPolicy
		for _, set := range sl {
			if set != nil {
				bufferPolicyMapStrToI := set.(map[string]interface{})

				if w, ok := bufferPolicyMapStrToI["disabled"]; ok && !isIntfNil(w) {
					bufferPolicy.Disabled = w.(bool)
				}

				if w, ok := bufferPolicyMapStrToI["max_request_bytes"]; ok && !isIntfNil(w) {
					bufferPolicy.MaxRequestBytes = uint32(w.(int))
				}

				if w, ok := bufferPolicyMapStrToI["max_request_time"]; ok && !isIntfNil(w) {
					bufferPolicy.MaxRequestTime = uint32(w.(int))
				}

			}
		}

	}

	//challenge_type

	challengeTypeTypeFound := false

	if v, ok := d.GetOk("captcha_challenge"); ok && !challengeTypeTypeFound {

		challengeTypeTypeFound = true
		challengeTypeInt := &ves_io_schema_virtual_host.CreateSpecType_CaptchaChallenge{}
		challengeTypeInt.CaptchaChallenge = &ves_io_schema_virtual_host.CaptchaChallengeType{}
		createSpec.ChallengeType = challengeTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["cookie_expiry"]; ok && !isIntfNil(v) {

					challengeTypeInt.CaptchaChallenge.CookieExpiry = uint32(v.(int))

				}

				if v, ok := cs["custom_page"]; ok && !isIntfNil(v) {

					challengeTypeInt.CaptchaChallenge.CustomPage = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("js_challenge"); ok && !challengeTypeTypeFound {

		challengeTypeTypeFound = true
		challengeTypeInt := &ves_io_schema_virtual_host.CreateSpecType_JsChallenge{}
		challengeTypeInt.JsChallenge = &ves_io_schema_virtual_host.JavascriptChallengeType{}
		createSpec.ChallengeType = challengeTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["cookie_expiry"]; ok && !isIntfNil(v) {

					challengeTypeInt.JsChallenge.CookieExpiry = uint32(v.(int))

				}

				if v, ok := cs["custom_page"]; ok && !isIntfNil(v) {

					challengeTypeInt.JsChallenge.CustomPage = v.(string)

				}

				if v, ok := cs["js_script_delay"]; ok && !isIntfNil(v) {

					challengeTypeInt.JsChallenge.JsScriptDelay = uint32(v.(int))

				}

			}
		}

	}

	if v, ok := d.GetOk("no_challenge"); ok && !challengeTypeTypeFound {

		challengeTypeTypeFound = true

		if v.(bool) {
			challengeTypeInt := &ves_io_schema_virtual_host.CreateSpecType_NoChallenge{}
			challengeTypeInt.NoChallenge = &ves_io_schema.Empty{}
			createSpec.ChallengeType = challengeTypeInt
		}

	}

	//coalescing_options
	if v, ok := d.GetOk("coalescing_options"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		coalescingOptions := &ves_io_schema.TLSCoalescingOptions{}
		createSpec.CoalescingOptions = coalescingOptions
		for _, set := range sl {
			if set != nil {
				coalescingOptionsMapStrToI := set.(map[string]interface{})

				coalescingChoiceTypeFound := false

				if v, ok := coalescingOptionsMapStrToI["default_coalescing"]; ok && !isIntfNil(v) && !coalescingChoiceTypeFound {

					coalescingChoiceTypeFound = true

					if v.(bool) {
						coalescingChoiceInt := &ves_io_schema.TLSCoalescingOptions_DefaultCoalescing{}
						coalescingChoiceInt.DefaultCoalescing = &ves_io_schema.Empty{}
						coalescingOptions.CoalescingChoice = coalescingChoiceInt
					}

				}

				if v, ok := coalescingOptionsMapStrToI["strict_coalescing"]; ok && !isIntfNil(v) && !coalescingChoiceTypeFound {

					coalescingChoiceTypeFound = true

					if v.(bool) {
						coalescingChoiceInt := &ves_io_schema.TLSCoalescingOptions_StrictCoalescing{}
						coalescingChoiceInt.StrictCoalescing = &ves_io_schema.Empty{}
						coalescingOptions.CoalescingChoice = coalescingChoiceInt
					}

				}

			}
		}

	}

	//compression_params
	if v, ok := d.GetOk("compression_params"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		compressionParams := &ves_io_schema_virtual_host.CompressionType{}
		createSpec.CompressionParams = compressionParams
		for _, set := range sl {
			if set != nil {
				compressionParamsMapStrToI := set.(map[string]interface{})

				if w, ok := compressionParamsMapStrToI["content_length"]; ok && !isIntfNil(w) {
					compressionParams.ContentLength = uint32(w.(int))
				}

				if w, ok := compressionParamsMapStrToI["content_type"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = v.(string)
					}
					compressionParams.ContentType = ls
				}

				if w, ok := compressionParamsMapStrToI["disable_on_etag_header"]; ok && !isIntfNil(w) {
					compressionParams.DisableOnEtagHeader = w.(bool)
				}

				if w, ok := compressionParamsMapStrToI["remove_accept_encoding_header"]; ok && !isIntfNil(w) {
					compressionParams.RemoveAcceptEncodingHeader = w.(bool)
				}

			}
		}

	}

	//connection_idle_timeout
	if v, ok := d.GetOk("connection_idle_timeout"); ok && !isIntfNil(v) {

		createSpec.ConnectionIdleTimeout =
			uint32(v.(int))

	}

	//cookies_to_modify
	if v, ok := d.GetOk("cookies_to_modify"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		cookiesToModify := make([]*ves_io_schema.CookieManipulationOptionType, len(sl))
		createSpec.CookiesToModify = cookiesToModify
		for i, set := range sl {
			if set != nil {
				cookiesToModify[i] = &ves_io_schema.CookieManipulationOptionType{}
				cookiesToModifyMapStrToI := set.(map[string]interface{})

				cookieTamperingTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["disable_tampering_protection"]; ok && !isIntfNil(v) && !cookieTamperingTypeFound {

					cookieTamperingTypeFound = true

					if v.(bool) {
						cookieTamperingInt := &ves_io_schema.CookieManipulationOptionType_DisableTamperingProtection{}
						cookieTamperingInt.DisableTamperingProtection = &ves_io_schema.Empty{}
						cookiesToModify[i].CookieTampering = cookieTamperingInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["enable_tampering_protection"]; ok && !isIntfNil(v) && !cookieTamperingTypeFound {

					cookieTamperingTypeFound = true

					if v.(bool) {
						cookieTamperingInt := &ves_io_schema.CookieManipulationOptionType_EnableTamperingProtection{}
						cookieTamperingInt.EnableTamperingProtection = &ves_io_schema.Empty{}
						cookiesToModify[i].CookieTampering = cookieTamperingInt
					}

				}

				httponlyTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["add_httponly"]; ok && !isIntfNil(v) && !httponlyTypeFound {

					httponlyTypeFound = true

					if v.(bool) {
						httponlyInt := &ves_io_schema.CookieManipulationOptionType_AddHttponly{}
						httponlyInt.AddHttponly = &ves_io_schema.Empty{}
						cookiesToModify[i].Httponly = httponlyInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["ignore_httponly"]; ok && !isIntfNil(v) && !httponlyTypeFound {

					httponlyTypeFound = true

					if v.(bool) {
						httponlyInt := &ves_io_schema.CookieManipulationOptionType_IgnoreHttponly{}
						httponlyInt.IgnoreHttponly = &ves_io_schema.Empty{}
						cookiesToModify[i].Httponly = httponlyInt
					}

				}

				maxAgeTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["ignore_max_age"]; ok && !isIntfNil(v) && !maxAgeTypeFound {

					maxAgeTypeFound = true

					if v.(bool) {
						maxAgeInt := &ves_io_schema.CookieManipulationOptionType_IgnoreMaxAge{}
						maxAgeInt.IgnoreMaxAge = &ves_io_schema.Empty{}
						cookiesToModify[i].MaxAge = maxAgeInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["max_age_value"]; ok && !isIntfNil(v) && !maxAgeTypeFound {

					maxAgeTypeFound = true
					maxAgeInt := &ves_io_schema.CookieManipulationOptionType_MaxAgeValue{}

					cookiesToModify[i].MaxAge = maxAgeInt

					maxAgeInt.MaxAgeValue = int32(v.(int))

				}

				if w, ok := cookiesToModifyMapStrToI["name"]; ok && !isIntfNil(w) {
					cookiesToModify[i].Name = w.(string)
				}

				samesiteTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["ignore_samesite"]; ok && !isIntfNil(v) && !samesiteTypeFound {

					samesiteTypeFound = true

					if v.(bool) {
						samesiteInt := &ves_io_schema.CookieManipulationOptionType_IgnoreSamesite{}
						samesiteInt.IgnoreSamesite = &ves_io_schema.Empty{}
						cookiesToModify[i].Samesite = samesiteInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["samesite_lax"]; ok && !isIntfNil(v) && !samesiteTypeFound {

					samesiteTypeFound = true

					if v.(bool) {
						samesiteInt := &ves_io_schema.CookieManipulationOptionType_SamesiteLax{}
						samesiteInt.SamesiteLax = &ves_io_schema.Empty{}
						cookiesToModify[i].Samesite = samesiteInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["samesite_none"]; ok && !isIntfNil(v) && !samesiteTypeFound {

					samesiteTypeFound = true

					if v.(bool) {
						samesiteInt := &ves_io_schema.CookieManipulationOptionType_SamesiteNone{}
						samesiteInt.SamesiteNone = &ves_io_schema.Empty{}
						cookiesToModify[i].Samesite = samesiteInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["samesite_strict"]; ok && !isIntfNil(v) && !samesiteTypeFound {

					samesiteTypeFound = true

					if v.(bool) {
						samesiteInt := &ves_io_schema.CookieManipulationOptionType_SamesiteStrict{}
						samesiteInt.SamesiteStrict = &ves_io_schema.Empty{}
						cookiesToModify[i].Samesite = samesiteInt
					}

				}

				secureTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["add_secure"]; ok && !isIntfNil(v) && !secureTypeFound {

					secureTypeFound = true

					if v.(bool) {
						secureInt := &ves_io_schema.CookieManipulationOptionType_AddSecure{}
						secureInt.AddSecure = &ves_io_schema.Empty{}
						cookiesToModify[i].Secure = secureInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["ignore_secure"]; ok && !isIntfNil(v) && !secureTypeFound {

					secureTypeFound = true

					if v.(bool) {
						secureInt := &ves_io_schema.CookieManipulationOptionType_IgnoreSecure{}
						secureInt.IgnoreSecure = &ves_io_schema.Empty{}
						cookiesToModify[i].Secure = secureInt
					}

				}

			}
		}

	}

	//cors_policy
	if v, ok := d.GetOk("cors_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		corsPolicy := &ves_io_schema.CorsPolicy{}
		createSpec.CorsPolicy = corsPolicy
		for _, set := range sl {
			if set != nil {
				corsPolicyMapStrToI := set.(map[string]interface{})

				if w, ok := corsPolicyMapStrToI["allow_credentials"]; ok && !isIntfNil(w) {
					corsPolicy.AllowCredentials = w.(bool)
				}

				if w, ok := corsPolicyMapStrToI["allow_headers"]; ok && !isIntfNil(w) {
					corsPolicy.AllowHeaders = w.(string)
				}

				if w, ok := corsPolicyMapStrToI["allow_methods"]; ok && !isIntfNil(w) {
					corsPolicy.AllowMethods = w.(string)
				}

				if w, ok := corsPolicyMapStrToI["allow_origin"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = v.(string)
					}
					corsPolicy.AllowOrigin = ls
				}

				if w, ok := corsPolicyMapStrToI["allow_origin_regex"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = v.(string)
					}
					corsPolicy.AllowOriginRegex = ls
				}

				if w, ok := corsPolicyMapStrToI["disabled"]; ok && !isIntfNil(w) {
					corsPolicy.Disabled = w.(bool)
				}

				if w, ok := corsPolicyMapStrToI["expose_headers"]; ok && !isIntfNil(w) {
					corsPolicy.ExposeHeaders = w.(string)
				}

				if w, ok := corsPolicyMapStrToI["max_age"]; ok && !isIntfNil(w) {
					corsPolicy.MaxAge = w.(string)
				}

				if w, ok := corsPolicyMapStrToI["maximum_age"]; ok && !isIntfNil(w) {
					corsPolicy.MaximumAge = int32(w.(int))
				}

			}
		}

	}

	//csrf_policy
	if v, ok := d.GetOk("csrf_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		csrfPolicy := &ves_io_schema.CsrfPolicy{}
		createSpec.CsrfPolicy = csrfPolicy
		for _, set := range sl {
			if set != nil {
				csrfPolicyMapStrToI := set.(map[string]interface{})

				allowedDomainsTypeFound := false

				if v, ok := csrfPolicyMapStrToI["all_load_balancer_domains"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

					allowedDomainsTypeFound = true

					if v.(bool) {
						allowedDomainsInt := &ves_io_schema.CsrfPolicy_AllLoadBalancerDomains{}
						allowedDomainsInt.AllLoadBalancerDomains = &ves_io_schema.Empty{}
						csrfPolicy.AllowedDomains = allowedDomainsInt
					}

				}

				if v, ok := csrfPolicyMapStrToI["custom_domain_list"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

					allowedDomainsTypeFound = true
					allowedDomainsInt := &ves_io_schema.CsrfPolicy_CustomDomainList{}
					allowedDomainsInt.CustomDomainList = &ves_io_schema.DomainNameList{}
					csrfPolicy.AllowedDomains = allowedDomainsInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["domains"]; ok && !isIntfNil(v) {

								ls := make([]string, len(v.([]interface{})))
								for i, v := range v.([]interface{}) {
									ls[i] = v.(string)
								}
								allowedDomainsInt.CustomDomainList.Domains = ls

							}

						}
					}

				}

				if v, ok := csrfPolicyMapStrToI["disabled"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

					allowedDomainsTypeFound = true

					if v.(bool) {
						allowedDomainsInt := &ves_io_schema.CsrfPolicy_Disabled{}
						allowedDomainsInt.Disabled = &ves_io_schema.Empty{}
						csrfPolicy.AllowedDomains = allowedDomainsInt
					}

				}

			}
		}

	}

	//custom_errors

	//default_lb_choice

	defaultLbChoiceTypeFound := false

	if v, ok := d.GetOk("default_loadbalancer"); ok && !defaultLbChoiceTypeFound {

		defaultLbChoiceTypeFound = true

		if v.(bool) {
			defaultLbChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_DefaultLoadbalancer{}
			defaultLbChoiceInt.DefaultLoadbalancer = &ves_io_schema.Empty{}
			createSpec.DefaultLbChoice = defaultLbChoiceInt
		}

	}

	if v, ok := d.GetOk("non_default_loadbalancer"); ok && !defaultLbChoiceTypeFound {

		defaultLbChoiceTypeFound = true

		if v.(bool) {
			defaultLbChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_NonDefaultLoadbalancer{}
			defaultLbChoiceInt.NonDefaultLoadbalancer = &ves_io_schema.Empty{}
			createSpec.DefaultLbChoice = defaultLbChoiceInt
		}

	}

	//disable_default_error_pages
	if v, ok := d.GetOk("disable_default_error_pages"); ok && !isIntfNil(v) {

		createSpec.DisableDefaultErrorPages =
			v.(bool)

	}

	//disable_dns_resolve
	if v, ok := d.GetOk("disable_dns_resolve"); ok && !isIntfNil(v) {

		createSpec.DisableDnsResolve =
			v.(bool)

	}

	//dns_proxy_configuration
	if v, ok := d.GetOk("dns_proxy_configuration"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		dnsProxyConfiguration := &ves_io_schema_virtual_host.DNSProxyConfiguration{}
		createSpec.DnsProxyConfiguration = dnsProxyConfiguration
		for _, set := range sl {
			if set != nil {
				dnsProxyConfigurationMapStrToI := set.(map[string]interface{})

				if v, ok := dnsProxyConfigurationMapStrToI["cache_profile"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					cacheProfile := &ves_io_schema_virtual_host.DNSCacheProfile{}
					dnsProxyConfiguration.CacheProfile = cacheProfile
					for _, set := range sl {
						if set != nil {
							cacheProfileMapStrToI := set.(map[string]interface{})

							cacheProfileChoiceTypeFound := false

							if v, ok := cacheProfileMapStrToI["cache_size"]; ok && !isIntfNil(v) && !cacheProfileChoiceTypeFound {

								cacheProfileChoiceTypeFound = true
								cacheProfileChoiceInt := &ves_io_schema_virtual_host.DNSCacheProfile_CacheSize{}

								cacheProfile.CacheProfileChoice = cacheProfileChoiceInt

								cacheProfileChoiceInt.CacheSize = uint32(v.(int))

							}

							if v, ok := cacheProfileMapStrToI["disable_cache_profile"]; ok && !isIntfNil(v) && !cacheProfileChoiceTypeFound {

								cacheProfileChoiceTypeFound = true

								if v.(bool) {
									cacheProfileChoiceInt := &ves_io_schema_virtual_host.DNSCacheProfile_DisableCacheProfile{}
									cacheProfileChoiceInt.DisableCacheProfile = &ves_io_schema.Empty{}
									cacheProfile.CacheProfileChoice = cacheProfileChoiceInt
								}

							}

						}
					}

				}

				if v, ok := dnsProxyConfigurationMapStrToI["ddos_profile"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ddosProfile := &ves_io_schema_virtual_host.DNSDDoSProfile{}
					dnsProxyConfiguration.DdosProfile = ddosProfile
					for _, set := range sl {
						if set != nil {
							ddosProfileMapStrToI := set.(map[string]interface{})

							ddosMitigationChoiceTypeFound := false

							if v, ok := ddosProfileMapStrToI["disable_ddos_mitigation"]; ok && !isIntfNil(v) && !ddosMitigationChoiceTypeFound {

								ddosMitigationChoiceTypeFound = true

								if v.(bool) {
									ddosMitigationChoiceInt := &ves_io_schema_virtual_host.DNSDDoSProfile_DisableDdosMitigation{}
									ddosMitigationChoiceInt.DisableDdosMitigation = &ves_io_schema.Empty{}
									ddosProfile.DdosMitigationChoice = ddosMitigationChoiceInt
								}

							}

							if v, ok := ddosProfileMapStrToI["enable_ddos_mitigation"]; ok && !isIntfNil(v) && !ddosMitigationChoiceTypeFound {

								ddosMitigationChoiceTypeFound = true

								if v.(bool) {
									ddosMitigationChoiceInt := &ves_io_schema_virtual_host.DNSDDoSProfile_EnableDdosMitigation{}
									ddosMitigationChoiceInt.EnableDdosMitigation = &ves_io_schema.Empty{}
									ddosProfile.DdosMitigationChoice = ddosMitigationChoiceInt
								}

							}

						}
					}

				}

				if v, ok := dnsProxyConfigurationMapStrToI["irules"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					irulesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
					dnsProxyConfiguration.Irules = irulesInt
					for i, ps := range sl {

						iMapToStrVal := ps.(map[string]interface{})
						irulesInt[i] = &ves_io_schema_views.ObjectRefType{}

						if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
							irulesInt[i].Name = v.(string)
						}

						if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							irulesInt[i].Namespace = v.(string)
						}

						if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							irulesInt[i].Tenant = v.(string)
						}

					}

				}

				if v, ok := dnsProxyConfigurationMapStrToI["protocol_inspection"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					protocolInspectionInt := &ves_io_schema_views.ObjectRefType{}
					dnsProxyConfiguration.ProtocolInspection = protocolInspectionInt

					for _, set := range sl {
						if set != nil {
							piMapToStrVal := set.(map[string]interface{})
							if val, ok := piMapToStrVal["name"]; ok && !isIntfNil(v) {
								protocolInspectionInt.Name = val.(string)
							}
							if val, ok := piMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								protocolInspectionInt.Namespace = val.(string)
							}

							if val, ok := piMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								protocolInspectionInt.Tenant = val.(string)
							}
						}
					}

				}

			}
		}

	}

	//domain_cert_map
	if v, ok := d.GetOk("domain_cert_map"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		domainCertMap := make(map[string]*ves_io_schema_virtual_host.DomainCertificates)
		createSpec.DomainCertMap = domainCertMap
		for _, set := range sl {
			if set != nil {
				domainCertMapMapStrToI := set.(map[string]interface{})
				key, ok := domainCertMapMapStrToI["name"]
				if ok && !isIntfNil(key) {
					domainCertMap[key.(string)] = &ves_io_schema_virtual_host.DomainCertificates{}
					val, _ := domainCertMapMapStrToI["value"]

					domainCertMapVals := val.([]interface{})
					for _, intVal := range domainCertMapVals {
						if intVal != nil {

							domainCertMapStaticMap := intVal.(map[string]interface{})

							if w, ok := domainCertMapStaticMap["ecdsa_certificates"]; ok && !isIntfNil(w) {
								domainCertMap[key.(string)].EcdsaCertificates = w.([]*ves_io_schema.ObjectRefType)
							}

							if w, ok := domainCertMapStaticMap["rsa_certificates"]; ok && !isIntfNil(w) {
								domainCertMap[key.(string)].RsaCertificates = w.([]*ves_io_schema.ObjectRefType)
							}

							// break after one loop
							break
						}
					}
				}
			}
		}

	}

	//domains
	if v, ok := d.GetOk("domains"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		createSpec.Domains = ls

	}

	//dynamic_reverse_proxy
	if v, ok := d.GetOk("dynamic_reverse_proxy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		dynamicReverseProxy := &ves_io_schema_virtual_host.DynamicReverseProxyType{}
		createSpec.DynamicReverseProxy = dynamicReverseProxy
		for _, set := range sl {
			if set != nil {
				dynamicReverseProxyMapStrToI := set.(map[string]interface{})

				if w, ok := dynamicReverseProxyMapStrToI["connection_timeout"]; ok && !isIntfNil(w) {
					dynamicReverseProxy.ConnectionTimeout = uint32(w.(int))
				}

				if v, ok := dynamicReverseProxyMapStrToI["resolution_network"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					resolutionNetworkInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					dynamicReverseProxy.ResolutionNetwork = resolutionNetworkInt
					for i, ps := range sl {

						rnMapToStrVal := ps.(map[string]interface{})
						resolutionNetworkInt[i] = &ves_io_schema.ObjectRefType{}

						resolutionNetworkInt[i].Kind = "virtual_network"

						if v, ok := rnMapToStrVal["name"]; ok && !isIntfNil(v) {
							resolutionNetworkInt[i].Name = v.(string)
						}

						if v, ok := rnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							resolutionNetworkInt[i].Namespace = v.(string)
						}

						if v, ok := rnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							resolutionNetworkInt[i].Tenant = v.(string)
						}

						if v, ok := rnMapToStrVal["uid"]; ok && !isIntfNil(v) {
							resolutionNetworkInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := dynamicReverseProxyMapStrToI["resolution_network_type"]; ok && !isIntfNil(v) {

					dynamicReverseProxy.ResolutionNetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

				}

				if w, ok := dynamicReverseProxyMapStrToI["resolve_endpoint_dynamically"]; ok && !isIntfNil(w) {
					dynamicReverseProxy.ResolveEndpointDynamically = w.(bool)
				}

			}
		}

	}

	//header_transformation_type
	if v, ok := d.GetOk("header_transformation_type"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		headerTransformationType := &ves_io_schema.HeaderTransformationType{}
		createSpec.HeaderTransformationType = headerTransformationType
		for _, set := range sl {
			if set != nil {
				headerTransformationTypeMapStrToI := set.(map[string]interface{})

				headerTransformationChoiceTypeFound := false

				if v, ok := headerTransformationTypeMapStrToI["default_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

					headerTransformationChoiceTypeFound = true

					if v.(bool) {
						headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_DefaultHeaderTransformation{}
						headerTransformationChoiceInt.DefaultHeaderTransformation = &ves_io_schema.Empty{}
						headerTransformationType.HeaderTransformationChoice = headerTransformationChoiceInt
					}

				}

				if v, ok := headerTransformationTypeMapStrToI["legacy_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

					headerTransformationChoiceTypeFound = true

					if v.(bool) {
						headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_LegacyHeaderTransformation{}
						headerTransformationChoiceInt.LegacyHeaderTransformation = &ves_io_schema.Empty{}
						headerTransformationType.HeaderTransformationChoice = headerTransformationChoiceInt
					}

				}

				if v, ok := headerTransformationTypeMapStrToI["preserve_case_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

					headerTransformationChoiceTypeFound = true

					if v.(bool) {
						headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_PreserveCaseHeaderTransformation{}
						headerTransformationChoiceInt.PreserveCaseHeaderTransformation = &ves_io_schema.Empty{}
						headerTransformationType.HeaderTransformationChoice = headerTransformationChoiceInt
					}

				}

				if v, ok := headerTransformationTypeMapStrToI["proper_case_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

					headerTransformationChoiceTypeFound = true

					if v.(bool) {
						headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_ProperCaseHeaderTransformation{}
						headerTransformationChoiceInt.ProperCaseHeaderTransformation = &ves_io_schema.Empty{}
						headerTransformationType.HeaderTransformationChoice = headerTransformationChoiceInt
					}

				}

			}
		}

	}

	//http_protocol_options
	if v, ok := d.GetOk("http_protocol_options"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		httpProtocolOptions := &ves_io_schema_virtual_host.HttpProtocolOptions{}
		createSpec.HttpProtocolOptions = httpProtocolOptions
		for _, set := range sl {
			if set != nil {
				httpProtocolOptionsMapStrToI := set.(map[string]interface{})

				httpProtocolChoiceTypeFound := false

				if v, ok := httpProtocolOptionsMapStrToI["http_protocol_enable_v1_only"]; ok && !isIntfNil(v) && !httpProtocolChoiceTypeFound {

					httpProtocolChoiceTypeFound = true
					httpProtocolChoiceInt := &ves_io_schema_virtual_host.HttpProtocolOptions_HttpProtocolEnableV1Only{}
					httpProtocolChoiceInt.HttpProtocolEnableV1Only = &ves_io_schema_virtual_host.Http1ProtocolOptions{}
					httpProtocolOptions.HttpProtocolChoice = httpProtocolChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["header_transformation"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								headerTransformation := &ves_io_schema.HeaderTransformationType{}
								httpProtocolChoiceInt.HttpProtocolEnableV1Only.HeaderTransformation = headerTransformation
								for _, set := range sl {
									if set != nil {
										headerTransformationMapStrToI := set.(map[string]interface{})

										headerTransformationChoiceTypeFound := false

										if v, ok := headerTransformationMapStrToI["default_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

											headerTransformationChoiceTypeFound = true

											if v.(bool) {
												headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_DefaultHeaderTransformation{}
												headerTransformationChoiceInt.DefaultHeaderTransformation = &ves_io_schema.Empty{}
												headerTransformation.HeaderTransformationChoice = headerTransformationChoiceInt
											}

										}

										if v, ok := headerTransformationMapStrToI["legacy_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

											headerTransformationChoiceTypeFound = true

											if v.(bool) {
												headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_LegacyHeaderTransformation{}
												headerTransformationChoiceInt.LegacyHeaderTransformation = &ves_io_schema.Empty{}
												headerTransformation.HeaderTransformationChoice = headerTransformationChoiceInt
											}

										}

										if v, ok := headerTransformationMapStrToI["preserve_case_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

											headerTransformationChoiceTypeFound = true

											if v.(bool) {
												headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_PreserveCaseHeaderTransformation{}
												headerTransformationChoiceInt.PreserveCaseHeaderTransformation = &ves_io_schema.Empty{}
												headerTransformation.HeaderTransformationChoice = headerTransformationChoiceInt
											}

										}

										if v, ok := headerTransformationMapStrToI["proper_case_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

											headerTransformationChoiceTypeFound = true

											if v.(bool) {
												headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_ProperCaseHeaderTransformation{}
												headerTransformationChoiceInt.ProperCaseHeaderTransformation = &ves_io_schema.Empty{}
												headerTransformation.HeaderTransformationChoice = headerTransformationChoiceInt
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := httpProtocolOptionsMapStrToI["http_protocol_enable_v1_v2"]; ok && !isIntfNil(v) && !httpProtocolChoiceTypeFound {

					httpProtocolChoiceTypeFound = true

					if v.(bool) {
						httpProtocolChoiceInt := &ves_io_schema_virtual_host.HttpProtocolOptions_HttpProtocolEnableV1V2{}
						httpProtocolChoiceInt.HttpProtocolEnableV1V2 = &ves_io_schema.Empty{}
						httpProtocolOptions.HttpProtocolChoice = httpProtocolChoiceInt
					}

				}

				if v, ok := httpProtocolOptionsMapStrToI["http_protocol_enable_v2_only"]; ok && !isIntfNil(v) && !httpProtocolChoiceTypeFound {

					httpProtocolChoiceTypeFound = true

					if v.(bool) {
						httpProtocolChoiceInt := &ves_io_schema_virtual_host.HttpProtocolOptions_HttpProtocolEnableV2Only{}
						httpProtocolChoiceInt.HttpProtocolEnableV2Only = &ves_io_schema.Empty{}
						httpProtocolOptions.HttpProtocolChoice = httpProtocolChoiceInt
					}

				}

			}
		}

	}

	//idle_timeout
	if v, ok := d.GetOk("idle_timeout"); ok && !isIntfNil(v) {

		createSpec.IdleTimeout =
			uint32(v.(int))

	}

	//masking_config
	if v, ok := d.GetOk("masking_config"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		maskingConfig := &ves_io_schema_virtual_host.MaskingConfiguration{}
		createSpec.MaskingConfig = maskingConfig
		for _, set := range sl {
			if set != nil {
				maskingConfigMapStrToI := set.(map[string]interface{})

				maskingChoiceTypeFound := false

				if v, ok := maskingConfigMapStrToI["disable_masking"]; ok && !isIntfNil(v) && !maskingChoiceTypeFound {

					maskingChoiceTypeFound = true

					if v.(bool) {
						maskingChoiceInt := &ves_io_schema_virtual_host.MaskingConfiguration_DisableMasking{}
						maskingChoiceInt.DisableMasking = &ves_io_schema.Empty{}
						maskingConfig.MaskingChoice = maskingChoiceInt
					}

				}

				if v, ok := maskingConfigMapStrToI["enable_masking"]; ok && !isIntfNil(v) && !maskingChoiceTypeFound {

					maskingChoiceTypeFound = true

					if v.(bool) {
						maskingChoiceInt := &ves_io_schema_virtual_host.MaskingConfiguration_EnableMasking{}
						maskingChoiceInt.EnableMasking = &ves_io_schema.Empty{}
						maskingConfig.MaskingChoice = maskingChoiceInt
					}

				}

			}
		}

	}

	//max_direct_response_body_size
	if v, ok := d.GetOk("max_direct_response_body_size"); ok && !isIntfNil(v) {

		createSpec.MaxDirectResponseBodySize =
			uint32(v.(int))

	}

	//max_request_header_size
	if v, ok := d.GetOk("max_request_header_size"); ok && !isIntfNil(v) {

		createSpec.MaxRequestHeaderSize =
			uint32(v.(int))

	}

	//path_normalize_choice

	pathNormalizeChoiceTypeFound := false

	if v, ok := d.GetOk("disable_path_normalize"); ok && !pathNormalizeChoiceTypeFound {

		pathNormalizeChoiceTypeFound = true

		if v.(bool) {
			pathNormalizeChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_DisablePathNormalize{}
			pathNormalizeChoiceInt.DisablePathNormalize = &ves_io_schema.Empty{}
			createSpec.PathNormalizeChoice = pathNormalizeChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_path_normalize"); ok && !pathNormalizeChoiceTypeFound {

		pathNormalizeChoiceTypeFound = true

		if v.(bool) {
			pathNormalizeChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_EnablePathNormalize{}
			pathNormalizeChoiceInt.EnablePathNormalize = &ves_io_schema.Empty{}
			createSpec.PathNormalizeChoice = pathNormalizeChoiceInt
		}

	}

	//proxy
	if v, ok := d.GetOk("proxy"); ok && !isIntfNil(v) {

		createSpec.Proxy = ves_io_schema_virtual_host.ProxyType(ves_io_schema_virtual_host.ProxyType_value[v.(string)])

	}

	//rate_limiter_allowed_prefixes
	if v, ok := d.GetOk("rate_limiter_allowed_prefixes"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		rateLimiterAllowedPrefixesInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		createSpec.RateLimiterAllowedPrefixes = rateLimiterAllowedPrefixesInt
		for i, ps := range sl {

			rlapMapToStrVal := ps.(map[string]interface{})
			rateLimiterAllowedPrefixesInt[i] = &ves_io_schema.ObjectRefType{}

			rateLimiterAllowedPrefixesInt[i].Kind = "ip_prefix_set"

			if v, ok := rlapMapToStrVal["name"]; ok && !isIntfNil(v) {
				rateLimiterAllowedPrefixesInt[i].Name = v.(string)
			}

			if v, ok := rlapMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				rateLimiterAllowedPrefixesInt[i].Namespace = v.(string)
			}

			if v, ok := rlapMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				rateLimiterAllowedPrefixesInt[i].Tenant = v.(string)
			}

			if v, ok := rlapMapToStrVal["uid"]; ok && !isIntfNil(v) {
				rateLimiterAllowedPrefixesInt[i].Uid = v.(string)
			}

		}

	}

	//request_headers_to_add
	if v, ok := d.GetOk("request_headers_to_add"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		requestHeadersToAdd := make([]*ves_io_schema.HeaderManipulationOptionType, len(sl))
		createSpec.RequestHeadersToAdd = requestHeadersToAdd
		for i, set := range sl {
			if set != nil {
				requestHeadersToAdd[i] = &ves_io_schema.HeaderManipulationOptionType{}
				requestHeadersToAddMapStrToI := set.(map[string]interface{})

				if w, ok := requestHeadersToAddMapStrToI["append"]; ok && !isIntfNil(w) {
					requestHeadersToAdd[i].Append = w.(bool)
				}

				if w, ok := requestHeadersToAddMapStrToI["name"]; ok && !isIntfNil(w) {
					requestHeadersToAdd[i].Name = w.(string)
				}

				valueChoiceTypeFound := false

				if v, ok := requestHeadersToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

					valueChoiceTypeFound = true
					valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_SecretValue{}
					valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
					requestHeadersToAdd[i].ValueChoice = valueChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

								valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := requestHeadersToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

					valueChoiceTypeFound = true
					valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_Value{}

					requestHeadersToAdd[i].ValueChoice = valueChoiceInt

					valueChoiceInt.Value = v.(string)

				}

			}
		}

	}

	//request_headers_to_remove
	if v, ok := d.GetOk("request_headers_to_remove"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		createSpec.RequestHeadersToRemove = ls

	}

	//response_headers_to_add
	if v, ok := d.GetOk("response_headers_to_add"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		responseHeadersToAdd := make([]*ves_io_schema.HeaderManipulationOptionType, len(sl))
		createSpec.ResponseHeadersToAdd = responseHeadersToAdd
		for i, set := range sl {
			if set != nil {
				responseHeadersToAdd[i] = &ves_io_schema.HeaderManipulationOptionType{}
				responseHeadersToAddMapStrToI := set.(map[string]interface{})

				if w, ok := responseHeadersToAddMapStrToI["append"]; ok && !isIntfNil(w) {
					responseHeadersToAdd[i].Append = w.(bool)
				}

				if w, ok := responseHeadersToAddMapStrToI["name"]; ok && !isIntfNil(w) {
					responseHeadersToAdd[i].Name = w.(string)
				}

				valueChoiceTypeFound := false

				if v, ok := responseHeadersToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

					valueChoiceTypeFound = true
					valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_SecretValue{}
					valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
					responseHeadersToAdd[i].ValueChoice = valueChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

								valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := responseHeadersToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

					valueChoiceTypeFound = true
					valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_Value{}

					responseHeadersToAdd[i].ValueChoice = valueChoiceInt

					valueChoiceInt.Value = v.(string)

				}

			}
		}

	}

	//response_headers_to_remove
	if v, ok := d.GetOk("response_headers_to_remove"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		createSpec.ResponseHeadersToRemove = ls

	}

	//retry_policy
	if v, ok := d.GetOk("retry_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		retryPolicy := &ves_io_schema.RetryPolicyType{}
		createSpec.RetryPolicy = retryPolicy
		for _, set := range sl {
			if set != nil {
				retryPolicyMapStrToI := set.(map[string]interface{})

				if v, ok := retryPolicyMapStrToI["back_off"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					backOff := &ves_io_schema.RetryBackOff{}
					retryPolicy.BackOff = backOff
					for _, set := range sl {
						if set != nil {
							backOffMapStrToI := set.(map[string]interface{})

							if w, ok := backOffMapStrToI["base_interval"]; ok && !isIntfNil(w) {
								backOff.BaseInterval = uint32(w.(int))
							}

							if w, ok := backOffMapStrToI["max_interval"]; ok && !isIntfNil(w) {
								backOff.MaxInterval = uint32(w.(int))
							}

						}
					}

				}

				if w, ok := retryPolicyMapStrToI["num_retries"]; ok && !isIntfNil(w) {
					retryPolicy.NumRetries = uint32(w.(int))
				}

				if w, ok := retryPolicyMapStrToI["per_try_timeout"]; ok && !isIntfNil(w) {
					retryPolicy.PerTryTimeout = uint32(w.(int))
				}

				if w, ok := retryPolicyMapStrToI["retriable_status_codes"]; ok && !isIntfNil(w) {
					ls := make([]uint32, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = uint32(v.(int))
					}
					retryPolicy.RetriableStatusCodes = ls
				}

				if w, ok := retryPolicyMapStrToI["retry_condition"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = v.(string)
					}
					retryPolicy.RetryCondition = ls
				}

				if w, ok := retryPolicyMapStrToI["retry_on"]; ok && !isIntfNil(w) {
					retryPolicy.RetryOn = w.(string)
				}

			}
		}

	}

	//routes
	if v, ok := d.GetOk("routes"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		routesInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		createSpec.Routes = routesInt
		for i, ps := range sl {

			rMapToStrVal := ps.(map[string]interface{})
			routesInt[i] = &ves_io_schema.ObjectRefType{}

			routesInt[i].Kind = "route"

			if v, ok := rMapToStrVal["name"]; ok && !isIntfNil(v) {
				routesInt[i].Name = v.(string)
			}

			if v, ok := rMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				routesInt[i].Namespace = v.(string)
			}

			if v, ok := rMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				routesInt[i].Tenant = v.(string)
			}

			if v, ok := rMapToStrVal["uid"]; ok && !isIntfNil(v) {
				routesInt[i].Uid = v.(string)
			}

		}

	}

	//sensitive_data_policy
	if v, ok := d.GetOk("sensitive_data_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		sensitiveDataPolicyInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		createSpec.SensitiveDataPolicy = sensitiveDataPolicyInt
		for i, ps := range sl {

			sdpMapToStrVal := ps.(map[string]interface{})
			sensitiveDataPolicyInt[i] = &ves_io_schema.ObjectRefType{}

			sensitiveDataPolicyInt[i].Kind = "sensitive_data_policy"

			if v, ok := sdpMapToStrVal["name"]; ok && !isIntfNil(v) {
				sensitiveDataPolicyInt[i].Name = v.(string)
			}

			if v, ok := sdpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				sensitiveDataPolicyInt[i].Namespace = v.(string)
			}

			if v, ok := sdpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				sensitiveDataPolicyInt[i].Tenant = v.(string)
			}

			if v, ok := sdpMapToStrVal["uid"]; ok && !isIntfNil(v) {
				sensitiveDataPolicyInt[i].Uid = v.(string)
			}

		}

	}

	//server_header_choice

	serverHeaderChoiceTypeFound := false

	if v, ok := d.GetOk("append_server_name"); ok && !serverHeaderChoiceTypeFound {

		serverHeaderChoiceTypeFound = true
		serverHeaderChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_AppendServerName{}

		createSpec.ServerHeaderChoice = serverHeaderChoiceInt

		serverHeaderChoiceInt.AppendServerName = v.(string)

	}

	if v, ok := d.GetOk("default_header"); ok && !serverHeaderChoiceTypeFound {

		serverHeaderChoiceTypeFound = true

		if v.(bool) {
			serverHeaderChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_DefaultHeader{}
			serverHeaderChoiceInt.DefaultHeader = &ves_io_schema.Empty{}
			createSpec.ServerHeaderChoice = serverHeaderChoiceInt
		}

	}

	if v, ok := d.GetOk("pass_through"); ok && !serverHeaderChoiceTypeFound {

		serverHeaderChoiceTypeFound = true

		if v.(bool) {
			serverHeaderChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_PassThrough{}
			serverHeaderChoiceInt.PassThrough = &ves_io_schema.Empty{}
			createSpec.ServerHeaderChoice = serverHeaderChoiceInt
		}

	}

	if v, ok := d.GetOk("server_name"); ok && !serverHeaderChoiceTypeFound {

		serverHeaderChoiceTypeFound = true
		serverHeaderChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_ServerName{}

		createSpec.ServerHeaderChoice = serverHeaderChoiceInt

		serverHeaderChoiceInt.ServerName = v.(string)

	}

	//slow_ddos_mitigation
	if v, ok := d.GetOk("slow_ddos_mitigation"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		slowDdosMitigation := &ves_io_schema_virtual_host.SlowDDoSMitigation{}
		createSpec.SlowDdosMitigation = slowDdosMitigation
		for _, set := range sl {
			if set != nil {
				slowDdosMitigationMapStrToI := set.(map[string]interface{})

				if w, ok := slowDdosMitigationMapStrToI["request_headers_timeout"]; ok && !isIntfNil(w) {
					slowDdosMitigation.RequestHeadersTimeout = uint32(w.(int))
				}

				requestTimeoutChoiceTypeFound := false

				if v, ok := slowDdosMitigationMapStrToI["disable_request_timeout"]; ok && !isIntfNil(v) && !requestTimeoutChoiceTypeFound {

					requestTimeoutChoiceTypeFound = true

					if v.(bool) {
						requestTimeoutChoiceInt := &ves_io_schema_virtual_host.SlowDDoSMitigation_DisableRequestTimeout{}
						requestTimeoutChoiceInt.DisableRequestTimeout = &ves_io_schema.Empty{}
						slowDdosMitigation.RequestTimeoutChoice = requestTimeoutChoiceInt
					}

				}

				if v, ok := slowDdosMitigationMapStrToI["request_timeout"]; ok && !isIntfNil(v) && !requestTimeoutChoiceTypeFound {

					requestTimeoutChoiceTypeFound = true
					requestTimeoutChoiceInt := &ves_io_schema_virtual_host.SlowDDoSMitigation_RequestTimeout{}

					slowDdosMitigation.RequestTimeoutChoice = requestTimeoutChoiceInt

					requestTimeoutChoiceInt.RequestTimeout = uint32(v.(int))

				}

			}
		}

	}

	//strict_sni_host_header_check_choice

	strictSniHostHeaderCheckChoiceTypeFound := false

	if v, ok := d.GetOk("additional_domains"); ok && !strictSniHostHeaderCheckChoiceTypeFound {

		strictSniHostHeaderCheckChoiceTypeFound = true
		strictSniHostHeaderCheckChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_AdditionalDomains{}
		strictSniHostHeaderCheckChoiceInt.AdditionalDomains = &ves_io_schema.DomainNameList{}
		createSpec.StrictSniHostHeaderCheckChoice = strictSniHostHeaderCheckChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["domains"]; ok && !isIntfNil(v) {

					ls := make([]string, len(v.([]interface{})))
					for i, v := range v.([]interface{}) {
						ls[i] = v.(string)
					}
					strictSniHostHeaderCheckChoiceInt.AdditionalDomains.Domains = ls

				}

			}
		}

	}

	if v, ok := d.GetOk("enable_strict_sni_host_header_check"); ok && !strictSniHostHeaderCheckChoiceTypeFound {

		strictSniHostHeaderCheckChoiceTypeFound = true

		if v.(bool) {
			strictSniHostHeaderCheckChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_EnableStrictSniHostHeaderCheck{}
			strictSniHostHeaderCheckChoiceInt.EnableStrictSniHostHeaderCheck = &ves_io_schema.Empty{}
			createSpec.StrictSniHostHeaderCheckChoice = strictSniHostHeaderCheckChoiceInt
		}

	}

	//temporary_user_blocking
	if v, ok := d.GetOk("temporary_user_blocking"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		temporaryUserBlocking := &ves_io_schema_virtual_host.TemporaryUserBlockingType{}
		createSpec.TemporaryUserBlocking = temporaryUserBlocking
		for _, set := range sl {
			if set != nil {
				temporaryUserBlockingMapStrToI := set.(map[string]interface{})

				if w, ok := temporaryUserBlockingMapStrToI["custom_page"]; ok && !isIntfNil(w) {
					temporaryUserBlocking.CustomPage = w.(string)
				}

			}
		}

	}

	//tls_certificates_choice

	tlsCertificatesChoiceTypeFound := false

	if v, ok := d.GetOk("tls_cert_params"); ok && !tlsCertificatesChoiceTypeFound {

		tlsCertificatesChoiceTypeFound = true
		tlsCertificatesChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_TlsCertParams{}
		tlsCertificatesChoiceInt.TlsCertParams = &ves_io_schema.CertificateParamsType{}
		createSpec.TlsCertificatesChoice = tlsCertificatesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["certificates"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					certificatesInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					tlsCertificatesChoiceInt.TlsCertParams.Certificates = certificatesInt
					for i, ps := range sl {

						cMapToStrVal := ps.(map[string]interface{})
						certificatesInt[i] = &ves_io_schema.ObjectRefType{}

						certificatesInt[i].Kind = "certificate"

						if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
							certificatesInt[i].Name = v.(string)
						}

						if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							certificatesInt[i].Namespace = v.(string)
						}

						if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							certificatesInt[i].Tenant = v.(string)
						}

						if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
							certificatesInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := cs["cipher_suites"]; ok && !isIntfNil(v) {

					ls := make([]string, len(v.([]interface{})))
					for i, v := range v.([]interface{}) {
						ls[i] = v.(string)
					}
					tlsCertificatesChoiceInt.TlsCertParams.CipherSuites = ls

				}

				clientCertificateVerifyChoiceTypeFound := false

				if _, ok := cs["client_certificate_optional"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.CertificateParamsType_ClientCertificateOptional{}
					clientCertificateVerifyChoiceInt.ClientCertificateOptional = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsCertParams.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if _, ok := cs["client_certificate_required"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.CertificateParamsType_ClientCertificateRequired{}
					clientCertificateVerifyChoiceInt.ClientCertificateRequired = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsCertParams.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if _, ok := cs["no_client_certificate"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.CertificateParamsType_NoClientCertificate{}
					clientCertificateVerifyChoiceInt.NoClientCertificate = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsCertParams.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if v, ok := cs["crl"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					crlInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					tlsCertificatesChoiceInt.TlsCertParams.Crl = crlInt
					for i, ps := range sl {

						cMapToStrVal := ps.(map[string]interface{})
						crlInt[i] = &ves_io_schema.ObjectRefType{}

						crlInt[i].Kind = "crl"

						if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
							crlInt[i].Name = v.(string)
						}

						if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							crlInt[i].Namespace = v.(string)
						}

						if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							crlInt[i].Tenant = v.(string)
						}

						if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
							crlInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := cs["maximum_protocol_version"]; ok && !isIntfNil(v) {

					tlsCertificatesChoiceInt.TlsCertParams.MaximumProtocolVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

				}

				if v, ok := cs["minimum_protocol_version"]; ok && !isIntfNil(v) {

					tlsCertificatesChoiceInt.TlsCertParams.MinimumProtocolVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

				}

				if v, ok := cs["require_client_certificate"]; ok && !isIntfNil(v) {

					tlsCertificatesChoiceInt.TlsCertParams.RequireClientCertificate = v.(bool)

				}

				if v, ok := cs["validation_params"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					validationParams := &ves_io_schema.TlsValidationParamsType{}
					tlsCertificatesChoiceInt.TlsCertParams.ValidationParams = validationParams
					for _, set := range sl {
						if set != nil {
							validationParamsMapStrToI := set.(map[string]interface{})

							if w, ok := validationParamsMapStrToI["skip_hostname_verification"]; ok && !isIntfNil(w) {
								validationParams.SkipHostnameVerification = w.(bool)
							}

							trustedCaChoiceTypeFound := false

							if v, ok := validationParamsMapStrToI["trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

								trustedCaChoiceTypeFound = true
								trustedCaChoiceInt := &ves_io_schema.TlsValidationParamsType_TrustedCa{}
								trustedCaChoiceInt.TrustedCa = &ves_io_schema.TrustedCAList{}
								validationParams.TrustedCaChoice = trustedCaChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["trusted_ca_list"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											trustedCaListInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											trustedCaChoiceInt.TrustedCa.TrustedCaList = trustedCaListInt
											for i, ps := range sl {

												tclMapToStrVal := ps.(map[string]interface{})
												trustedCaListInt[i] = &ves_io_schema.ObjectRefType{}

												trustedCaListInt[i].Kind = "trusted_ca_list"

												if v, ok := tclMapToStrVal["name"]; ok && !isIntfNil(v) {
													trustedCaListInt[i].Name = v.(string)
												}

												if v, ok := tclMapToStrVal["namespace"]; ok && !isIntfNil(v) {
													trustedCaListInt[i].Namespace = v.(string)
												}

												if v, ok := tclMapToStrVal["tenant"]; ok && !isIntfNil(v) {
													trustedCaListInt[i].Tenant = v.(string)
												}

												if v, ok := tclMapToStrVal["uid"]; ok && !isIntfNil(v) {
													trustedCaListInt[i].Uid = v.(string)
												}

											}

										}

									}
								}

							}

							if v, ok := validationParamsMapStrToI["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

								trustedCaChoiceTypeFound = true
								trustedCaChoiceInt := &ves_io_schema.TlsValidationParamsType_TrustedCaUrl{}

								validationParams.TrustedCaChoice = trustedCaChoiceInt

								trustedCaChoiceInt.TrustedCaUrl = v.(string)

							}

							if w, ok := validationParamsMapStrToI["use_volterra_trusted_ca_url"]; ok && !isIntfNil(w) {
								validationParams.UseVolterraTrustedCaUrl = w.(bool)
							}

							if w, ok := validationParamsMapStrToI["verify_subject_alt_names"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								validationParams.VerifySubjectAltNames = ls
							}

						}
					}

				}

				if v, ok := cs["xfcc_header_elements"]; ok && !isIntfNil(v) {

					xfcc_header_elementsList := []ves_io_schema.XfccElement{}
					for _, j := range v.([]interface{}) {
						xfcc_header_elementsList = append(xfcc_header_elementsList, ves_io_schema.XfccElement(ves_io_schema.XfccElement_value[j.(string)]))
					}
					tlsCertificatesChoiceInt.TlsCertParams.XfccHeaderElements = xfcc_header_elementsList

				}

			}
		}

	}

	if v, ok := d.GetOk("tls_parameters"); ok && !tlsCertificatesChoiceTypeFound {

		tlsCertificatesChoiceTypeFound = true
		tlsCertificatesChoiceInt := &ves_io_schema_virtual_host.CreateSpecType_TlsParameters{}
		tlsCertificatesChoiceInt.TlsParameters = &ves_io_schema.DownstreamTlsParamsType{}
		createSpec.TlsCertificatesChoice = tlsCertificatesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				clientCertificateVerifyChoiceTypeFound := false

				if _, ok := cs["client_certificate_optional"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.DownstreamTlsParamsType_ClientCertificateOptional{}
					clientCertificateVerifyChoiceInt.ClientCertificateOptional = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsParameters.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if _, ok := cs["client_certificate_required"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.DownstreamTlsParamsType_ClientCertificateRequired{}
					clientCertificateVerifyChoiceInt.ClientCertificateRequired = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsParameters.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if _, ok := cs["no_client_certificate"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.DownstreamTlsParamsType_NoClientCertificate{}
					clientCertificateVerifyChoiceInt.NoClientCertificate = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsParameters.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if v, ok := cs["common_params"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					commonParams := &ves_io_schema.TlsParamsType{}
					tlsCertificatesChoiceInt.TlsParameters.CommonParams = commonParams
					for _, set := range sl {
						if set != nil {
							commonParamsMapStrToI := set.(map[string]interface{})

							if w, ok := commonParamsMapStrToI["cipher_suites"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								commonParams.CipherSuites = ls
							}

							if v, ok := commonParamsMapStrToI["maximum_protocol_version"]; ok && !isIntfNil(v) {

								commonParams.MaximumProtocolVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

							}

							if v, ok := commonParamsMapStrToI["minimum_protocol_version"]; ok && !isIntfNil(v) {

								commonParams.MinimumProtocolVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

							}

							if v, ok := commonParamsMapStrToI["tls_certificates"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								tlsCertificates := make([]*ves_io_schema.TlsCertificateType, len(sl))
								commonParams.TlsCertificates = tlsCertificates
								for i, set := range sl {
									if set != nil {
										tlsCertificates[i] = &ves_io_schema.TlsCertificateType{}
										tlsCertificatesMapStrToI := set.(map[string]interface{})

										if w, ok := tlsCertificatesMapStrToI["certificate_url"]; ok && !isIntfNil(w) {
											tlsCertificates[i].CertificateUrl = w.(string)
										}

										if w, ok := tlsCertificatesMapStrToI["description"]; ok && !isIntfNil(w) {
											tlsCertificates[i].Description = w.(string)
										}

										ocspStaplingChoiceTypeFound := false

										if v, ok := tlsCertificatesMapStrToI["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

											ocspStaplingChoiceTypeFound = true
											ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
											ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
											tlsCertificates[i].OcspStaplingChoice = ocspStaplingChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

														hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
														for _, j := range v.([]interface{}) {
															hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
														}
														ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

													}

												}
											}

										}

										if _, ok := tlsCertificatesMapStrToI["disable_ocsp_stapling"]; ok && !ocspStaplingChoiceTypeFound {

											ocspStaplingChoiceTypeFound = true
											ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_DisableOcspStapling{}
											ocspStaplingChoiceInt.DisableOcspStapling = &ves_io_schema.Empty{}
											tlsCertificates[i].OcspStaplingChoice = ocspStaplingChoiceInt

										}

										if _, ok := tlsCertificatesMapStrToI["use_system_defaults"]; ok && !ocspStaplingChoiceTypeFound {

											ocspStaplingChoiceTypeFound = true
											ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_UseSystemDefaults{}
											ocspStaplingChoiceInt.UseSystemDefaults = &ves_io_schema.Empty{}
											tlsCertificates[i].OcspStaplingChoice = ocspStaplingChoiceInt

										}

										if v, ok := tlsCertificatesMapStrToI["private_key"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											privateKey := &ves_io_schema.SecretType{}
											tlsCertificates[i].PrivateKey = privateKey
											for _, set := range sl {
												if set != nil {
													privateKeyMapStrToI := set.(map[string]interface{})

													if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														privateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														privateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														privateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														privateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							if w, ok := commonParamsMapStrToI["trusted_ca_url"]; ok && !isIntfNil(w) {
								commonParams.TrustedCaUrl = w.(string)
							}

							if v, ok := commonParamsMapStrToI["validation_params"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								validationParams := &ves_io_schema.TlsValidationParamsType{}
								commonParams.ValidationParams = validationParams
								for _, set := range sl {
									if set != nil {
										validationParamsMapStrToI := set.(map[string]interface{})

										if w, ok := validationParamsMapStrToI["skip_hostname_verification"]; ok && !isIntfNil(w) {
											validationParams.SkipHostnameVerification = w.(bool)
										}

										trustedCaChoiceTypeFound := false

										if v, ok := validationParamsMapStrToI["trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

											trustedCaChoiceTypeFound = true
											trustedCaChoiceInt := &ves_io_schema.TlsValidationParamsType_TrustedCa{}
											trustedCaChoiceInt.TrustedCa = &ves_io_schema.TrustedCAList{}
											validationParams.TrustedCaChoice = trustedCaChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["trusted_ca_list"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														trustedCaListInt := make([]*ves_io_schema.ObjectRefType, len(sl))
														trustedCaChoiceInt.TrustedCa.TrustedCaList = trustedCaListInt
														for i, ps := range sl {

															tclMapToStrVal := ps.(map[string]interface{})
															trustedCaListInt[i] = &ves_io_schema.ObjectRefType{}

															trustedCaListInt[i].Kind = "trusted_ca_list"

															if v, ok := tclMapToStrVal["name"]; ok && !isIntfNil(v) {
																trustedCaListInt[i].Name = v.(string)
															}

															if v, ok := tclMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																trustedCaListInt[i].Namespace = v.(string)
															}

															if v, ok := tclMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																trustedCaListInt[i].Tenant = v.(string)
															}

															if v, ok := tclMapToStrVal["uid"]; ok && !isIntfNil(v) {
																trustedCaListInt[i].Uid = v.(string)
															}

														}

													}

												}
											}

										}

										if v, ok := validationParamsMapStrToI["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

											trustedCaChoiceTypeFound = true
											trustedCaChoiceInt := &ves_io_schema.TlsValidationParamsType_TrustedCaUrl{}

											validationParams.TrustedCaChoice = trustedCaChoiceInt

											trustedCaChoiceInt.TrustedCaUrl = v.(string)

										}

										if w, ok := validationParamsMapStrToI["use_volterra_trusted_ca_url"]; ok && !isIntfNil(w) {
											validationParams.UseVolterraTrustedCaUrl = w.(bool)
										}

										if w, ok := validationParamsMapStrToI["verify_subject_alt_names"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												ls[i] = v.(string)
											}
											validationParams.VerifySubjectAltNames = ls
										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["crl"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					crlInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					tlsCertificatesChoiceInt.TlsParameters.Crl = crlInt
					for i, ps := range sl {

						cMapToStrVal := ps.(map[string]interface{})
						crlInt[i] = &ves_io_schema.ObjectRefType{}

						crlInt[i].Kind = "crl"

						if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
							crlInt[i].Name = v.(string)
						}

						if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							crlInt[i].Namespace = v.(string)
						}

						if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							crlInt[i].Tenant = v.(string)
						}

						if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
							crlInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := cs["require_client_certificate"]; ok && !isIntfNil(v) {

					tlsCertificatesChoiceInt.TlsParameters.RequireClientCertificate = v.(bool)

				}

				if v, ok := cs["xfcc_header_elements"]; ok && !isIntfNil(v) {

					xfcc_header_elementsList := []ves_io_schema.XfccElement{}
					for _, j := range v.([]interface{}) {
						xfcc_header_elementsList = append(xfcc_header_elementsList, ves_io_schema.XfccElement(ves_io_schema.XfccElement_value[j.(string)]))
					}
					tlsCertificatesChoiceInt.TlsParameters.XfccHeaderElements = xfcc_header_elementsList

				}

			}
		}

	}

	//user_identification
	if v, ok := d.GetOk("user_identification"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		userIdentificationInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		createSpec.UserIdentification = userIdentificationInt
		for i, ps := range sl {

			uiMapToStrVal := ps.(map[string]interface{})
			userIdentificationInt[i] = &ves_io_schema.ObjectRefType{}

			userIdentificationInt[i].Kind = "user_identification"

			if v, ok := uiMapToStrVal["name"]; ok && !isIntfNil(v) {
				userIdentificationInt[i].Name = v.(string)
			}

			if v, ok := uiMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				userIdentificationInt[i].Namespace = v.(string)
			}

			if v, ok := uiMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				userIdentificationInt[i].Tenant = v.(string)
			}

			if v, ok := uiMapToStrVal["uid"]; ok && !isIntfNil(v) {
				userIdentificationInt[i].Uid = v.(string)
			}

		}

	}

	//waf_type
	if v, ok := d.GetOk("waf_type"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		wafType := &ves_io_schema.WafType{}
		createSpec.WafType = wafType
		for _, set := range sl {
			if set != nil {
				wafTypeMapStrToI := set.(map[string]interface{})

				refTypeTypeFound := false

				if v, ok := wafTypeMapStrToI["app_firewall"]; ok && !isIntfNil(v) && !refTypeTypeFound {

					refTypeTypeFound = true
					refTypeInt := &ves_io_schema.WafType_AppFirewall{}
					refTypeInt.AppFirewall = &ves_io_schema.AppFirewallRefType{}
					wafType.RefType = refTypeInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["app_firewall"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								appFirewallInt := make([]*ves_io_schema.ObjectRefType, len(sl))
								refTypeInt.AppFirewall.AppFirewall = appFirewallInt
								for i, ps := range sl {

									afMapToStrVal := ps.(map[string]interface{})
									appFirewallInt[i] = &ves_io_schema.ObjectRefType{}

									appFirewallInt[i].Kind = "app_firewall"

									if v, ok := afMapToStrVal["name"]; ok && !isIntfNil(v) {
										appFirewallInt[i].Name = v.(string)
									}

									if v, ok := afMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										appFirewallInt[i].Namespace = v.(string)
									}

									if v, ok := afMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										appFirewallInt[i].Tenant = v.(string)
									}

									if v, ok := afMapToStrVal["uid"]; ok && !isIntfNil(v) {
										appFirewallInt[i].Uid = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := wafTypeMapStrToI["disable_waf"]; ok && !isIntfNil(v) && !refTypeTypeFound {

					refTypeTypeFound = true

					if v.(bool) {
						refTypeInt := &ves_io_schema.WafType_DisableWaf{}
						refTypeInt.DisableWaf = &ves_io_schema.Empty{}
						wafType.RefType = refTypeInt
					}

				}

				if v, ok := wafTypeMapStrToI["inherit_waf"]; ok && !isIntfNil(v) && !refTypeTypeFound {

					refTypeTypeFound = true

					if v.(bool) {
						refTypeInt := &ves_io_schema.WafType_InheritWaf{}
						refTypeInt.InheritWaf = &ves_io_schema.Empty{}
						wafType.RefType = refTypeInt
					}

				}

			}
		}

	}

	//ztna_proxy_configurations
	if v, ok := d.GetOk("ztna_proxy_configurations"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		ztnaProxyConfigurations := &ves_io_schema_virtual_host.ZtnaProxyConfiguration{}
		createSpec.ZtnaProxyConfigurations = ztnaProxyConfigurations
		for _, set := range sl {
			if set != nil {
				ztnaProxyConfigurationsMapStrToI := set.(map[string]interface{})

				if v, ok := ztnaProxyConfigurationsMapStrToI["ztna_application_config"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ztnaApplicationConfigInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					ztnaProxyConfigurations.ZtnaApplicationConfig = ztnaApplicationConfigInt
					for i, ps := range sl {

						zacMapToStrVal := ps.(map[string]interface{})
						ztnaApplicationConfigInt[i] = &ves_io_schema.ObjectRefType{}

						ztnaApplicationConfigInt[i].Kind = "ztna_application"

						if v, ok := zacMapToStrVal["name"]; ok && !isIntfNil(v) {
							ztnaApplicationConfigInt[i].Name = v.(string)
						}

						if v, ok := zacMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							ztnaApplicationConfigInt[i].Namespace = v.(string)
						}

						if v, ok := zacMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							ztnaApplicationConfigInt[i].Tenant = v.(string)
						}

						if v, ok := zacMapToStrVal["uid"]; ok && !isIntfNil(v) {
							ztnaApplicationConfigInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := ztnaProxyConfigurationsMapStrToI["ztna_policy_config"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ztnaPolicyConfigInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					ztnaProxyConfigurations.ZtnaPolicyConfig = ztnaPolicyConfigInt
					for i, ps := range sl {

						zpcMapToStrVal := ps.(map[string]interface{})
						ztnaPolicyConfigInt[i] = &ves_io_schema.ObjectRefType{}

						ztnaPolicyConfigInt[i].Kind = "ztna"

						if v, ok := zpcMapToStrVal["name"]; ok && !isIntfNil(v) {
							ztnaPolicyConfigInt[i].Name = v.(string)
						}

						if v, ok := zpcMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							ztnaPolicyConfigInt[i].Namespace = v.(string)
						}

						if v, ok := zpcMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							ztnaPolicyConfigInt[i].Tenant = v.(string)
						}

						if v, ok := zpcMapToStrVal["uid"]; ok && !isIntfNil(v) {
							ztnaPolicyConfigInt[i].Uid = v.(string)
						}

					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Creating Volterra VirtualHost object with struct: %+v", createReq)

	createVirtualHostResp, err := client.CreateObject(context.Background(), ves_io_schema_virtual_host.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating VirtualHost: %s", err)
	}
	d.SetId(createVirtualHostResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraVirtualHostRead(d, meta)
}

func resourceVolterraVirtualHostRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_virtual_host.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] VirtualHost %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra VirtualHost %q: %s", d.Id(), err)
	}
	return setVirtualHostFields(client, d, resp)
}

func setVirtualHostFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraVirtualHostUpdate updates VirtualHost resource
func resourceVolterraVirtualHostUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_virtual_host.ReplaceSpecType{}
	updateReq := &ves_io_schema_virtual_host.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("add_location"); ok && !isIntfNil(v) {

		updateSpec.AddLocation =
			v.(bool)

	}

	if v, ok := d.GetOk("advertise_policies"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		advertisePoliciesInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		updateSpec.AdvertisePolicies = advertisePoliciesInt
		for i, ps := range sl {

			apMapToStrVal := ps.(map[string]interface{})
			advertisePoliciesInt[i] = &ves_io_schema.ObjectRefType{}

			advertisePoliciesInt[i].Kind = "advertise_policy"

			if v, ok := apMapToStrVal["name"]; ok && !isIntfNil(v) {
				advertisePoliciesInt[i].Name = v.(string)
			}

			if v, ok := apMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				advertisePoliciesInt[i].Namespace = v.(string)
			}

			if v, ok := apMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				advertisePoliciesInt[i].Tenant = v.(string)
			}

			if v, ok := apMapToStrVal["uid"]; ok && !isIntfNil(v) {
				advertisePoliciesInt[i].Uid = v.(string)
			}

		}

	}

	if v, ok := d.GetOk("api_spec"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		apiSpec := &ves_io_schema_virtual_host.ApiSpec{}
		updateSpec.ApiSpec = apiSpec
		for _, set := range sl {
			if set != nil {
				apiSpecMapStrToI := set.(map[string]interface{})

				if v, ok := apiSpecMapStrToI["api_definition"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					apiDefinitionInt := &ves_io_schema_views.ObjectRefType{}
					apiSpec.ApiDefinition = apiDefinitionInt

					for _, set := range sl {
						if set != nil {
							adMapToStrVal := set.(map[string]interface{})
							if val, ok := adMapToStrVal["name"]; ok && !isIntfNil(v) {
								apiDefinitionInt.Name = val.(string)
							}
							if val, ok := adMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								apiDefinitionInt.Namespace = val.(string)
							}

							if val, ok := adMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								apiDefinitionInt.Tenant = val.(string)
							}
						}
					}

				}

				openApiValidationChoiceTypeFound := false

				if v, ok := apiSpecMapStrToI["disable_open_api_validation"]; ok && !isIntfNil(v) && !openApiValidationChoiceTypeFound {

					openApiValidationChoiceTypeFound = true

					if v.(bool) {
						openApiValidationChoiceInt := &ves_io_schema_virtual_host.ApiSpec_DisableOpenApiValidation{}
						openApiValidationChoiceInt.DisableOpenApiValidation = &ves_io_schema.Empty{}
						apiSpec.OpenApiValidationChoice = openApiValidationChoiceInt
					}

				}

				if v, ok := apiSpecMapStrToI["enable_open_api_validation"]; ok && !isIntfNil(v) && !openApiValidationChoiceTypeFound {

					openApiValidationChoiceTypeFound = true
					openApiValidationChoiceInt := &ves_io_schema_virtual_host.ApiSpec_EnableOpenApiValidation{}
					openApiValidationChoiceInt.EnableOpenApiValidation = &ves_io_schema_virtual_host.OpenApiValidationSettings{}
					apiSpec.OpenApiValidationChoice = openApiValidationChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["allow_only_specified_headers"]; ok && !isIntfNil(v) {

								openApiValidationChoiceInt.EnableOpenApiValidation.AllowOnlySpecifiedHeaders = v.(bool)

							}

							if v, ok := cs["allow_only_specified_query_params"]; ok && !isIntfNil(v) {

								openApiValidationChoiceInt.EnableOpenApiValidation.AllowOnlySpecifiedQueryParams = v.(bool)

							}

							if v, ok := cs["fail_close"]; ok && !isIntfNil(v) {

								openApiValidationChoiceInt.EnableOpenApiValidation.FailClose = v.(bool)

							}

							if v, ok := cs["fail_oversized_body_validation"]; ok && !isIntfNil(v) {

								openApiValidationChoiceInt.EnableOpenApiValidation.FailOversizedBodyValidation = v.(bool)

							}

						}
					}

				}

			}
		}

	}

	authenticationChoiceTypeFound := false

	if v, ok := d.GetOk("authentication"); ok && !authenticationChoiceTypeFound {

		authenticationChoiceTypeFound = true
		authenticationChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_Authentication{}
		authenticationChoiceInt.Authentication = &ves_io_schema_virtual_host.AuthenticationDetails{}
		updateSpec.AuthenticationChoice = authenticationChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["auth_config"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					authConfigInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					authenticationChoiceInt.Authentication.AuthConfig = authConfigInt
					for i, ps := range sl {

						acMapToStrVal := ps.(map[string]interface{})
						authConfigInt[i] = &ves_io_schema.ObjectRefType{}

						authConfigInt[i].Kind = "authentication"

						if v, ok := acMapToStrVal["name"]; ok && !isIntfNil(v) {
							authConfigInt[i].Name = v.(string)
						}

						if v, ok := acMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							authConfigInt[i].Namespace = v.(string)
						}

						if v, ok := acMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							authConfigInt[i].Tenant = v.(string)
						}

						if v, ok := acMapToStrVal["uid"]; ok && !isIntfNil(v) {
							authConfigInt[i].Uid = v.(string)
						}

					}

				}

				cookieParamsChoiceTypeFound := false

				if v, ok := cs["cookie_params"]; ok && !isIntfNil(v) && !cookieParamsChoiceTypeFound {

					cookieParamsChoiceTypeFound = true
					cookieParamsChoiceInt := &ves_io_schema_virtual_host.AuthenticationDetails_CookieParams{}
					cookieParamsChoiceInt.CookieParams = &ves_io_schema_authentication.CookieParams{}
					authenticationChoiceInt.Authentication.CookieParamsChoice = cookieParamsChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["cookie_expiry"]; ok && !isIntfNil(v) {

								cookieParamsChoiceInt.CookieParams.CookieExpiry = uint32(v.(int))

							}

							if v, ok := cs["cookie_refresh_interval"]; ok && !isIntfNil(v) {

								cookieParamsChoiceInt.CookieParams.CookieRefreshInterval = uint32(v.(int))

							}

							secretChoiceTypeFound := false

							if v, ok := cs["auth_hmac"]; ok && !isIntfNil(v) && !secretChoiceTypeFound {

								secretChoiceTypeFound = true
								secretChoiceInt := &ves_io_schema_authentication.CookieParams_AuthHmac{}
								secretChoiceInt.AuthHmac = &ves_io_schema_authentication.HMACKeyPair{}
								cookieParamsChoiceInt.CookieParams.SecretChoice = secretChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["prim_key"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											primKey := &ves_io_schema.SecretType{}
											secretChoiceInt.AuthHmac.PrimKey = primKey
											for _, set := range sl {
												if set != nil {
													primKeyMapStrToI := set.(map[string]interface{})

													if v, ok := primKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														primKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := primKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														primKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := primKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														primKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := primKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														primKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := primKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														primKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := primKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														primKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

										if v, ok := cs["prim_key_expiry"]; ok && !isIntfNil(v) {

											ts, err := parseTime(v.(string))
											if err != nil {
												return fmt.Errorf("error creating PrimKeyExpiry, timestamp format is wrong: %s", err)
											}
											secretChoiceInt.AuthHmac.PrimKeyExpiry = ts
										}

										if v, ok := cs["sec_key"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											secKey := &ves_io_schema.SecretType{}
											secretChoiceInt.AuthHmac.SecKey = secKey
											for _, set := range sl {
												if set != nil {
													secKeyMapStrToI := set.(map[string]interface{})

													if v, ok := secKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														secKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := secKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														secKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := secKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														secKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := secKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														secKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := secKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														secKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := secKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														secKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

										if v, ok := cs["sec_key_expiry"]; ok && !isIntfNil(v) {

											ts, err := parseTime(v.(string))
											if err != nil {
												return fmt.Errorf("error creating SecKeyExpiry, timestamp format is wrong: %s", err)
											}
											secretChoiceInt.AuthHmac.SecKeyExpiry = ts
										}

									}
								}

							}

							if v, ok := cs["kms_key_hmac"]; ok && !isIntfNil(v) && !secretChoiceTypeFound {

								secretChoiceTypeFound = true
								secretChoiceInt := &ves_io_schema_authentication.CookieParams_KmsKeyHmac{}
								secretChoiceInt.KmsKeyHmac = &ves_io_schema_authentication.KMSKeyRefType{}
								cookieParamsChoiceInt.CookieParams.SecretChoice = secretChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["auth_hmac_kms"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											authHmacKmsInt := &ves_io_schema_views.ObjectRefType{}
											secretChoiceInt.KmsKeyHmac.AuthHmacKms = authHmacKmsInt

											for _, set := range sl {
												if set != nil {
													ahkMapToStrVal := set.(map[string]interface{})
													if val, ok := ahkMapToStrVal["name"]; ok && !isIntfNil(v) {
														authHmacKmsInt.Name = val.(string)
													}
													if val, ok := ahkMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														authHmacKmsInt.Namespace = val.(string)
													}

													if val, ok := ahkMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														authHmacKmsInt.Tenant = val.(string)
													}
												}
											}

										}

									}
								}

							}

							if v, ok := cs["session_expiry"]; ok && !isIntfNil(v) {

								cookieParamsChoiceInt.CookieParams.SessionExpiry = uint32(v.(int))

							}

						}
					}

				}

				if v, ok := cs["use_auth_object_config"]; ok && !isIntfNil(v) && !cookieParamsChoiceTypeFound {

					cookieParamsChoiceTypeFound = true

					if v.(bool) {
						cookieParamsChoiceInt := &ves_io_schema_virtual_host.AuthenticationDetails_UseAuthObjectConfig{}
						cookieParamsChoiceInt.UseAuthObjectConfig = &ves_io_schema.Empty{}
						authenticationChoiceInt.Authentication.CookieParamsChoice = cookieParamsChoiceInt
					}

				}

				redirectUrlChoiceTypeFound := false

				if v, ok := cs["redirect_dynamic"]; ok && !isIntfNil(v) && !redirectUrlChoiceTypeFound {

					redirectUrlChoiceTypeFound = true

					if v.(bool) {
						redirectUrlChoiceInt := &ves_io_schema_virtual_host.AuthenticationDetails_RedirectDynamic{}
						redirectUrlChoiceInt.RedirectDynamic = &ves_io_schema.Empty{}
						authenticationChoiceInt.Authentication.RedirectUrlChoice = redirectUrlChoiceInt
					}

				}

				if v, ok := cs["redirect_url"]; ok && !isIntfNil(v) && !redirectUrlChoiceTypeFound {

					redirectUrlChoiceTypeFound = true
					redirectUrlChoiceInt := &ves_io_schema_virtual_host.AuthenticationDetails_RedirectUrl{}

					authenticationChoiceInt.Authentication.RedirectUrlChoice = redirectUrlChoiceInt

					redirectUrlChoiceInt.RedirectUrl = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("no_authentication"); ok && !authenticationChoiceTypeFound {

		authenticationChoiceTypeFound = true

		if v.(bool) {
			authenticationChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_NoAuthentication{}
			authenticationChoiceInt.NoAuthentication = &ves_io_schema.Empty{}
			updateSpec.AuthenticationChoice = authenticationChoiceInt
		}

	}

	if v, ok := d.GetOk("buffer_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		bufferPolicy := &ves_io_schema.BufferConfigType{}
		updateSpec.BufferPolicy = bufferPolicy
		for _, set := range sl {
			if set != nil {
				bufferPolicyMapStrToI := set.(map[string]interface{})

				if w, ok := bufferPolicyMapStrToI["disabled"]; ok && !isIntfNil(w) {
					bufferPolicy.Disabled = w.(bool)
				}

				if w, ok := bufferPolicyMapStrToI["max_request_bytes"]; ok && !isIntfNil(w) {
					bufferPolicy.MaxRequestBytes = uint32(w.(int))
				}

				if w, ok := bufferPolicyMapStrToI["max_request_time"]; ok && !isIntfNil(w) {
					bufferPolicy.MaxRequestTime = uint32(w.(int))
				}

			}
		}

	}

	challengeTypeTypeFound := false

	if v, ok := d.GetOk("captcha_challenge"); ok && !challengeTypeTypeFound {

		challengeTypeTypeFound = true
		challengeTypeInt := &ves_io_schema_virtual_host.ReplaceSpecType_CaptchaChallenge{}
		challengeTypeInt.CaptchaChallenge = &ves_io_schema_virtual_host.CaptchaChallengeType{}
		updateSpec.ChallengeType = challengeTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["cookie_expiry"]; ok && !isIntfNil(v) {

					challengeTypeInt.CaptchaChallenge.CookieExpiry = uint32(v.(int))

				}

				if v, ok := cs["custom_page"]; ok && !isIntfNil(v) {

					challengeTypeInt.CaptchaChallenge.CustomPage = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("js_challenge"); ok && !challengeTypeTypeFound {

		challengeTypeTypeFound = true
		challengeTypeInt := &ves_io_schema_virtual_host.ReplaceSpecType_JsChallenge{}
		challengeTypeInt.JsChallenge = &ves_io_schema_virtual_host.JavascriptChallengeType{}
		updateSpec.ChallengeType = challengeTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["cookie_expiry"]; ok && !isIntfNil(v) {

					challengeTypeInt.JsChallenge.CookieExpiry = uint32(v.(int))

				}

				if v, ok := cs["custom_page"]; ok && !isIntfNil(v) {

					challengeTypeInt.JsChallenge.CustomPage = v.(string)

				}

				if v, ok := cs["js_script_delay"]; ok && !isIntfNil(v) {

					challengeTypeInt.JsChallenge.JsScriptDelay = uint32(v.(int))

				}

			}
		}

	}

	if v, ok := d.GetOk("no_challenge"); ok && !challengeTypeTypeFound {

		challengeTypeTypeFound = true

		if v.(bool) {
			challengeTypeInt := &ves_io_schema_virtual_host.ReplaceSpecType_NoChallenge{}
			challengeTypeInt.NoChallenge = &ves_io_schema.Empty{}
			updateSpec.ChallengeType = challengeTypeInt
		}

	}

	if v, ok := d.GetOk("coalescing_options"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		coalescingOptions := &ves_io_schema.TLSCoalescingOptions{}
		updateSpec.CoalescingOptions = coalescingOptions
		for _, set := range sl {
			if set != nil {
				coalescingOptionsMapStrToI := set.(map[string]interface{})

				coalescingChoiceTypeFound := false

				if v, ok := coalescingOptionsMapStrToI["default_coalescing"]; ok && !isIntfNil(v) && !coalescingChoiceTypeFound {

					coalescingChoiceTypeFound = true

					if v.(bool) {
						coalescingChoiceInt := &ves_io_schema.TLSCoalescingOptions_DefaultCoalescing{}
						coalescingChoiceInt.DefaultCoalescing = &ves_io_schema.Empty{}
						coalescingOptions.CoalescingChoice = coalescingChoiceInt
					}

				}

				if v, ok := coalescingOptionsMapStrToI["strict_coalescing"]; ok && !isIntfNil(v) && !coalescingChoiceTypeFound {

					coalescingChoiceTypeFound = true

					if v.(bool) {
						coalescingChoiceInt := &ves_io_schema.TLSCoalescingOptions_StrictCoalescing{}
						coalescingChoiceInt.StrictCoalescing = &ves_io_schema.Empty{}
						coalescingOptions.CoalescingChoice = coalescingChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("compression_params"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		compressionParams := &ves_io_schema_virtual_host.CompressionType{}
		updateSpec.CompressionParams = compressionParams
		for _, set := range sl {
			if set != nil {
				compressionParamsMapStrToI := set.(map[string]interface{})

				if w, ok := compressionParamsMapStrToI["content_length"]; ok && !isIntfNil(w) {
					compressionParams.ContentLength = uint32(w.(int))
				}

				if w, ok := compressionParamsMapStrToI["content_type"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = v.(string)
					}
					compressionParams.ContentType = ls
				}

				if w, ok := compressionParamsMapStrToI["disable_on_etag_header"]; ok && !isIntfNil(w) {
					compressionParams.DisableOnEtagHeader = w.(bool)
				}

				if w, ok := compressionParamsMapStrToI["remove_accept_encoding_header"]; ok && !isIntfNil(w) {
					compressionParams.RemoveAcceptEncodingHeader = w.(bool)
				}

			}
		}

	}

	if v, ok := d.GetOk("connection_idle_timeout"); ok && !isIntfNil(v) {

		updateSpec.ConnectionIdleTimeout =
			uint32(v.(int))

	}

	if v, ok := d.GetOk("cookies_to_modify"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		cookiesToModify := make([]*ves_io_schema.CookieManipulationOptionType, len(sl))
		updateSpec.CookiesToModify = cookiesToModify
		for i, set := range sl {
			if set != nil {
				cookiesToModify[i] = &ves_io_schema.CookieManipulationOptionType{}
				cookiesToModifyMapStrToI := set.(map[string]interface{})

				cookieTamperingTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["disable_tampering_protection"]; ok && !isIntfNil(v) && !cookieTamperingTypeFound {

					cookieTamperingTypeFound = true

					if v.(bool) {
						cookieTamperingInt := &ves_io_schema.CookieManipulationOptionType_DisableTamperingProtection{}
						cookieTamperingInt.DisableTamperingProtection = &ves_io_schema.Empty{}
						cookiesToModify[i].CookieTampering = cookieTamperingInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["enable_tampering_protection"]; ok && !isIntfNil(v) && !cookieTamperingTypeFound {

					cookieTamperingTypeFound = true

					if v.(bool) {
						cookieTamperingInt := &ves_io_schema.CookieManipulationOptionType_EnableTamperingProtection{}
						cookieTamperingInt.EnableTamperingProtection = &ves_io_schema.Empty{}
						cookiesToModify[i].CookieTampering = cookieTamperingInt
					}

				}

				httponlyTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["add_httponly"]; ok && !isIntfNil(v) && !httponlyTypeFound {

					httponlyTypeFound = true

					if v.(bool) {
						httponlyInt := &ves_io_schema.CookieManipulationOptionType_AddHttponly{}
						httponlyInt.AddHttponly = &ves_io_schema.Empty{}
						cookiesToModify[i].Httponly = httponlyInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["ignore_httponly"]; ok && !isIntfNil(v) && !httponlyTypeFound {

					httponlyTypeFound = true

					if v.(bool) {
						httponlyInt := &ves_io_schema.CookieManipulationOptionType_IgnoreHttponly{}
						httponlyInt.IgnoreHttponly = &ves_io_schema.Empty{}
						cookiesToModify[i].Httponly = httponlyInt
					}

				}

				maxAgeTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["ignore_max_age"]; ok && !isIntfNil(v) && !maxAgeTypeFound {

					maxAgeTypeFound = true

					if v.(bool) {
						maxAgeInt := &ves_io_schema.CookieManipulationOptionType_IgnoreMaxAge{}
						maxAgeInt.IgnoreMaxAge = &ves_io_schema.Empty{}
						cookiesToModify[i].MaxAge = maxAgeInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["max_age_value"]; ok && !isIntfNil(v) && !maxAgeTypeFound {

					maxAgeTypeFound = true
					maxAgeInt := &ves_io_schema.CookieManipulationOptionType_MaxAgeValue{}

					cookiesToModify[i].MaxAge = maxAgeInt

					maxAgeInt.MaxAgeValue = int32(v.(int))

				}

				if w, ok := cookiesToModifyMapStrToI["name"]; ok && !isIntfNil(w) {
					cookiesToModify[i].Name = w.(string)
				}

				samesiteTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["ignore_samesite"]; ok && !isIntfNil(v) && !samesiteTypeFound {

					samesiteTypeFound = true

					if v.(bool) {
						samesiteInt := &ves_io_schema.CookieManipulationOptionType_IgnoreSamesite{}
						samesiteInt.IgnoreSamesite = &ves_io_schema.Empty{}
						cookiesToModify[i].Samesite = samesiteInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["samesite_lax"]; ok && !isIntfNil(v) && !samesiteTypeFound {

					samesiteTypeFound = true

					if v.(bool) {
						samesiteInt := &ves_io_schema.CookieManipulationOptionType_SamesiteLax{}
						samesiteInt.SamesiteLax = &ves_io_schema.Empty{}
						cookiesToModify[i].Samesite = samesiteInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["samesite_none"]; ok && !isIntfNil(v) && !samesiteTypeFound {

					samesiteTypeFound = true

					if v.(bool) {
						samesiteInt := &ves_io_schema.CookieManipulationOptionType_SamesiteNone{}
						samesiteInt.SamesiteNone = &ves_io_schema.Empty{}
						cookiesToModify[i].Samesite = samesiteInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["samesite_strict"]; ok && !isIntfNil(v) && !samesiteTypeFound {

					samesiteTypeFound = true

					if v.(bool) {
						samesiteInt := &ves_io_schema.CookieManipulationOptionType_SamesiteStrict{}
						samesiteInt.SamesiteStrict = &ves_io_schema.Empty{}
						cookiesToModify[i].Samesite = samesiteInt
					}

				}

				secureTypeFound := false

				if v, ok := cookiesToModifyMapStrToI["add_secure"]; ok && !isIntfNil(v) && !secureTypeFound {

					secureTypeFound = true

					if v.(bool) {
						secureInt := &ves_io_schema.CookieManipulationOptionType_AddSecure{}
						secureInt.AddSecure = &ves_io_schema.Empty{}
						cookiesToModify[i].Secure = secureInt
					}

				}

				if v, ok := cookiesToModifyMapStrToI["ignore_secure"]; ok && !isIntfNil(v) && !secureTypeFound {

					secureTypeFound = true

					if v.(bool) {
						secureInt := &ves_io_schema.CookieManipulationOptionType_IgnoreSecure{}
						secureInt.IgnoreSecure = &ves_io_schema.Empty{}
						cookiesToModify[i].Secure = secureInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("cors_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		corsPolicy := &ves_io_schema.CorsPolicy{}
		updateSpec.CorsPolicy = corsPolicy
		for _, set := range sl {
			if set != nil {
				corsPolicyMapStrToI := set.(map[string]interface{})

				if w, ok := corsPolicyMapStrToI["allow_credentials"]; ok && !isIntfNil(w) {
					corsPolicy.AllowCredentials = w.(bool)
				}

				if w, ok := corsPolicyMapStrToI["allow_headers"]; ok && !isIntfNil(w) {
					corsPolicy.AllowHeaders = w.(string)
				}

				if w, ok := corsPolicyMapStrToI["allow_methods"]; ok && !isIntfNil(w) {
					corsPolicy.AllowMethods = w.(string)
				}

				if w, ok := corsPolicyMapStrToI["allow_origin"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = v.(string)
					}
					corsPolicy.AllowOrigin = ls
				}

				if w, ok := corsPolicyMapStrToI["allow_origin_regex"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = v.(string)
					}
					corsPolicy.AllowOriginRegex = ls
				}

				if w, ok := corsPolicyMapStrToI["disabled"]; ok && !isIntfNil(w) {
					corsPolicy.Disabled = w.(bool)
				}

				if w, ok := corsPolicyMapStrToI["expose_headers"]; ok && !isIntfNil(w) {
					corsPolicy.ExposeHeaders = w.(string)
				}

				if w, ok := corsPolicyMapStrToI["max_age"]; ok && !isIntfNil(w) {
					corsPolicy.MaxAge = w.(string)
				}

				if w, ok := corsPolicyMapStrToI["maximum_age"]; ok && !isIntfNil(w) {
					corsPolicy.MaximumAge = int32(w.(int))
				}

			}
		}

	}

	if v, ok := d.GetOk("csrf_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		csrfPolicy := &ves_io_schema.CsrfPolicy{}
		updateSpec.CsrfPolicy = csrfPolicy
		for _, set := range sl {
			if set != nil {
				csrfPolicyMapStrToI := set.(map[string]interface{})

				allowedDomainsTypeFound := false

				if v, ok := csrfPolicyMapStrToI["all_load_balancer_domains"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

					allowedDomainsTypeFound = true

					if v.(bool) {
						allowedDomainsInt := &ves_io_schema.CsrfPolicy_AllLoadBalancerDomains{}
						allowedDomainsInt.AllLoadBalancerDomains = &ves_io_schema.Empty{}
						csrfPolicy.AllowedDomains = allowedDomainsInt
					}

				}

				if v, ok := csrfPolicyMapStrToI["custom_domain_list"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

					allowedDomainsTypeFound = true
					allowedDomainsInt := &ves_io_schema.CsrfPolicy_CustomDomainList{}
					allowedDomainsInt.CustomDomainList = &ves_io_schema.DomainNameList{}
					csrfPolicy.AllowedDomains = allowedDomainsInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["domains"]; ok && !isIntfNil(v) {

								ls := make([]string, len(v.([]interface{})))
								for i, v := range v.([]interface{}) {
									ls[i] = v.(string)
								}
								allowedDomainsInt.CustomDomainList.Domains = ls

							}

						}
					}

				}

				if v, ok := csrfPolicyMapStrToI["disabled"]; ok && !isIntfNil(v) && !allowedDomainsTypeFound {

					allowedDomainsTypeFound = true

					if v.(bool) {
						allowedDomainsInt := &ves_io_schema.CsrfPolicy_Disabled{}
						allowedDomainsInt.Disabled = &ves_io_schema.Empty{}
						csrfPolicy.AllowedDomains = allowedDomainsInt
					}

				}

			}
		}

	}

	defaultLbChoiceTypeFound := false

	if v, ok := d.GetOk("default_loadbalancer"); ok && !defaultLbChoiceTypeFound {

		defaultLbChoiceTypeFound = true

		if v.(bool) {
			defaultLbChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_DefaultLoadbalancer{}
			defaultLbChoiceInt.DefaultLoadbalancer = &ves_io_schema.Empty{}
			updateSpec.DefaultLbChoice = defaultLbChoiceInt
		}

	}

	if v, ok := d.GetOk("non_default_loadbalancer"); ok && !defaultLbChoiceTypeFound {

		defaultLbChoiceTypeFound = true

		if v.(bool) {
			defaultLbChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_NonDefaultLoadbalancer{}
			defaultLbChoiceInt.NonDefaultLoadbalancer = &ves_io_schema.Empty{}
			updateSpec.DefaultLbChoice = defaultLbChoiceInt
		}

	}

	if v, ok := d.GetOk("disable_default_error_pages"); ok && !isIntfNil(v) {

		updateSpec.DisableDefaultErrorPages =
			v.(bool)

	}

	if v, ok := d.GetOk("disable_dns_resolve"); ok && !isIntfNil(v) {

		updateSpec.DisableDnsResolve =
			v.(bool)

	}

	if v, ok := d.GetOk("dns_proxy_configuration"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		dnsProxyConfiguration := &ves_io_schema_virtual_host.DNSProxyConfiguration{}
		updateSpec.DnsProxyConfiguration = dnsProxyConfiguration
		for _, set := range sl {
			if set != nil {
				dnsProxyConfigurationMapStrToI := set.(map[string]interface{})

				if v, ok := dnsProxyConfigurationMapStrToI["cache_profile"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					cacheProfile := &ves_io_schema_virtual_host.DNSCacheProfile{}
					dnsProxyConfiguration.CacheProfile = cacheProfile
					for _, set := range sl {
						if set != nil {
							cacheProfileMapStrToI := set.(map[string]interface{})

							cacheProfileChoiceTypeFound := false

							if v, ok := cacheProfileMapStrToI["cache_size"]; ok && !isIntfNil(v) && !cacheProfileChoiceTypeFound {

								cacheProfileChoiceTypeFound = true
								cacheProfileChoiceInt := &ves_io_schema_virtual_host.DNSCacheProfile_CacheSize{}

								cacheProfile.CacheProfileChoice = cacheProfileChoiceInt

								cacheProfileChoiceInt.CacheSize = uint32(v.(int))

							}

							if v, ok := cacheProfileMapStrToI["disable_cache_profile"]; ok && !isIntfNil(v) && !cacheProfileChoiceTypeFound {

								cacheProfileChoiceTypeFound = true

								if v.(bool) {
									cacheProfileChoiceInt := &ves_io_schema_virtual_host.DNSCacheProfile_DisableCacheProfile{}
									cacheProfileChoiceInt.DisableCacheProfile = &ves_io_schema.Empty{}
									cacheProfile.CacheProfileChoice = cacheProfileChoiceInt
								}

							}

						}
					}

				}

				if v, ok := dnsProxyConfigurationMapStrToI["ddos_profile"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ddosProfile := &ves_io_schema_virtual_host.DNSDDoSProfile{}
					dnsProxyConfiguration.DdosProfile = ddosProfile
					for _, set := range sl {
						if set != nil {
							ddosProfileMapStrToI := set.(map[string]interface{})

							ddosMitigationChoiceTypeFound := false

							if v, ok := ddosProfileMapStrToI["disable_ddos_mitigation"]; ok && !isIntfNil(v) && !ddosMitigationChoiceTypeFound {

								ddosMitigationChoiceTypeFound = true

								if v.(bool) {
									ddosMitigationChoiceInt := &ves_io_schema_virtual_host.DNSDDoSProfile_DisableDdosMitigation{}
									ddosMitigationChoiceInt.DisableDdosMitigation = &ves_io_schema.Empty{}
									ddosProfile.DdosMitigationChoice = ddosMitigationChoiceInt
								}

							}

							if v, ok := ddosProfileMapStrToI["enable_ddos_mitigation"]; ok && !isIntfNil(v) && !ddosMitigationChoiceTypeFound {

								ddosMitigationChoiceTypeFound = true

								if v.(bool) {
									ddosMitigationChoiceInt := &ves_io_schema_virtual_host.DNSDDoSProfile_EnableDdosMitigation{}
									ddosMitigationChoiceInt.EnableDdosMitigation = &ves_io_schema.Empty{}
									ddosProfile.DdosMitigationChoice = ddosMitigationChoiceInt
								}

							}

						}
					}

				}

				if v, ok := dnsProxyConfigurationMapStrToI["irules"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					irulesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
					dnsProxyConfiguration.Irules = irulesInt
					for i, ps := range sl {

						iMapToStrVal := ps.(map[string]interface{})
						irulesInt[i] = &ves_io_schema_views.ObjectRefType{}

						if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
							irulesInt[i].Name = v.(string)
						}

						if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							irulesInt[i].Namespace = v.(string)
						}

						if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							irulesInt[i].Tenant = v.(string)
						}

					}

				}

				if v, ok := dnsProxyConfigurationMapStrToI["protocol_inspection"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					protocolInspectionInt := &ves_io_schema_views.ObjectRefType{}
					dnsProxyConfiguration.ProtocolInspection = protocolInspectionInt

					for _, set := range sl {
						if set != nil {
							piMapToStrVal := set.(map[string]interface{})
							if val, ok := piMapToStrVal["name"]; ok && !isIntfNil(v) {
								protocolInspectionInt.Name = val.(string)
							}
							if val, ok := piMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								protocolInspectionInt.Namespace = val.(string)
							}

							if val, ok := piMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								protocolInspectionInt.Tenant = val.(string)
							}
						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("domain_cert_map"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		domainCertMap := make(map[string]*ves_io_schema_virtual_host.DomainCertificates)
		updateSpec.DomainCertMap = domainCertMap
		for _, set := range sl {
			if set != nil {
				domainCertMapMapStrToI := set.(map[string]interface{})
				key, ok := domainCertMapMapStrToI["name"]
				if ok && !isIntfNil(key) {
					domainCertMap[key.(string)] = &ves_io_schema_virtual_host.DomainCertificates{}
					val, _ := domainCertMapMapStrToI["value"]

					domainCertMapVals := val.([]interface{})
					for _, intVal := range domainCertMapVals {
						if intVal != nil {

							domainCertMapStaticMap := intVal.(map[string]interface{})

							if w, ok := domainCertMapStaticMap["ecdsa_certificates"]; ok && !isIntfNil(w) {
								domainCertMap[key.(string)].EcdsaCertificates = w.([]*ves_io_schema.ObjectRefType)
							}

							if w, ok := domainCertMapStaticMap["rsa_certificates"]; ok && !isIntfNil(w) {
								domainCertMap[key.(string)].RsaCertificates = w.([]*ves_io_schema.ObjectRefType)
							}

							// break after one loop
							break
						}
					}
				}
			}
		}

	}

	if v, ok := d.GetOk("domains"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		updateSpec.Domains = ls

	}

	if v, ok := d.GetOk("dynamic_reverse_proxy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		dynamicReverseProxy := &ves_io_schema_virtual_host.DynamicReverseProxyType{}
		updateSpec.DynamicReverseProxy = dynamicReverseProxy
		for _, set := range sl {
			if set != nil {
				dynamicReverseProxyMapStrToI := set.(map[string]interface{})

				if w, ok := dynamicReverseProxyMapStrToI["connection_timeout"]; ok && !isIntfNil(w) {
					dynamicReverseProxy.ConnectionTimeout = uint32(w.(int))
				}

				if v, ok := dynamicReverseProxyMapStrToI["resolution_network"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					resolutionNetworkInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					dynamicReverseProxy.ResolutionNetwork = resolutionNetworkInt
					for i, ps := range sl {

						rnMapToStrVal := ps.(map[string]interface{})
						resolutionNetworkInt[i] = &ves_io_schema.ObjectRefType{}

						resolutionNetworkInt[i].Kind = "virtual_network"

						if v, ok := rnMapToStrVal["name"]; ok && !isIntfNil(v) {
							resolutionNetworkInt[i].Name = v.(string)
						}

						if v, ok := rnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							resolutionNetworkInt[i].Namespace = v.(string)
						}

						if v, ok := rnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							resolutionNetworkInt[i].Tenant = v.(string)
						}

						if v, ok := rnMapToStrVal["uid"]; ok && !isIntfNil(v) {
							resolutionNetworkInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := dynamicReverseProxyMapStrToI["resolution_network_type"]; ok && !isIntfNil(v) {

					dynamicReverseProxy.ResolutionNetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

				}

				if w, ok := dynamicReverseProxyMapStrToI["resolve_endpoint_dynamically"]; ok && !isIntfNil(w) {
					dynamicReverseProxy.ResolveEndpointDynamically = w.(bool)
				}

			}
		}

	}

	if v, ok := d.GetOk("header_transformation_type"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		headerTransformationType := &ves_io_schema.HeaderTransformationType{}
		updateSpec.HeaderTransformationType = headerTransformationType
		for _, set := range sl {
			if set != nil {
				headerTransformationTypeMapStrToI := set.(map[string]interface{})

				headerTransformationChoiceTypeFound := false

				if v, ok := headerTransformationTypeMapStrToI["default_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

					headerTransformationChoiceTypeFound = true

					if v.(bool) {
						headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_DefaultHeaderTransformation{}
						headerTransformationChoiceInt.DefaultHeaderTransformation = &ves_io_schema.Empty{}
						headerTransformationType.HeaderTransformationChoice = headerTransformationChoiceInt
					}

				}

				if v, ok := headerTransformationTypeMapStrToI["legacy_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

					headerTransformationChoiceTypeFound = true

					if v.(bool) {
						headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_LegacyHeaderTransformation{}
						headerTransformationChoiceInt.LegacyHeaderTransformation = &ves_io_schema.Empty{}
						headerTransformationType.HeaderTransformationChoice = headerTransformationChoiceInt
					}

				}

				if v, ok := headerTransformationTypeMapStrToI["preserve_case_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

					headerTransformationChoiceTypeFound = true

					if v.(bool) {
						headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_PreserveCaseHeaderTransformation{}
						headerTransformationChoiceInt.PreserveCaseHeaderTransformation = &ves_io_schema.Empty{}
						headerTransformationType.HeaderTransformationChoice = headerTransformationChoiceInt
					}

				}

				if v, ok := headerTransformationTypeMapStrToI["proper_case_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

					headerTransformationChoiceTypeFound = true

					if v.(bool) {
						headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_ProperCaseHeaderTransformation{}
						headerTransformationChoiceInt.ProperCaseHeaderTransformation = &ves_io_schema.Empty{}
						headerTransformationType.HeaderTransformationChoice = headerTransformationChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("http_protocol_options"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		httpProtocolOptions := &ves_io_schema_virtual_host.HttpProtocolOptions{}
		updateSpec.HttpProtocolOptions = httpProtocolOptions
		for _, set := range sl {
			if set != nil {
				httpProtocolOptionsMapStrToI := set.(map[string]interface{})

				httpProtocolChoiceTypeFound := false

				if v, ok := httpProtocolOptionsMapStrToI["http_protocol_enable_v1_only"]; ok && !isIntfNil(v) && !httpProtocolChoiceTypeFound {

					httpProtocolChoiceTypeFound = true
					httpProtocolChoiceInt := &ves_io_schema_virtual_host.HttpProtocolOptions_HttpProtocolEnableV1Only{}
					httpProtocolChoiceInt.HttpProtocolEnableV1Only = &ves_io_schema_virtual_host.Http1ProtocolOptions{}
					httpProtocolOptions.HttpProtocolChoice = httpProtocolChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["header_transformation"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								headerTransformation := &ves_io_schema.HeaderTransformationType{}
								httpProtocolChoiceInt.HttpProtocolEnableV1Only.HeaderTransformation = headerTransformation
								for _, set := range sl {
									if set != nil {
										headerTransformationMapStrToI := set.(map[string]interface{})

										headerTransformationChoiceTypeFound := false

										if v, ok := headerTransformationMapStrToI["default_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

											headerTransformationChoiceTypeFound = true

											if v.(bool) {
												headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_DefaultHeaderTransformation{}
												headerTransformationChoiceInt.DefaultHeaderTransformation = &ves_io_schema.Empty{}
												headerTransformation.HeaderTransformationChoice = headerTransformationChoiceInt
											}

										}

										if v, ok := headerTransformationMapStrToI["legacy_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

											headerTransformationChoiceTypeFound = true

											if v.(bool) {
												headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_LegacyHeaderTransformation{}
												headerTransformationChoiceInt.LegacyHeaderTransformation = &ves_io_schema.Empty{}
												headerTransformation.HeaderTransformationChoice = headerTransformationChoiceInt
											}

										}

										if v, ok := headerTransformationMapStrToI["preserve_case_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

											headerTransformationChoiceTypeFound = true

											if v.(bool) {
												headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_PreserveCaseHeaderTransformation{}
												headerTransformationChoiceInt.PreserveCaseHeaderTransformation = &ves_io_schema.Empty{}
												headerTransformation.HeaderTransformationChoice = headerTransformationChoiceInt
											}

										}

										if v, ok := headerTransformationMapStrToI["proper_case_header_transformation"]; ok && !isIntfNil(v) && !headerTransformationChoiceTypeFound {

											headerTransformationChoiceTypeFound = true

											if v.(bool) {
												headerTransformationChoiceInt := &ves_io_schema.HeaderTransformationType_ProperCaseHeaderTransformation{}
												headerTransformationChoiceInt.ProperCaseHeaderTransformation = &ves_io_schema.Empty{}
												headerTransformation.HeaderTransformationChoice = headerTransformationChoiceInt
											}

										}

									}
								}

							}

						}
					}

				}

				if v, ok := httpProtocolOptionsMapStrToI["http_protocol_enable_v1_v2"]; ok && !isIntfNil(v) && !httpProtocolChoiceTypeFound {

					httpProtocolChoiceTypeFound = true

					if v.(bool) {
						httpProtocolChoiceInt := &ves_io_schema_virtual_host.HttpProtocolOptions_HttpProtocolEnableV1V2{}
						httpProtocolChoiceInt.HttpProtocolEnableV1V2 = &ves_io_schema.Empty{}
						httpProtocolOptions.HttpProtocolChoice = httpProtocolChoiceInt
					}

				}

				if v, ok := httpProtocolOptionsMapStrToI["http_protocol_enable_v2_only"]; ok && !isIntfNil(v) && !httpProtocolChoiceTypeFound {

					httpProtocolChoiceTypeFound = true

					if v.(bool) {
						httpProtocolChoiceInt := &ves_io_schema_virtual_host.HttpProtocolOptions_HttpProtocolEnableV2Only{}
						httpProtocolChoiceInt.HttpProtocolEnableV2Only = &ves_io_schema.Empty{}
						httpProtocolOptions.HttpProtocolChoice = httpProtocolChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("idle_timeout"); ok && !isIntfNil(v) {

		updateSpec.IdleTimeout =
			uint32(v.(int))

	}

	if v, ok := d.GetOk("masking_config"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		maskingConfig := &ves_io_schema_virtual_host.MaskingConfiguration{}
		updateSpec.MaskingConfig = maskingConfig
		for _, set := range sl {
			if set != nil {
				maskingConfigMapStrToI := set.(map[string]interface{})

				maskingChoiceTypeFound := false

				if v, ok := maskingConfigMapStrToI["disable_masking"]; ok && !isIntfNil(v) && !maskingChoiceTypeFound {

					maskingChoiceTypeFound = true

					if v.(bool) {
						maskingChoiceInt := &ves_io_schema_virtual_host.MaskingConfiguration_DisableMasking{}
						maskingChoiceInt.DisableMasking = &ves_io_schema.Empty{}
						maskingConfig.MaskingChoice = maskingChoiceInt
					}

				}

				if v, ok := maskingConfigMapStrToI["enable_masking"]; ok && !isIntfNil(v) && !maskingChoiceTypeFound {

					maskingChoiceTypeFound = true

					if v.(bool) {
						maskingChoiceInt := &ves_io_schema_virtual_host.MaskingConfiguration_EnableMasking{}
						maskingChoiceInt.EnableMasking = &ves_io_schema.Empty{}
						maskingConfig.MaskingChoice = maskingChoiceInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("max_direct_response_body_size"); ok && !isIntfNil(v) {

		updateSpec.MaxDirectResponseBodySize =
			uint32(v.(int))

	}

	if v, ok := d.GetOk("max_request_header_size"); ok && !isIntfNil(v) {

		updateSpec.MaxRequestHeaderSize =
			uint32(v.(int))

	}

	pathNormalizeChoiceTypeFound := false

	if v, ok := d.GetOk("disable_path_normalize"); ok && !pathNormalizeChoiceTypeFound {

		pathNormalizeChoiceTypeFound = true

		if v.(bool) {
			pathNormalizeChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_DisablePathNormalize{}
			pathNormalizeChoiceInt.DisablePathNormalize = &ves_io_schema.Empty{}
			updateSpec.PathNormalizeChoice = pathNormalizeChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_path_normalize"); ok && !pathNormalizeChoiceTypeFound {

		pathNormalizeChoiceTypeFound = true

		if v.(bool) {
			pathNormalizeChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_EnablePathNormalize{}
			pathNormalizeChoiceInt.EnablePathNormalize = &ves_io_schema.Empty{}
			updateSpec.PathNormalizeChoice = pathNormalizeChoiceInt
		}

	}

	if v, ok := d.GetOk("proxy"); ok && !isIntfNil(v) {

		updateSpec.Proxy = ves_io_schema_virtual_host.ProxyType(ves_io_schema_virtual_host.ProxyType_value[v.(string)])

	}

	if v, ok := d.GetOk("rate_limiter_allowed_prefixes"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		rateLimiterAllowedPrefixesInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		updateSpec.RateLimiterAllowedPrefixes = rateLimiterAllowedPrefixesInt
		for i, ps := range sl {

			rlapMapToStrVal := ps.(map[string]interface{})
			rateLimiterAllowedPrefixesInt[i] = &ves_io_schema.ObjectRefType{}

			rateLimiterAllowedPrefixesInt[i].Kind = "ip_prefix_set"

			if v, ok := rlapMapToStrVal["name"]; ok && !isIntfNil(v) {
				rateLimiterAllowedPrefixesInt[i].Name = v.(string)
			}

			if v, ok := rlapMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				rateLimiterAllowedPrefixesInt[i].Namespace = v.(string)
			}

			if v, ok := rlapMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				rateLimiterAllowedPrefixesInt[i].Tenant = v.(string)
			}

			if v, ok := rlapMapToStrVal["uid"]; ok && !isIntfNil(v) {
				rateLimiterAllowedPrefixesInt[i].Uid = v.(string)
			}

		}

	}

	if v, ok := d.GetOk("request_headers_to_add"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		requestHeadersToAdd := make([]*ves_io_schema.HeaderManipulationOptionType, len(sl))
		updateSpec.RequestHeadersToAdd = requestHeadersToAdd
		for i, set := range sl {
			if set != nil {
				requestHeadersToAdd[i] = &ves_io_schema.HeaderManipulationOptionType{}
				requestHeadersToAddMapStrToI := set.(map[string]interface{})

				if w, ok := requestHeadersToAddMapStrToI["append"]; ok && !isIntfNil(w) {
					requestHeadersToAdd[i].Append = w.(bool)
				}

				if w, ok := requestHeadersToAddMapStrToI["name"]; ok && !isIntfNil(w) {
					requestHeadersToAdd[i].Name = w.(string)
				}

				valueChoiceTypeFound := false

				if v, ok := requestHeadersToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

					valueChoiceTypeFound = true
					valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_SecretValue{}
					valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
					requestHeadersToAdd[i].ValueChoice = valueChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

								valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := requestHeadersToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

					valueChoiceTypeFound = true
					valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_Value{}

					requestHeadersToAdd[i].ValueChoice = valueChoiceInt

					valueChoiceInt.Value = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("request_headers_to_remove"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		updateSpec.RequestHeadersToRemove = ls

	}

	if v, ok := d.GetOk("response_headers_to_add"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		responseHeadersToAdd := make([]*ves_io_schema.HeaderManipulationOptionType, len(sl))
		updateSpec.ResponseHeadersToAdd = responseHeadersToAdd
		for i, set := range sl {
			if set != nil {
				responseHeadersToAdd[i] = &ves_io_schema.HeaderManipulationOptionType{}
				responseHeadersToAddMapStrToI := set.(map[string]interface{})

				if w, ok := responseHeadersToAddMapStrToI["append"]; ok && !isIntfNil(w) {
					responseHeadersToAdd[i].Append = w.(bool)
				}

				if w, ok := responseHeadersToAddMapStrToI["name"]; ok && !isIntfNil(w) {
					responseHeadersToAdd[i].Name = w.(string)
				}

				valueChoiceTypeFound := false

				if v, ok := responseHeadersToAddMapStrToI["secret_value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

					valueChoiceTypeFound = true
					valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_SecretValue{}
					valueChoiceInt.SecretValue = &ves_io_schema.SecretType{}
					responseHeadersToAdd[i].ValueChoice = valueChoiceInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
								valueChoiceInt.SecretValue.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
								for _, set := range sl {
									if set != nil {
										blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

										if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.Location = w.(string)
										}

										if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
											blindfoldSecretInfoInternal.StoreProvider = w.(string)
										}

									}
								}

							}

							if v, ok := cs["secret_encoding_type"]; ok && !isIntfNil(v) {

								valueChoiceInt.SecretValue.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

							}

							secretInfoOneofTypeFound := false

							if v, ok := cs["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
								secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

										}

										if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

										}

									}
								}

							}

							if v, ok := cs["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
								secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["url"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

										}

									}
								}

							}

							if v, ok := cs["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
								secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["key"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

										}

										if v, ok := cs["location"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

										}

										if v, ok := cs["provider"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

										}

										if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

										}

										if v, ok := cs["version"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := cs["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

								secretInfoOneofTypeFound = true
								secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
								secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
								valueChoiceInt.SecretValue.SecretInfoOneof = secretInfoOneofInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["name"]; ok && !isIntfNil(v) {

											secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

										}

									}
								}

							}

						}
					}

				}

				if v, ok := responseHeadersToAddMapStrToI["value"]; ok && !isIntfNil(v) && !valueChoiceTypeFound {

					valueChoiceTypeFound = true
					valueChoiceInt := &ves_io_schema.HeaderManipulationOptionType_Value{}

					responseHeadersToAdd[i].ValueChoice = valueChoiceInt

					valueChoiceInt.Value = v.(string)

				}

			}
		}

	}

	if v, ok := d.GetOk("response_headers_to_remove"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		updateSpec.ResponseHeadersToRemove = ls

	}

	if v, ok := d.GetOk("retry_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		retryPolicy := &ves_io_schema.RetryPolicyType{}
		updateSpec.RetryPolicy = retryPolicy
		for _, set := range sl {
			if set != nil {
				retryPolicyMapStrToI := set.(map[string]interface{})

				if v, ok := retryPolicyMapStrToI["back_off"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					backOff := &ves_io_schema.RetryBackOff{}
					retryPolicy.BackOff = backOff
					for _, set := range sl {
						if set != nil {
							backOffMapStrToI := set.(map[string]interface{})

							if w, ok := backOffMapStrToI["base_interval"]; ok && !isIntfNil(w) {
								backOff.BaseInterval = uint32(w.(int))
							}

							if w, ok := backOffMapStrToI["max_interval"]; ok && !isIntfNil(w) {
								backOff.MaxInterval = uint32(w.(int))
							}

						}
					}

				}

				if w, ok := retryPolicyMapStrToI["num_retries"]; ok && !isIntfNil(w) {
					retryPolicy.NumRetries = uint32(w.(int))
				}

				if w, ok := retryPolicyMapStrToI["per_try_timeout"]; ok && !isIntfNil(w) {
					retryPolicy.PerTryTimeout = uint32(w.(int))
				}

				if w, ok := retryPolicyMapStrToI["retriable_status_codes"]; ok && !isIntfNil(w) {
					ls := make([]uint32, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = uint32(v.(int))
					}
					retryPolicy.RetriableStatusCodes = ls
				}

				if w, ok := retryPolicyMapStrToI["retry_condition"]; ok && !isIntfNil(w) {
					ls := make([]string, len(w.([]interface{})))
					for i, v := range w.([]interface{}) {
						ls[i] = v.(string)
					}
					retryPolicy.RetryCondition = ls
				}

				if w, ok := retryPolicyMapStrToI["retry_on"]; ok && !isIntfNil(w) {
					retryPolicy.RetryOn = w.(string)
				}

			}
		}

	}

	if v, ok := d.GetOk("routes"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		routesInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		updateSpec.Routes = routesInt
		for i, ps := range sl {

			rMapToStrVal := ps.(map[string]interface{})
			routesInt[i] = &ves_io_schema.ObjectRefType{}

			routesInt[i].Kind = "route"

			if v, ok := rMapToStrVal["name"]; ok && !isIntfNil(v) {
				routesInt[i].Name = v.(string)
			}

			if v, ok := rMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				routesInt[i].Namespace = v.(string)
			}

			if v, ok := rMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				routesInt[i].Tenant = v.(string)
			}

			if v, ok := rMapToStrVal["uid"]; ok && !isIntfNil(v) {
				routesInt[i].Uid = v.(string)
			}

		}

	}

	if v, ok := d.GetOk("sensitive_data_policy"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		sensitiveDataPolicyInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		updateSpec.SensitiveDataPolicy = sensitiveDataPolicyInt
		for i, ps := range sl {

			sdpMapToStrVal := ps.(map[string]interface{})
			sensitiveDataPolicyInt[i] = &ves_io_schema.ObjectRefType{}

			sensitiveDataPolicyInt[i].Kind = "sensitive_data_policy"

			if v, ok := sdpMapToStrVal["name"]; ok && !isIntfNil(v) {
				sensitiveDataPolicyInt[i].Name = v.(string)
			}

			if v, ok := sdpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				sensitiveDataPolicyInt[i].Namespace = v.(string)
			}

			if v, ok := sdpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				sensitiveDataPolicyInt[i].Tenant = v.(string)
			}

			if v, ok := sdpMapToStrVal["uid"]; ok && !isIntfNil(v) {
				sensitiveDataPolicyInt[i].Uid = v.(string)
			}

		}

	}

	serverHeaderChoiceTypeFound := false

	if v, ok := d.GetOk("append_server_name"); ok && !serverHeaderChoiceTypeFound {

		serverHeaderChoiceTypeFound = true
		serverHeaderChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_AppendServerName{}

		updateSpec.ServerHeaderChoice = serverHeaderChoiceInt

		serverHeaderChoiceInt.AppendServerName = v.(string)

	}

	if v, ok := d.GetOk("default_header"); ok && !serverHeaderChoiceTypeFound {

		serverHeaderChoiceTypeFound = true

		if v.(bool) {
			serverHeaderChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_DefaultHeader{}
			serverHeaderChoiceInt.DefaultHeader = &ves_io_schema.Empty{}
			updateSpec.ServerHeaderChoice = serverHeaderChoiceInt
		}

	}

	if v, ok := d.GetOk("pass_through"); ok && !serverHeaderChoiceTypeFound {

		serverHeaderChoiceTypeFound = true

		if v.(bool) {
			serverHeaderChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_PassThrough{}
			serverHeaderChoiceInt.PassThrough = &ves_io_schema.Empty{}
			updateSpec.ServerHeaderChoice = serverHeaderChoiceInt
		}

	}

	if v, ok := d.GetOk("server_name"); ok && !serverHeaderChoiceTypeFound {

		serverHeaderChoiceTypeFound = true
		serverHeaderChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_ServerName{}

		updateSpec.ServerHeaderChoice = serverHeaderChoiceInt

		serverHeaderChoiceInt.ServerName = v.(string)

	}

	if v, ok := d.GetOk("slow_ddos_mitigation"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		slowDdosMitigation := &ves_io_schema_virtual_host.SlowDDoSMitigation{}
		updateSpec.SlowDdosMitigation = slowDdosMitigation
		for _, set := range sl {
			if set != nil {
				slowDdosMitigationMapStrToI := set.(map[string]interface{})

				if w, ok := slowDdosMitigationMapStrToI["request_headers_timeout"]; ok && !isIntfNil(w) {
					slowDdosMitigation.RequestHeadersTimeout = uint32(w.(int))
				}

				requestTimeoutChoiceTypeFound := false

				if v, ok := slowDdosMitigationMapStrToI["disable_request_timeout"]; ok && !isIntfNil(v) && !requestTimeoutChoiceTypeFound {

					requestTimeoutChoiceTypeFound = true

					if v.(bool) {
						requestTimeoutChoiceInt := &ves_io_schema_virtual_host.SlowDDoSMitigation_DisableRequestTimeout{}
						requestTimeoutChoiceInt.DisableRequestTimeout = &ves_io_schema.Empty{}
						slowDdosMitigation.RequestTimeoutChoice = requestTimeoutChoiceInt
					}

				}

				if v, ok := slowDdosMitigationMapStrToI["request_timeout"]; ok && !isIntfNil(v) && !requestTimeoutChoiceTypeFound {

					requestTimeoutChoiceTypeFound = true
					requestTimeoutChoiceInt := &ves_io_schema_virtual_host.SlowDDoSMitigation_RequestTimeout{}

					slowDdosMitigation.RequestTimeoutChoice = requestTimeoutChoiceInt

					requestTimeoutChoiceInt.RequestTimeout = uint32(v.(int))

				}

			}
		}

	}

	strictSniHostHeaderCheckChoiceTypeFound := false

	if v, ok := d.GetOk("additional_domains"); ok && !strictSniHostHeaderCheckChoiceTypeFound {

		strictSniHostHeaderCheckChoiceTypeFound = true
		strictSniHostHeaderCheckChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_AdditionalDomains{}
		strictSniHostHeaderCheckChoiceInt.AdditionalDomains = &ves_io_schema.DomainNameList{}
		updateSpec.StrictSniHostHeaderCheckChoice = strictSniHostHeaderCheckChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["domains"]; ok && !isIntfNil(v) {

					ls := make([]string, len(v.([]interface{})))
					for i, v := range v.([]interface{}) {
						ls[i] = v.(string)
					}
					strictSniHostHeaderCheckChoiceInt.AdditionalDomains.Domains = ls

				}

			}
		}

	}

	if v, ok := d.GetOk("enable_strict_sni_host_header_check"); ok && !strictSniHostHeaderCheckChoiceTypeFound {

		strictSniHostHeaderCheckChoiceTypeFound = true

		if v.(bool) {
			strictSniHostHeaderCheckChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_EnableStrictSniHostHeaderCheck{}
			strictSniHostHeaderCheckChoiceInt.EnableStrictSniHostHeaderCheck = &ves_io_schema.Empty{}
			updateSpec.StrictSniHostHeaderCheckChoice = strictSniHostHeaderCheckChoiceInt
		}

	}

	if v, ok := d.GetOk("temporary_user_blocking"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		temporaryUserBlocking := &ves_io_schema_virtual_host.TemporaryUserBlockingType{}
		updateSpec.TemporaryUserBlocking = temporaryUserBlocking
		for _, set := range sl {
			if set != nil {
				temporaryUserBlockingMapStrToI := set.(map[string]interface{})

				if w, ok := temporaryUserBlockingMapStrToI["custom_page"]; ok && !isIntfNil(w) {
					temporaryUserBlocking.CustomPage = w.(string)
				}

			}
		}

	}

	tlsCertificatesChoiceTypeFound := false

	if v, ok := d.GetOk("tls_cert_params"); ok && !tlsCertificatesChoiceTypeFound {

		tlsCertificatesChoiceTypeFound = true
		tlsCertificatesChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_TlsCertParams{}
		tlsCertificatesChoiceInt.TlsCertParams = &ves_io_schema.CertificateParamsType{}
		updateSpec.TlsCertificatesChoice = tlsCertificatesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["certificates"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					certificatesInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					tlsCertificatesChoiceInt.TlsCertParams.Certificates = certificatesInt
					for i, ps := range sl {

						cMapToStrVal := ps.(map[string]interface{})
						certificatesInt[i] = &ves_io_schema.ObjectRefType{}

						certificatesInt[i].Kind = "certificate"

						if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
							certificatesInt[i].Name = v.(string)
						}

						if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							certificatesInt[i].Namespace = v.(string)
						}

						if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							certificatesInt[i].Tenant = v.(string)
						}

						if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
							certificatesInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := cs["cipher_suites"]; ok && !isIntfNil(v) {

					ls := make([]string, len(v.([]interface{})))
					for i, v := range v.([]interface{}) {
						ls[i] = v.(string)
					}
					tlsCertificatesChoiceInt.TlsCertParams.CipherSuites = ls

				}

				clientCertificateVerifyChoiceTypeFound := false

				if _, ok := cs["client_certificate_optional"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.CertificateParamsType_ClientCertificateOptional{}
					clientCertificateVerifyChoiceInt.ClientCertificateOptional = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsCertParams.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if _, ok := cs["client_certificate_required"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.CertificateParamsType_ClientCertificateRequired{}
					clientCertificateVerifyChoiceInt.ClientCertificateRequired = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsCertParams.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if _, ok := cs["no_client_certificate"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.CertificateParamsType_NoClientCertificate{}
					clientCertificateVerifyChoiceInt.NoClientCertificate = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsCertParams.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if v, ok := cs["crl"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					crlInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					tlsCertificatesChoiceInt.TlsCertParams.Crl = crlInt
					for i, ps := range sl {

						cMapToStrVal := ps.(map[string]interface{})
						crlInt[i] = &ves_io_schema.ObjectRefType{}

						crlInt[i].Kind = "crl"

						if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
							crlInt[i].Name = v.(string)
						}

						if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							crlInt[i].Namespace = v.(string)
						}

						if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							crlInt[i].Tenant = v.(string)
						}

						if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
							crlInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := cs["maximum_protocol_version"]; ok && !isIntfNil(v) {

					tlsCertificatesChoiceInt.TlsCertParams.MaximumProtocolVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

				}

				if v, ok := cs["minimum_protocol_version"]; ok && !isIntfNil(v) {

					tlsCertificatesChoiceInt.TlsCertParams.MinimumProtocolVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

				}

				if v, ok := cs["require_client_certificate"]; ok && !isIntfNil(v) {

					tlsCertificatesChoiceInt.TlsCertParams.RequireClientCertificate = v.(bool)

				}

				if v, ok := cs["validation_params"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					validationParams := &ves_io_schema.TlsValidationParamsType{}
					tlsCertificatesChoiceInt.TlsCertParams.ValidationParams = validationParams
					for _, set := range sl {
						if set != nil {
							validationParamsMapStrToI := set.(map[string]interface{})

							if w, ok := validationParamsMapStrToI["skip_hostname_verification"]; ok && !isIntfNil(w) {
								validationParams.SkipHostnameVerification = w.(bool)
							}

							trustedCaChoiceTypeFound := false

							if v, ok := validationParamsMapStrToI["trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

								trustedCaChoiceTypeFound = true
								trustedCaChoiceInt := &ves_io_schema.TlsValidationParamsType_TrustedCa{}
								trustedCaChoiceInt.TrustedCa = &ves_io_schema.TrustedCAList{}
								validationParams.TrustedCaChoice = trustedCaChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["trusted_ca_list"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											trustedCaListInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											trustedCaChoiceInt.TrustedCa.TrustedCaList = trustedCaListInt
											for i, ps := range sl {

												tclMapToStrVal := ps.(map[string]interface{})
												trustedCaListInt[i] = &ves_io_schema.ObjectRefType{}

												trustedCaListInt[i].Kind = "trusted_ca_list"

												if v, ok := tclMapToStrVal["name"]; ok && !isIntfNil(v) {
													trustedCaListInt[i].Name = v.(string)
												}

												if v, ok := tclMapToStrVal["namespace"]; ok && !isIntfNil(v) {
													trustedCaListInt[i].Namespace = v.(string)
												}

												if v, ok := tclMapToStrVal["tenant"]; ok && !isIntfNil(v) {
													trustedCaListInt[i].Tenant = v.(string)
												}

												if v, ok := tclMapToStrVal["uid"]; ok && !isIntfNil(v) {
													trustedCaListInt[i].Uid = v.(string)
												}

											}

										}

									}
								}

							}

							if v, ok := validationParamsMapStrToI["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

								trustedCaChoiceTypeFound = true
								trustedCaChoiceInt := &ves_io_schema.TlsValidationParamsType_TrustedCaUrl{}

								validationParams.TrustedCaChoice = trustedCaChoiceInt

								trustedCaChoiceInt.TrustedCaUrl = v.(string)

							}

							if w, ok := validationParamsMapStrToI["use_volterra_trusted_ca_url"]; ok && !isIntfNil(w) {
								validationParams.UseVolterraTrustedCaUrl = w.(bool)
							}

							if w, ok := validationParamsMapStrToI["verify_subject_alt_names"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								validationParams.VerifySubjectAltNames = ls
							}

						}
					}

				}

				if v, ok := cs["xfcc_header_elements"]; ok && !isIntfNil(v) {

					xfcc_header_elementsList := []ves_io_schema.XfccElement{}
					for _, j := range v.([]interface{}) {
						xfcc_header_elementsList = append(xfcc_header_elementsList, ves_io_schema.XfccElement(ves_io_schema.XfccElement_value[j.(string)]))
					}
					tlsCertificatesChoiceInt.TlsCertParams.XfccHeaderElements = xfcc_header_elementsList

				}

			}
		}

	}

	if v, ok := d.GetOk("tls_parameters"); ok && !tlsCertificatesChoiceTypeFound {

		tlsCertificatesChoiceTypeFound = true
		tlsCertificatesChoiceInt := &ves_io_schema_virtual_host.ReplaceSpecType_TlsParameters{}
		tlsCertificatesChoiceInt.TlsParameters = &ves_io_schema.DownstreamTlsParamsType{}
		updateSpec.TlsCertificatesChoice = tlsCertificatesChoiceInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				clientCertificateVerifyChoiceTypeFound := false

				if _, ok := cs["client_certificate_optional"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.DownstreamTlsParamsType_ClientCertificateOptional{}
					clientCertificateVerifyChoiceInt.ClientCertificateOptional = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsParameters.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if _, ok := cs["client_certificate_required"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.DownstreamTlsParamsType_ClientCertificateRequired{}
					clientCertificateVerifyChoiceInt.ClientCertificateRequired = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsParameters.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if _, ok := cs["no_client_certificate"]; ok && !clientCertificateVerifyChoiceTypeFound {

					clientCertificateVerifyChoiceTypeFound = true
					clientCertificateVerifyChoiceInt := &ves_io_schema.DownstreamTlsParamsType_NoClientCertificate{}
					clientCertificateVerifyChoiceInt.NoClientCertificate = &ves_io_schema.Empty{}
					tlsCertificatesChoiceInt.TlsParameters.ClientCertificateVerifyChoice = clientCertificateVerifyChoiceInt

				}

				if v, ok := cs["common_params"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					commonParams := &ves_io_schema.TlsParamsType{}
					tlsCertificatesChoiceInt.TlsParameters.CommonParams = commonParams
					for _, set := range sl {
						if set != nil {
							commonParamsMapStrToI := set.(map[string]interface{})

							if w, ok := commonParamsMapStrToI["cipher_suites"]; ok && !isIntfNil(w) {
								ls := make([]string, len(w.([]interface{})))
								for i, v := range w.([]interface{}) {
									ls[i] = v.(string)
								}
								commonParams.CipherSuites = ls
							}

							if v, ok := commonParamsMapStrToI["maximum_protocol_version"]; ok && !isIntfNil(v) {

								commonParams.MaximumProtocolVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

							}

							if v, ok := commonParamsMapStrToI["minimum_protocol_version"]; ok && !isIntfNil(v) {

								commonParams.MinimumProtocolVersion = ves_io_schema.TlsProtocol(ves_io_schema.TlsProtocol_value[v.(string)])

							}

							if v, ok := commonParamsMapStrToI["tls_certificates"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								tlsCertificates := make([]*ves_io_schema.TlsCertificateType, len(sl))
								commonParams.TlsCertificates = tlsCertificates
								for i, set := range sl {
									if set != nil {
										tlsCertificates[i] = &ves_io_schema.TlsCertificateType{}
										tlsCertificatesMapStrToI := set.(map[string]interface{})

										if w, ok := tlsCertificatesMapStrToI["certificate_url"]; ok && !isIntfNil(w) {
											tlsCertificates[i].CertificateUrl = w.(string)
										}

										if w, ok := tlsCertificatesMapStrToI["description"]; ok && !isIntfNil(w) {
											tlsCertificates[i].Description = w.(string)
										}

										ocspStaplingChoiceTypeFound := false

										if v, ok := tlsCertificatesMapStrToI["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

											ocspStaplingChoiceTypeFound = true
											ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
											ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
											tlsCertificates[i].OcspStaplingChoice = ocspStaplingChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

														hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
														for _, j := range v.([]interface{}) {
															hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
														}
														ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

													}

												}
											}

										}

										if _, ok := tlsCertificatesMapStrToI["disable_ocsp_stapling"]; ok && !ocspStaplingChoiceTypeFound {

											ocspStaplingChoiceTypeFound = true
											ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_DisableOcspStapling{}
											ocspStaplingChoiceInt.DisableOcspStapling = &ves_io_schema.Empty{}
											tlsCertificates[i].OcspStaplingChoice = ocspStaplingChoiceInt

										}

										if _, ok := tlsCertificatesMapStrToI["use_system_defaults"]; ok && !ocspStaplingChoiceTypeFound {

											ocspStaplingChoiceTypeFound = true
											ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_UseSystemDefaults{}
											ocspStaplingChoiceInt.UseSystemDefaults = &ves_io_schema.Empty{}
											tlsCertificates[i].OcspStaplingChoice = ocspStaplingChoiceInt

										}

										if v, ok := tlsCertificatesMapStrToI["private_key"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											privateKey := &ves_io_schema.SecretType{}
											tlsCertificates[i].PrivateKey = privateKey
											for _, set := range sl {
												if set != nil {
													privateKeyMapStrToI := set.(map[string]interface{})

													if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
														privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
														for _, set := range sl {
															if set != nil {
																blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.Location = w.(string)
																}

																if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																	blindfoldSecretInfoInternal.StoreProvider = w.(string)
																}

															}
														}

													}

													if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

														privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

													}

													secretInfoOneofTypeFound := false

													if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
														secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
														privateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																}

																if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																}

															}
														}

													}

													if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
														secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
														privateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["url"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																}

															}
														}

													}

													if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
														secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
														privateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["key"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																}

																if v, ok := cs["location"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																}

																if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																}

																if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																}

																if v, ok := cs["version"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																}

															}
														}

													}

													if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

														secretInfoOneofTypeFound = true
														secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
														secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
														privateKey.SecretInfoOneof = secretInfoOneofInt

														sl := v.([]interface{})
														for _, set := range sl {
															if set != nil {
																cs := set.(map[string]interface{})

																if v, ok := cs["name"]; ok && !isIntfNil(v) {

																	secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																}

															}
														}

													}

												}
											}

										}

									}
								}

							}

							if w, ok := commonParamsMapStrToI["trusted_ca_url"]; ok && !isIntfNil(w) {
								commonParams.TrustedCaUrl = w.(string)
							}

							if v, ok := commonParamsMapStrToI["validation_params"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								validationParams := &ves_io_schema.TlsValidationParamsType{}
								commonParams.ValidationParams = validationParams
								for _, set := range sl {
									if set != nil {
										validationParamsMapStrToI := set.(map[string]interface{})

										if w, ok := validationParamsMapStrToI["skip_hostname_verification"]; ok && !isIntfNil(w) {
											validationParams.SkipHostnameVerification = w.(bool)
										}

										trustedCaChoiceTypeFound := false

										if v, ok := validationParamsMapStrToI["trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

											trustedCaChoiceTypeFound = true
											trustedCaChoiceInt := &ves_io_schema.TlsValidationParamsType_TrustedCa{}
											trustedCaChoiceInt.TrustedCa = &ves_io_schema.TrustedCAList{}
											validationParams.TrustedCaChoice = trustedCaChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["trusted_ca_list"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														trustedCaListInt := make([]*ves_io_schema.ObjectRefType, len(sl))
														trustedCaChoiceInt.TrustedCa.TrustedCaList = trustedCaListInt
														for i, ps := range sl {

															tclMapToStrVal := ps.(map[string]interface{})
															trustedCaListInt[i] = &ves_io_schema.ObjectRefType{}

															trustedCaListInt[i].Kind = "trusted_ca_list"

															if v, ok := tclMapToStrVal["name"]; ok && !isIntfNil(v) {
																trustedCaListInt[i].Name = v.(string)
															}

															if v, ok := tclMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																trustedCaListInt[i].Namespace = v.(string)
															}

															if v, ok := tclMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																trustedCaListInt[i].Tenant = v.(string)
															}

															if v, ok := tclMapToStrVal["uid"]; ok && !isIntfNil(v) {
																trustedCaListInt[i].Uid = v.(string)
															}

														}

													}

												}
											}

										}

										if v, ok := validationParamsMapStrToI["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

											trustedCaChoiceTypeFound = true
											trustedCaChoiceInt := &ves_io_schema.TlsValidationParamsType_TrustedCaUrl{}

											validationParams.TrustedCaChoice = trustedCaChoiceInt

											trustedCaChoiceInt.TrustedCaUrl = v.(string)

										}

										if w, ok := validationParamsMapStrToI["use_volterra_trusted_ca_url"]; ok && !isIntfNil(w) {
											validationParams.UseVolterraTrustedCaUrl = w.(bool)
										}

										if w, ok := validationParamsMapStrToI["verify_subject_alt_names"]; ok && !isIntfNil(w) {
											ls := make([]string, len(w.([]interface{})))
											for i, v := range w.([]interface{}) {
												ls[i] = v.(string)
											}
											validationParams.VerifySubjectAltNames = ls
										}

									}
								}

							}

						}
					}

				}

				if v, ok := cs["crl"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					crlInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					tlsCertificatesChoiceInt.TlsParameters.Crl = crlInt
					for i, ps := range sl {

						cMapToStrVal := ps.(map[string]interface{})
						crlInt[i] = &ves_io_schema.ObjectRefType{}

						crlInt[i].Kind = "crl"

						if v, ok := cMapToStrVal["name"]; ok && !isIntfNil(v) {
							crlInt[i].Name = v.(string)
						}

						if v, ok := cMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							crlInt[i].Namespace = v.(string)
						}

						if v, ok := cMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							crlInt[i].Tenant = v.(string)
						}

						if v, ok := cMapToStrVal["uid"]; ok && !isIntfNil(v) {
							crlInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := cs["require_client_certificate"]; ok && !isIntfNil(v) {

					tlsCertificatesChoiceInt.TlsParameters.RequireClientCertificate = v.(bool)

				}

				if v, ok := cs["xfcc_header_elements"]; ok && !isIntfNil(v) {

					xfcc_header_elementsList := []ves_io_schema.XfccElement{}
					for _, j := range v.([]interface{}) {
						xfcc_header_elementsList = append(xfcc_header_elementsList, ves_io_schema.XfccElement(ves_io_schema.XfccElement_value[j.(string)]))
					}
					tlsCertificatesChoiceInt.TlsParameters.XfccHeaderElements = xfcc_header_elementsList

				}

			}
		}

	}

	if v, ok := d.GetOk("user_identification"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		userIdentificationInt := make([]*ves_io_schema.ObjectRefType, len(sl))
		updateSpec.UserIdentification = userIdentificationInt
		for i, ps := range sl {

			uiMapToStrVal := ps.(map[string]interface{})
			userIdentificationInt[i] = &ves_io_schema.ObjectRefType{}

			userIdentificationInt[i].Kind = "user_identification"

			if v, ok := uiMapToStrVal["name"]; ok && !isIntfNil(v) {
				userIdentificationInt[i].Name = v.(string)
			}

			if v, ok := uiMapToStrVal["namespace"]; ok && !isIntfNil(v) {
				userIdentificationInt[i].Namespace = v.(string)
			}

			if v, ok := uiMapToStrVal["tenant"]; ok && !isIntfNil(v) {
				userIdentificationInt[i].Tenant = v.(string)
			}

			if v, ok := uiMapToStrVal["uid"]; ok && !isIntfNil(v) {
				userIdentificationInt[i].Uid = v.(string)
			}

		}

	}

	if v, ok := d.GetOk("waf_type"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		wafType := &ves_io_schema.WafType{}
		updateSpec.WafType = wafType
		for _, set := range sl {
			if set != nil {
				wafTypeMapStrToI := set.(map[string]interface{})

				refTypeTypeFound := false

				if v, ok := wafTypeMapStrToI["app_firewall"]; ok && !isIntfNil(v) && !refTypeTypeFound {

					refTypeTypeFound = true
					refTypeInt := &ves_io_schema.WafType_AppFirewall{}
					refTypeInt.AppFirewall = &ves_io_schema.AppFirewallRefType{}
					wafType.RefType = refTypeInt

					sl := v.([]interface{})
					for _, set := range sl {
						if set != nil {
							cs := set.(map[string]interface{})

							if v, ok := cs["app_firewall"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								appFirewallInt := make([]*ves_io_schema.ObjectRefType, len(sl))
								refTypeInt.AppFirewall.AppFirewall = appFirewallInt
								for i, ps := range sl {

									afMapToStrVal := ps.(map[string]interface{})
									appFirewallInt[i] = &ves_io_schema.ObjectRefType{}

									appFirewallInt[i].Kind = "app_firewall"

									if v, ok := afMapToStrVal["name"]; ok && !isIntfNil(v) {
										appFirewallInt[i].Name = v.(string)
									}

									if v, ok := afMapToStrVal["namespace"]; ok && !isIntfNil(v) {
										appFirewallInt[i].Namespace = v.(string)
									}

									if v, ok := afMapToStrVal["tenant"]; ok && !isIntfNil(v) {
										appFirewallInt[i].Tenant = v.(string)
									}

									if v, ok := afMapToStrVal["uid"]; ok && !isIntfNil(v) {
										appFirewallInt[i].Uid = v.(string)
									}

								}

							}

						}
					}

				}

				if v, ok := wafTypeMapStrToI["disable_waf"]; ok && !isIntfNil(v) && !refTypeTypeFound {

					refTypeTypeFound = true

					if v.(bool) {
						refTypeInt := &ves_io_schema.WafType_DisableWaf{}
						refTypeInt.DisableWaf = &ves_io_schema.Empty{}
						wafType.RefType = refTypeInt
					}

				}

				if v, ok := wafTypeMapStrToI["inherit_waf"]; ok && !isIntfNil(v) && !refTypeTypeFound {

					refTypeTypeFound = true

					if v.(bool) {
						refTypeInt := &ves_io_schema.WafType_InheritWaf{}
						refTypeInt.InheritWaf = &ves_io_schema.Empty{}
						wafType.RefType = refTypeInt
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ztna_proxy_configurations"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		ztnaProxyConfigurations := &ves_io_schema_virtual_host.ZtnaProxyConfiguration{}
		updateSpec.ZtnaProxyConfigurations = ztnaProxyConfigurations
		for _, set := range sl {
			if set != nil {
				ztnaProxyConfigurationsMapStrToI := set.(map[string]interface{})

				if v, ok := ztnaProxyConfigurationsMapStrToI["ztna_application_config"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ztnaApplicationConfigInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					ztnaProxyConfigurations.ZtnaApplicationConfig = ztnaApplicationConfigInt
					for i, ps := range sl {

						zacMapToStrVal := ps.(map[string]interface{})
						ztnaApplicationConfigInt[i] = &ves_io_schema.ObjectRefType{}

						ztnaApplicationConfigInt[i].Kind = "ztna_application"

						if v, ok := zacMapToStrVal["name"]; ok && !isIntfNil(v) {
							ztnaApplicationConfigInt[i].Name = v.(string)
						}

						if v, ok := zacMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							ztnaApplicationConfigInt[i].Namespace = v.(string)
						}

						if v, ok := zacMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							ztnaApplicationConfigInt[i].Tenant = v.(string)
						}

						if v, ok := zacMapToStrVal["uid"]; ok && !isIntfNil(v) {
							ztnaApplicationConfigInt[i].Uid = v.(string)
						}

					}

				}

				if v, ok := ztnaProxyConfigurationsMapStrToI["ztna_policy_config"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ztnaPolicyConfigInt := make([]*ves_io_schema.ObjectRefType, len(sl))
					ztnaProxyConfigurations.ZtnaPolicyConfig = ztnaPolicyConfigInt
					for i, ps := range sl {

						zpcMapToStrVal := ps.(map[string]interface{})
						ztnaPolicyConfigInt[i] = &ves_io_schema.ObjectRefType{}

						ztnaPolicyConfigInt[i].Kind = "ztna"

						if v, ok := zpcMapToStrVal["name"]; ok && !isIntfNil(v) {
							ztnaPolicyConfigInt[i].Name = v.(string)
						}

						if v, ok := zpcMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							ztnaPolicyConfigInt[i].Namespace = v.(string)
						}

						if v, ok := zpcMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							ztnaPolicyConfigInt[i].Tenant = v.(string)
						}

						if v, ok := zpcMapToStrVal["uid"]; ok && !isIntfNil(v) {
							ztnaPolicyConfigInt[i].Uid = v.(string)
						}

					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Updating Volterra VirtualHost obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_virtual_host.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating VirtualHost: %s", err)
	}

	return resourceVolterraVirtualHostRead(d, meta)
}

func resourceVolterraVirtualHostDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_virtual_host.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] VirtualHost %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra VirtualHost before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra VirtualHost obj with name %+v in namespace %+v", name, namespace)
	return client.DeleteObject(context.Background(), ves_io_schema_virtual_host.ObjectType, namespace, name)
}
