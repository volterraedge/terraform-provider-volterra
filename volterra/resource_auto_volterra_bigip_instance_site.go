//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_interface "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_bigip_instance_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/bigip_instance_site"
	ves_io_schema_views_common_node "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/common_node"
)

// resourceVolterraBigipInstanceSite is implementation of Volterra's BigipInstanceSite resources
func resourceVolterraBigipInstanceSite() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraBigipInstanceSiteCreate,
		Read:   resourceVolterraBigipInstanceSiteRead,
		Update: resourceVolterraBigipInstanceSiteUpdate,
		Delete: resourceVolterraBigipInstanceSiteDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"central_manager": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Required: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"central_manager_site": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"node_list": {

				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"hostname": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"interface_list": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dhcp_client": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"dhcp_server": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},

									"no_ipv4_address": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_ip": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},

									"description": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"bond_interface": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},

									"ethernet_interface": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"device": {
													Type:     schema.TypeString,
													Required: true,
												},

												"mac": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"vlan_interface": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"device": {
													Type:     schema.TypeString,
													Required: true,
												},

												"vlan_id": {
													Type:     schema.TypeInt,
													Optional: true,
												},
											},
										},
									},

									"ipv6_auto_config": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},

									"no_ipv6_address": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_ipv6_address": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},

									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"monitor": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{},
										},
									},

									"monitor_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"mtu": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"network_option": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"segment_network": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"site_local_inside_network": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"site_local_network": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"priority": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"site_to_site_connectivity_interface_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"site_to_site_connectivity_interface_enabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"public_ip": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"type": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"volterra_software": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_sw_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"volterra_software_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
		},
	}
}

// resourceVolterraBigipInstanceSiteCreate creates BigipInstanceSite resource
func resourceVolterraBigipInstanceSiteCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_bigip_instance_site.CreateSpecType{}
	createReq := &ves_io_schema_views_bigip_instance_site.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//central_manager
	if v, ok := d.GetOk("central_manager"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		centralManager := &ves_io_schema_views_bigip_instance_site.CentralManagerList{}
		createSpec.CentralManager = centralManager
		for _, set := range sl {
			if set != nil {
				centralManagerMapStrToI := set.(map[string]interface{})

				if v, ok := centralManagerMapStrToI["central_manager_site"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					centralManagerSiteInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
					centralManager.CentralManagerSite = centralManagerSiteInt
					for i, ps := range sl {

						cmsMapToStrVal := ps.(map[string]interface{})
						centralManagerSiteInt[i] = &ves_io_schema_views.ObjectRefType{}

						if v, ok := cmsMapToStrVal["name"]; ok && !isIntfNil(v) {
							centralManagerSiteInt[i].Name = v.(string)
						}

						if v, ok := cmsMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							centralManagerSiteInt[i].Namespace = v.(string)
						}

						if v, ok := cmsMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							centralManagerSiteInt[i].Tenant = v.(string)
						}

					}

				}

			}
		}

	}

	//node_list
	if v, ok := d.GetOk("node_list"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		nodeList := make([]*ves_io_schema_views_common_node.Node, len(sl))
		createSpec.NodeList = nodeList
		for i, set := range sl {
			if set != nil {
				nodeList[i] = &ves_io_schema_views_common_node.Node{}
				nodeListMapStrToI := set.(map[string]interface{})

				if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
					nodeList[i].Hostname = w.(string)
				}

				if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					interfaceList := make([]*ves_io_schema_views_common_node.Interface, len(sl))
					nodeList[i].InterfaceList = interfaceList
					for i, set := range sl {
						if set != nil {
							interfaceList[i] = &ves_io_schema_views_common_node.Interface{}
							interfaceListMapStrToI := set.(map[string]interface{})

							addressChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

								addressChoiceTypeFound = true

								if v.(bool) {
									addressChoiceInt := &ves_io_schema_views_common_node.Interface_DhcpClient{}
									addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
									interfaceList[i].AddressChoice = addressChoiceInt
								}

							}

							if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

								addressChoiceTypeFound = true
								addressChoiceInt := &ves_io_schema_views_common_node.Interface_DhcpServer{}
								addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
								interfaceList[i].AddressChoice = addressChoiceInt

							}

							if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

								addressChoiceTypeFound = true

								if v.(bool) {
									addressChoiceInt := &ves_io_schema_views_common_node.Interface_NoIpv4Address{}
									addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
									interfaceList[i].AddressChoice = addressChoiceInt
								}

							}

							if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

								addressChoiceTypeFound = true
								addressChoiceInt := &ves_io_schema_views_common_node.Interface_StaticIp{}
								addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
								interfaceList[i].AddressChoice = addressChoiceInt

							}

							if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
								interfaceList[i].Description = w.(string)
							}

							interfaceChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_common_node.Interface_BondInterface{}
								interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
								interfaceList[i].InterfaceChoice = interfaceChoiceInt

							}

							if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_common_node.Interface_EthernetInterface{}
								interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_common_node.EthernetInterfaceType{}
								interfaceList[i].InterfaceChoice = interfaceChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["device"]; ok && !isIntfNil(v) {

											interfaceChoiceInt.EthernetInterface.Device = v.(string)

										}

										if v, ok := cs["mac"]; ok && !isIntfNil(v) {

											interfaceChoiceInt.EthernetInterface.Mac = v.(string)

										}

									}
								}

							}

							if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_common_node.Interface_VlanInterface{}
								interfaceChoiceInt.VlanInterface = &ves_io_schema_views_common_node.VlanInterfaceType{}
								interfaceList[i].InterfaceChoice = interfaceChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["device"]; ok && !isIntfNil(v) {

											interfaceChoiceInt.VlanInterface.Device = v.(string)

										}

										if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

											interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

										}

									}
								}

							}

							ipv6AddressChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

								ipv6AddressChoiceTypeFound = true
								ipv6AddressChoiceInt := &ves_io_schema_views_common_node.Interface_Ipv6AutoConfig{}
								ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
								interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

							}

							if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

								ipv6AddressChoiceTypeFound = true

								if v.(bool) {
									ipv6AddressChoiceInt := &ves_io_schema_views_common_node.Interface_NoIpv6Address{}
									ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
									interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
								}

							}

							if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

								ipv6AddressChoiceTypeFound = true
								ipv6AddressChoiceInt := &ves_io_schema_views_common_node.Interface_StaticIpv6Address{}
								ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
								interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

							}

							if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								interfaceList[i].Labels = ms
							}

							monitoringChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

								monitoringChoiceTypeFound = true
								monitoringChoiceInt := &ves_io_schema_views_common_node.Interface_Monitor{}
								monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
								interfaceList[i].MonitoringChoice = monitoringChoiceInt

							}

							if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

								monitoringChoiceTypeFound = true

								if v.(bool) {
									monitoringChoiceInt := &ves_io_schema_views_common_node.Interface_MonitorDisabled{}
									monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
									interfaceList[i].MonitoringChoice = monitoringChoiceInt
								}

							}

							if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
								interfaceList[i].Mtu = uint32(w.(int))
							}

							if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
								interfaceList[i].Name = w.(string)
							}

							if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkOption := &ves_io_schema_views_common_node.NetworkSelectType{}
								interfaceList[i].NetworkOption = networkOption
								for _, set := range sl {
									if set != nil {
										networkOptionMapStrToI := set.(map[string]interface{})

										networkChoiceTypeFound := false

										if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

											networkChoiceTypeFound = true
											networkChoiceInt := &ves_io_schema_views_common_node.NetworkSelectType_SegmentNetwork{}
											networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
											networkOption.NetworkChoice = networkChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}
											}

										}

										if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

											networkChoiceTypeFound = true

											if v.(bool) {
												networkChoiceInt := &ves_io_schema_views_common_node.NetworkSelectType_SiteLocalInsideNetwork{}
												networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
												networkOption.NetworkChoice = networkChoiceInt
											}

										}

										if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

											networkChoiceTypeFound = true

											if v.(bool) {
												networkChoiceInt := &ves_io_schema_views_common_node.NetworkSelectType_SiteLocalNetwork{}
												networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
												networkOption.NetworkChoice = networkChoiceInt
											}

										}

									}
								}

							}

							if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
								interfaceList[i].Priority = uint32(w.(int))
							}

							siteToSiteConnectivityInterfaceChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

								siteToSiteConnectivityInterfaceChoiceTypeFound = true

								if v.(bool) {
									siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_common_node.Interface_SiteToSiteConnectivityInterfaceDisabled{}
									siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
									interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
								}

							}

							if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

								siteToSiteConnectivityInterfaceChoiceTypeFound = true

								if v.(bool) {
									siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_common_node.Interface_SiteToSiteConnectivityInterfaceEnabled{}
									siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
									interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
								}

							}

						}
					}

				}

				if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
					nodeList[i].PublicIp = w.(string)
				}

				if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
					nodeList[i].Type = w.(string)
				}

			}
		}

	}

	//volterra_software
	if v, ok := d.GetOk("volterra_software"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		volterraSoftware := &ves_io_schema_views.VolterraSoftwareType{}
		createSpec.VolterraSoftware = volterraSoftware
		for _, set := range sl {
			if set != nil {
				volterraSoftwareMapStrToI := set.(map[string]interface{})

				volterraSwVersionChoiceTypeFound := false

				if v, ok := volterraSoftwareMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true

					if v.(bool) {
						volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
						volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
						volterraSoftware.VolterraSwVersionChoice = volterraSwVersionChoiceInt
					}

				}

				if v, ok := volterraSoftwareMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

					volterraSoftware.VolterraSwVersionChoice = volterraSwVersionChoiceInt

					volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

				}

			}
		}

	}

	log.Printf("[DEBUG] Creating Volterra BigipInstanceSite object with struct: %+v", createReq)

	createBigipInstanceSiteResp, err := client.CreateObject(context.Background(), ves_io_schema_views_bigip_instance_site.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating BigipInstanceSite: %s", err)
	}
	d.SetId(createBigipInstanceSiteResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraBigipInstanceSiteRead(d, meta)
}

func resourceVolterraBigipInstanceSiteRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_bigip_instance_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] BigipInstanceSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra BigipInstanceSite %q: %s", d.Id(), err)
	}
	return setBigipInstanceSiteFields(client, d, resp)
}

func setBigipInstanceSiteFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraBigipInstanceSiteUpdate updates BigipInstanceSite resource
func resourceVolterraBigipInstanceSiteUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_bigip_instance_site.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_bigip_instance_site.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("central_manager"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		centralManager := &ves_io_schema_views_bigip_instance_site.CentralManagerList{}
		updateSpec.CentralManager = centralManager
		for _, set := range sl {
			if set != nil {
				centralManagerMapStrToI := set.(map[string]interface{})

				if v, ok := centralManagerMapStrToI["central_manager_site"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					centralManagerSiteInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
					centralManager.CentralManagerSite = centralManagerSiteInt
					for i, ps := range sl {

						cmsMapToStrVal := ps.(map[string]interface{})
						centralManagerSiteInt[i] = &ves_io_schema_views.ObjectRefType{}

						if v, ok := cmsMapToStrVal["name"]; ok && !isIntfNil(v) {
							centralManagerSiteInt[i].Name = v.(string)
						}

						if v, ok := cmsMapToStrVal["namespace"]; ok && !isIntfNil(v) {
							centralManagerSiteInt[i].Namespace = v.(string)
						}

						if v, ok := cmsMapToStrVal["tenant"]; ok && !isIntfNil(v) {
							centralManagerSiteInt[i].Tenant = v.(string)
						}

					}

				}

			}
		}

	}

	if v, ok := d.GetOk("node_list"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		nodeList := make([]*ves_io_schema_views_common_node.Node, len(sl))
		updateSpec.NodeList = nodeList
		for i, set := range sl {
			if set != nil {
				nodeList[i] = &ves_io_schema_views_common_node.Node{}
				nodeListMapStrToI := set.(map[string]interface{})

				if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
					nodeList[i].Hostname = w.(string)
				}

				if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					interfaceList := make([]*ves_io_schema_views_common_node.Interface, len(sl))
					nodeList[i].InterfaceList = interfaceList
					for i, set := range sl {
						if set != nil {
							interfaceList[i] = &ves_io_schema_views_common_node.Interface{}
							interfaceListMapStrToI := set.(map[string]interface{})

							addressChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

								addressChoiceTypeFound = true

								if v.(bool) {
									addressChoiceInt := &ves_io_schema_views_common_node.Interface_DhcpClient{}
									addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
									interfaceList[i].AddressChoice = addressChoiceInt
								}

							}

							if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

								addressChoiceTypeFound = true
								addressChoiceInt := &ves_io_schema_views_common_node.Interface_DhcpServer{}
								addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
								interfaceList[i].AddressChoice = addressChoiceInt

							}

							if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

								addressChoiceTypeFound = true

								if v.(bool) {
									addressChoiceInt := &ves_io_schema_views_common_node.Interface_NoIpv4Address{}
									addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
									interfaceList[i].AddressChoice = addressChoiceInt
								}

							}

							if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

								addressChoiceTypeFound = true
								addressChoiceInt := &ves_io_schema_views_common_node.Interface_StaticIp{}
								addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
								interfaceList[i].AddressChoice = addressChoiceInt

							}

							if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
								interfaceList[i].Description = w.(string)
							}

							interfaceChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_common_node.Interface_BondInterface{}
								interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
								interfaceList[i].InterfaceChoice = interfaceChoiceInt

							}

							if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_common_node.Interface_EthernetInterface{}
								interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_common_node.EthernetInterfaceType{}
								interfaceList[i].InterfaceChoice = interfaceChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["device"]; ok && !isIntfNil(v) {

											interfaceChoiceInt.EthernetInterface.Device = v.(string)

										}

										if v, ok := cs["mac"]; ok && !isIntfNil(v) {

											interfaceChoiceInt.EthernetInterface.Mac = v.(string)

										}

									}
								}

							}

							if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_common_node.Interface_VlanInterface{}
								interfaceChoiceInt.VlanInterface = &ves_io_schema_views_common_node.VlanInterfaceType{}
								interfaceList[i].InterfaceChoice = interfaceChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["device"]; ok && !isIntfNil(v) {

											interfaceChoiceInt.VlanInterface.Device = v.(string)

										}

										if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

											interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

										}

									}
								}

							}

							ipv6AddressChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

								ipv6AddressChoiceTypeFound = true
								ipv6AddressChoiceInt := &ves_io_schema_views_common_node.Interface_Ipv6AutoConfig{}
								ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
								interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

							}

							if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

								ipv6AddressChoiceTypeFound = true

								if v.(bool) {
									ipv6AddressChoiceInt := &ves_io_schema_views_common_node.Interface_NoIpv6Address{}
									ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
									interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
								}

							}

							if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

								ipv6AddressChoiceTypeFound = true
								ipv6AddressChoiceInt := &ves_io_schema_views_common_node.Interface_StaticIpv6Address{}
								ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
								interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

							}

							if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								interfaceList[i].Labels = ms
							}

							monitoringChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

								monitoringChoiceTypeFound = true
								monitoringChoiceInt := &ves_io_schema_views_common_node.Interface_Monitor{}
								monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
								interfaceList[i].MonitoringChoice = monitoringChoiceInt

							}

							if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

								monitoringChoiceTypeFound = true

								if v.(bool) {
									monitoringChoiceInt := &ves_io_schema_views_common_node.Interface_MonitorDisabled{}
									monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
									interfaceList[i].MonitoringChoice = monitoringChoiceInt
								}

							}

							if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
								interfaceList[i].Mtu = uint32(w.(int))
							}

							if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
								interfaceList[i].Name = w.(string)
							}

							if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								networkOption := &ves_io_schema_views_common_node.NetworkSelectType{}
								interfaceList[i].NetworkOption = networkOption
								for _, set := range sl {
									if set != nil {
										networkOptionMapStrToI := set.(map[string]interface{})

										networkChoiceTypeFound := false

										if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

											networkChoiceTypeFound = true
											networkChoiceInt := &ves_io_schema_views_common_node.NetworkSelectType_SegmentNetwork{}
											networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
											networkOption.NetworkChoice = networkChoiceInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}
											}

										}

										if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

											networkChoiceTypeFound = true

											if v.(bool) {
												networkChoiceInt := &ves_io_schema_views_common_node.NetworkSelectType_SiteLocalInsideNetwork{}
												networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
												networkOption.NetworkChoice = networkChoiceInt
											}

										}

										if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

											networkChoiceTypeFound = true

											if v.(bool) {
												networkChoiceInt := &ves_io_schema_views_common_node.NetworkSelectType_SiteLocalNetwork{}
												networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
												networkOption.NetworkChoice = networkChoiceInt
											}

										}

									}
								}

							}

							if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
								interfaceList[i].Priority = uint32(w.(int))
							}

							siteToSiteConnectivityInterfaceChoiceTypeFound := false

							if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

								siteToSiteConnectivityInterfaceChoiceTypeFound = true

								if v.(bool) {
									siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_common_node.Interface_SiteToSiteConnectivityInterfaceDisabled{}
									siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
									interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
								}

							}

							if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

								siteToSiteConnectivityInterfaceChoiceTypeFound = true

								if v.(bool) {
									siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_common_node.Interface_SiteToSiteConnectivityInterfaceEnabled{}
									siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
									interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
								}

							}

						}
					}

				}

				if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
					nodeList[i].PublicIp = w.(string)
				}

				if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
					nodeList[i].Type = w.(string)
				}

			}
		}

	}

	if v, ok := d.GetOk("volterra_software"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		volterraSoftware := &ves_io_schema_views.VolterraSoftwareType{}
		updateSpec.VolterraSoftware = volterraSoftware
		for _, set := range sl {
			if set != nil {
				volterraSoftwareMapStrToI := set.(map[string]interface{})

				volterraSwVersionChoiceTypeFound := false

				if v, ok := volterraSoftwareMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true

					if v.(bool) {
						volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
						volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
						volterraSoftware.VolterraSwVersionChoice = volterraSwVersionChoiceInt
					}

				}

				if v, ok := volterraSoftwareMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

					volterraSwVersionChoiceTypeFound = true
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

					volterraSoftware.VolterraSwVersionChoice = volterraSwVersionChoiceInt

					volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

				}

			}
		}

	}

	log.Printf("[DEBUG] Updating Volterra BigipInstanceSite obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_bigip_instance_site.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating BigipInstanceSite: %s", err)
	}

	return resourceVolterraBigipInstanceSiteRead(d, meta)
}

func resourceVolterraBigipInstanceSiteDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_bigip_instance_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] BigipInstanceSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra BigipInstanceSite before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra BigipInstanceSite obj with name %+v in namespace %+v", name, namespace)
	opts := []vesapi.CallOpt{
		vesapi.WithFailIfReferred(),
	}
	return client.DeleteObject(context.Background(), ves_io_schema_views_bigip_instance_site.ObjectType, namespace, name, opts...)
}
