//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_network_interface "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_securemesh_site_v2 "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/securemesh_site_v2"
	ves_io_schema_virtual_network "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_network"
)

// resourceVolterraSecuremeshSiteV2 is implementation of Volterra's SecuremeshSiteV2 resources
func resourceVolterraSecuremeshSiteV2() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraSecuremeshSiteV2Create,
		Read:   resourceVolterraSecuremeshSiteV2Read,
		Update: resourceVolterraSecuremeshSiteV2Update,
		Delete: resourceVolterraSecuremeshSiteV2Delete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"block_all_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"blocked_services": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"blocked_sevice": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ssh": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"web_user_interface": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"network_type": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"active_forward_proxy_policies": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"forward_proxy_policies": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"no_forward_proxy": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"load_balancing": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"vip_vrrp_mode": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"local_vrf": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_sli_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sli_config": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"nameserver": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"nameserver_v6": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"no_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"no_v6_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_v6_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"vip": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"vip_v6": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"default_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"slo_config": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"nameserver": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"nameserver_v6": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"no_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"no_v6_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_v6_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"vip": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"vip_v6": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"log_receiver": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"logs_streaming_disabled": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"active_enhanced_firewall_policies": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"enhanced_firewall_policies": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"no_network_policy": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"disable_ha": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"enable_ha": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"offline_survivability_mode": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"enable_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"performance_enhancement_mode": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"perf_mode_l3_enhanced": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"jumbo": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"no_jumbo": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"perf_mode_l7_enhanced": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"aws": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"not_managed": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"node_list": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"hostname": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"interface_list": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv4_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"description": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bond_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"devices": {

																			Type: schema.TypeList,

																			Required: true,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},

																		"active_backup": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"lacp": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"rate": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"link_polling_interval": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"link_up_delay": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"ethernet_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"mac": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"vlan_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"vlan_id": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6_auto_config": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeSet,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"is_management": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"is_primary": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"network_option": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"segment_network": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"site_local_inside_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"site_local_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"site_to_site_connectivity_interface_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_to_site_connectivity_interface_enabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"public_ip": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"type": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"azure": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"not_managed": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"node_list": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"hostname": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"interface_list": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv4_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"description": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bond_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"devices": {

																			Type: schema.TypeList,

																			Required: true,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},

																		"active_backup": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"lacp": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"rate": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"link_polling_interval": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"link_up_delay": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"ethernet_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"mac": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"vlan_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"vlan_id": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6_auto_config": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeSet,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"is_management": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"is_primary": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"network_option": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"segment_network": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"site_local_inside_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"site_local_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"site_to_site_connectivity_interface_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_to_site_connectivity_interface_enabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"public_ip": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"type": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"baremetal": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"not_managed": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"node_list": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"hostname": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"interface_list": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv4_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"description": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bond_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"devices": {

																			Type: schema.TypeList,

																			Required: true,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},

																		"active_backup": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"lacp": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"rate": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"link_polling_interval": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"link_up_delay": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"ethernet_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"mac": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"vlan_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"vlan_id": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6_auto_config": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeSet,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"is_management": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"is_primary": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"network_option": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"segment_network": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"site_local_inside_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"site_local_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"site_to_site_connectivity_interface_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_to_site_connectivity_interface_enabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"public_ip": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"type": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"gcp": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"not_managed": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"node_list": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"hostname": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"interface_list": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv4_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"description": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bond_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"devices": {

																			Type: schema.TypeList,

																			Required: true,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},

																		"active_backup": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"lacp": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"rate": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"link_polling_interval": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"link_up_delay": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"ethernet_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"mac": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"vlan_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"vlan_id": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6_auto_config": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeSet,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"is_management": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"is_primary": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"network_option": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"segment_network": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"site_local_inside_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"site_local_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"site_to_site_connectivity_interface_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_to_site_connectivity_interface_enabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"public_ip": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"type": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"kvm": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"not_managed": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"node_list": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"hostname": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"interface_list": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv4_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"description": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bond_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"devices": {

																			Type: schema.TypeList,

																			Required: true,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},

																		"active_backup": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"lacp": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"rate": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"link_polling_interval": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"link_up_delay": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"ethernet_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"mac": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"vlan_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"vlan_id": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6_auto_config": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeSet,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"is_management": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"is_primary": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"network_option": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"segment_network": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"site_local_inside_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"site_local_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"site_to_site_connectivity_interface_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_to_site_connectivity_interface_enabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"public_ip": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"type": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"oci": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"not_managed": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"node_list": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"hostname": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"interface_list": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv4_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"description": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bond_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"devices": {

																			Type: schema.TypeList,

																			Required: true,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},

																		"active_backup": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"lacp": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"rate": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"link_polling_interval": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"link_up_delay": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"ethernet_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"mac": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"vlan_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"vlan_id": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6_auto_config": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeSet,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"is_management": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"is_primary": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"network_option": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"segment_network": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"site_local_inside_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"site_local_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"site_to_site_connectivity_interface_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_to_site_connectivity_interface_enabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"public_ip": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"type": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"rseries": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"not_managed": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"node_list": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"hostname": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"interface_list": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv4_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"description": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bond_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"devices": {

																			Type: schema.TypeList,

																			Required: true,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},

																		"active_backup": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"lacp": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"rate": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"link_polling_interval": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"link_up_delay": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"ethernet_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"mac": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"vlan_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"vlan_id": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6_auto_config": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeSet,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"is_management": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"is_primary": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"network_option": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"segment_network": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"site_local_inside_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"site_local_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"site_to_site_connectivity_interface_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_to_site_connectivity_interface_enabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"public_ip": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"type": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"vmware": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"not_managed": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"node_list": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"hostname": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"interface_list": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv4_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"description": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"bond_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"devices": {

																			Type: schema.TypeList,

																			Required: true,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},

																		"active_backup": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"lacp": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"rate": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"link_polling_interval": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"link_up_delay": {
																			Type:     schema.TypeInt,
																			Required: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Required: true,
																		},
																	},
																},
															},

															"ethernet_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"mac": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"vlan_interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"device": {
																			Type:     schema.TypeString,
																			Required: true,
																		},

																		"vlan_id": {
																			Type:     schema.TypeInt,
																			Optional: true,
																		},
																	},
																},
															},

															"ipv6_auto_config": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:       schema.TypeSet,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"namespace": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																														"tenant": {
																															Type:       schema.TypeString,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},
																													},
																												},
																											},

																											"pool_settings": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:       schema.TypeBool,
																															Optional:   true,
																															Deprecated: "This field is deprecated and will be removed in future release.",
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"network_prefix_allocator": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"namespace": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																								"tenant": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"is_management": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"is_primary": {
																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"network_option": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"segment_network": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"site_local_inside_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"site_local_network": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"site_to_site_connectivity_interface_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_to_site_connectivity_interface_enabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},
														},
													},
												},

												"public_ip": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"type": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"re_select": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"geo_proximity": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"specific_geography": {

							Type:       schema.TypeString,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"specific_re": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"backup_re": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"primary_re": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"dc_cluster_group_sli": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"no_s2s_connectivity_sli": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"dc_cluster_group_slo": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"no_s2s_connectivity_slo": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"site_mesh_group_on_slo": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"no_site_mesh_group": {

							Type:       schema.TypeBool,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
						},

						"site_mesh_group": {

							Type:       schema.TypeSet,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"namespace": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
									"tenant": {
										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"software_settings": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"os": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"default_os_version": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"operating_system_version": {

										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"sw": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"default_sw_version": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"volterra_software_version": {

										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"tunnel_dead_timeout": {
				Type:     schema.TypeInt,
				Optional: true,
			},

			"tunnel_type": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"upgrade_settings": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"kubernetes_upgrade_drain": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"disable_upgrade_drain": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"enable_upgrade_drain": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"drain_max_unavailable_node_count": {

													Type:     schema.TypeInt,
													Optional: true,
												},

												"drain_max_unavailable_node_percentage": {

													Type:       schema.TypeInt,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"drain_node_timeout": {
													Type:     schema.TypeInt,
													Required: true,
												},

												"disable_vega_upgrade_mode": {

													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"enable_vega_upgrade_mode": {

													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// resourceVolterraSecuremeshSiteV2Create creates SecuremeshSiteV2 resource
func resourceVolterraSecuremeshSiteV2Create(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_securemesh_site_v2.CreateSpecType{}
	createReq := &ves_io_schema_views_securemesh_site_v2.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//blocked_services_choice

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("block_all_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_BlockAllServices{}
			blockedServicesChoiceInt.BlockAllServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		createSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
				blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
				for i, set := range sl {
					blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
					blockedSeviceMapStrToI := set.(map[string]interface{})

					blockedServicesValueTypeChoiceTypeFound := false

					if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
							blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
							blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
							blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

						blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

					}

				}

			}

		}

	}

	//forward_proxy_choice

	forwardProxyChoiceTypeFound := false

	if v, ok := d.GetOk("active_forward_proxy_policies"); ok && !forwardProxyChoiceTypeFound {

		forwardProxyChoiceTypeFound = true
		forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_ActiveForwardProxyPolicies{}
		forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
		createSpec.ForwardProxyChoice = forwardProxyChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
				forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
				for i, ps := range sl {

					fppMapToStrVal := ps.(map[string]interface{})
					forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

					if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
						forwardProxyPoliciesInt[i].Name = v.(string)
					}

					if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						forwardProxyPoliciesInt[i].Namespace = v.(string)
					}

					if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						forwardProxyPoliciesInt[i].Tenant = v.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("no_forward_proxy"); ok && !forwardProxyChoiceTypeFound {

		forwardProxyChoiceTypeFound = true

		if v.(bool) {
			forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_NoForwardProxy{}
			forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
			createSpec.ForwardProxyChoice = forwardProxyChoiceInt
		}

	}

	//load_balancing
	if v, ok := d.GetOk("load_balancing"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		loadBalancing := &ves_io_schema_views_securemesh_site_v2.LoadBalancingSettingsType{}
		createSpec.LoadBalancing = loadBalancing
		for _, set := range sl {
			loadBalancingMapStrToI := set.(map[string]interface{})

			if v, ok := loadBalancingMapStrToI["vip_vrrp_mode"]; ok && !isIntfNil(v) {

				loadBalancing.VipVrrpMode = ves_io_schema.VipVrrpType(ves_io_schema.VipVrrpType_value[v.(string)])

			}

		}

	}

	//local_vrf
	if v, ok := d.GetOk("local_vrf"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		localVrf := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType{}
		createSpec.LocalVrf = localVrf
		for _, set := range sl {
			localVrfMapStrToI := set.(map[string]interface{})

			sliChoiceTypeFound := false

			if v, ok := localVrfMapStrToI["default_sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true

				if v.(bool) {
					sliChoiceInt := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType_DefaultSliConfig{}
					sliChoiceInt.DefaultSliConfig = &ves_io_schema.Empty{}
					localVrf.SliChoice = sliChoiceInt
				}

			}

			if v, ok := localVrfMapStrToI["sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true
				sliChoiceInt := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType_SliConfig{}
				sliChoiceInt.SliConfig = &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration{}
				localVrf.SliChoice = sliChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sliChoiceInt.SliConfig.Labels = ms
					}

					if v, ok := cs["nameserver"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.Nameserver = v.(string)

					}

					if v, ok := cs["nameserver_v6"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.NameserverV6 = v.(string)

					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_securemesh_site_v2.StaticRoutesListType{}
						sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					staticV6RouteChoiceTypeFound := false

					if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true

						if v.(bool) {
							staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_NoV6StaticRoutes{}
							staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
						}

					}

					if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true
						staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_StaticV6Routes{}
						staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
						sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
								staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					if v, ok := cs["vip"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.Vip = v.(string)

					}

					if v, ok := cs["vip_v6"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.VipV6 = v.(string)

					}

				}

			}

			sloChoiceTypeFound := false

			if v, ok := localVrfMapStrToI["default_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true

				if v.(bool) {
					sloChoiceInt := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType_DefaultConfig{}
					sloChoiceInt.DefaultConfig = &ves_io_schema.Empty{}
					localVrf.SloChoice = sloChoiceInt
				}

			}

			if v, ok := localVrfMapStrToI["slo_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true
				sloChoiceInt := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType_SloConfig{}
				sloChoiceInt.SloConfig = &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration{}
				localVrf.SloChoice = sloChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sloChoiceInt.SloConfig.Labels = ms
					}

					if v, ok := cs["nameserver"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.Nameserver = v.(string)

					}

					if v, ok := cs["nameserver_v6"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.NameserverV6 = v.(string)

					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_securemesh_site_v2.StaticRoutesListType{}
						sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					staticV6RouteChoiceTypeFound := false

					if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true

						if v.(bool) {
							staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_NoV6StaticRoutes{}
							staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
						}

					}

					if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true
						staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_StaticV6Routes{}
						staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
						sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
								staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					if v, ok := cs["vip"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.Vip = v.(string)

					}

					if v, ok := cs["vip_v6"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.VipV6 = v.(string)

					}

				}

			}

		}

	}

	//logs_receiver_choice

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		createSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			createSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	//network_policy_choice

	networkPolicyChoiceTypeFound := false

	if v, ok := d.GetOk("active_enhanced_firewall_policies"); ok && !networkPolicyChoiceTypeFound {

		networkPolicyChoiceTypeFound = true
		networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_ActiveEnhancedFirewallPolicies{}
		networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
		createSpec.NetworkPolicyChoice = networkPolicyChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
				networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
				for i, ps := range sl {

					efpMapToStrVal := ps.(map[string]interface{})
					enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

					if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
						enhancedFirewallPoliciesInt[i].Name = v.(string)
					}

					if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						enhancedFirewallPoliciesInt[i].Namespace = v.(string)
					}

					if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						enhancedFirewallPoliciesInt[i].Tenant = v.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("no_network_policy"); ok && !networkPolicyChoiceTypeFound {

		networkPolicyChoiceTypeFound = true

		if v.(bool) {
			networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_NoNetworkPolicy{}
			networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
			createSpec.NetworkPolicyChoice = networkPolicyChoiceInt
		}

	}

	//node_ha_choice

	nodeHaChoiceTypeFound := false

	if v, ok := d.GetOk("disable_ha"); ok && !nodeHaChoiceTypeFound {

		nodeHaChoiceTypeFound = true

		if v.(bool) {
			nodeHaChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_DisableHa{}
			nodeHaChoiceInt.DisableHa = &ves_io_schema.Empty{}
			createSpec.NodeHaChoice = nodeHaChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_ha"); ok && !nodeHaChoiceTypeFound {

		nodeHaChoiceTypeFound = true

		if v.(bool) {
			nodeHaChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_EnableHa{}
			nodeHaChoiceInt.EnableHa = &ves_io_schema.Empty{}
			createSpec.NodeHaChoice = nodeHaChoiceInt
		}

	}

	//offline_survivability_mode
	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		createSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

			offlineSurvivabilityModeChoiceTypeFound := false

			if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

			if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

		}

	}

	//performance_enhancement_mode
	if v, ok := d.GetOk("performance_enhancement_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
		createSpec.PerformanceEnhancementMode = performanceEnhancementMode
		for _, set := range sl {
			performanceEnhancementModeMapStrToI := set.(map[string]interface{})

			perfModeChoiceTypeFound := false

			if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

				perfModeChoiceTypeFound = true
				perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
				perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
				performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					perfModeChoiceTypeFound := false

					if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
							perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
							perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
						}

					}

					if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
							perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
							perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
						}

					}

				}

			}

			if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

				perfModeChoiceTypeFound = true

				if v.(bool) {
					perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
					perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
					performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
				}

			}

		}

	}

	//provider_choice

	providerChoiceTypeFound := false

	if v, ok := d.GetOk("aws"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_Aws{}
		providerChoiceInt.Aws = &ves_io_schema_views_securemesh_site_v2.AWSProviderType{}
		createSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.AWSProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Aws.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("azure"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_Azure{}
		providerChoiceInt.Azure = &ves_io_schema_views_securemesh_site_v2.AzureProviderType{}
		createSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.AzureProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Azure.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("baremetal"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_Baremetal{}
		providerChoiceInt.Baremetal = &ves_io_schema_views_securemesh_site_v2.BaremetalProviderType{}
		createSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.BaremetalProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Baremetal.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("gcp"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_Gcp{}
		providerChoiceInt.Gcp = &ves_io_schema_views_securemesh_site_v2.GCPProviderType{}
		createSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.GCPProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Gcp.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("kvm"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_Kvm{}
		providerChoiceInt.Kvm = &ves_io_schema_views_securemesh_site_v2.KVMProviderType{}
		createSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.KVMProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Kvm.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("oci"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_Oci{}
		providerChoiceInt.Oci = &ves_io_schema_views_securemesh_site_v2.OCIProviderType{}
		createSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.OCIProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Oci.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("rseries"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_Rseries{}
		providerChoiceInt.Rseries = &ves_io_schema_views_securemesh_site_v2.RSeriesProviderType{}
		createSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.RSeriesProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Rseries.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("vmware"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_Vmware{}
		providerChoiceInt.Vmware = &ves_io_schema_views_securemesh_site_v2.VMwareProviderType{}
		createSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.VMwareProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Vmware.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	//re_select
	if v, ok := d.GetOk("re_select"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		reSelect := &ves_io_schema_views.RegionalEdgeSelection{}
		createSpec.ReSelect = reSelect
		for _, set := range sl {
			reSelectMapStrToI := set.(map[string]interface{})

			reSelectionChoiceTypeFound := false

			if v, ok := reSelectMapStrToI["geo_proximity"]; ok && !isIntfNil(v) && !reSelectionChoiceTypeFound {

				reSelectionChoiceTypeFound = true

				if v.(bool) {
					reSelectionChoiceInt := &ves_io_schema_views.RegionalEdgeSelection_GeoProximity{}
					reSelectionChoiceInt.GeoProximity = &ves_io_schema.Empty{}
					reSelect.ReSelectionChoice = reSelectionChoiceInt
				}

			}

			if v, ok := reSelectMapStrToI["specific_geography"]; ok && !isIntfNil(v) && !reSelectionChoiceTypeFound {

				reSelectionChoiceTypeFound = true
				reSelectionChoiceInt := &ves_io_schema_views.RegionalEdgeSelection_SpecificGeography{}

				reSelect.ReSelectionChoice = reSelectionChoiceInt

				reSelectionChoiceInt.SpecificGeography = v.(string)

			}

			if v, ok := reSelectMapStrToI["specific_re"]; ok && !isIntfNil(v) && !reSelectionChoiceTypeFound {

				reSelectionChoiceTypeFound = true
				reSelectionChoiceInt := &ves_io_schema_views.RegionalEdgeSelection_SpecificRe{}
				reSelectionChoiceInt.SpecificRe = &ves_io_schema_views.SpecificRE{}
				reSelect.ReSelectionChoice = reSelectionChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["backup_re"]; ok && !isIntfNil(v) {

						reSelectionChoiceInt.SpecificRe.BackupRe = v.(string)

					}

					if v, ok := cs["primary_re"]; ok && !isIntfNil(v) {

						reSelectionChoiceInt.SpecificRe.PrimaryRe = v.(string)

					}

				}

			}

		}

	}

	//s2s_connectivity_sli_choice

	s2SConnectivitySliChoiceTypeFound := false

	if v, ok := d.GetOk("dc_cluster_group_sli"); ok && !s2SConnectivitySliChoiceTypeFound {

		s2SConnectivitySliChoiceTypeFound = true
		s2SConnectivitySliChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_DcClusterGroupSli{}
		s2SConnectivitySliChoiceInt.DcClusterGroupSli = &ves_io_schema_views.ObjectRefType{}
		createSpec.S2SConnectivitySliChoice = s2SConnectivitySliChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				s2SConnectivitySliChoiceInt.DcClusterGroupSli.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				s2SConnectivitySliChoiceInt.DcClusterGroupSli.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				s2SConnectivitySliChoiceInt.DcClusterGroupSli.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("no_s2s_connectivity_sli"); ok && !s2SConnectivitySliChoiceTypeFound {

		s2SConnectivitySliChoiceTypeFound = true

		if v.(bool) {
			s2SConnectivitySliChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_NoS2SConnectivitySli{}
			s2SConnectivitySliChoiceInt.NoS2SConnectivitySli = &ves_io_schema.Empty{}
			createSpec.S2SConnectivitySliChoice = s2SConnectivitySliChoiceInt
		}

	}

	//s2s_connectivity_slo_choice

	s2SConnectivitySloChoiceTypeFound := false

	if v, ok := d.GetOk("dc_cluster_group_slo"); ok && !s2SConnectivitySloChoiceTypeFound {

		s2SConnectivitySloChoiceTypeFound = true
		s2SConnectivitySloChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_DcClusterGroupSlo{}
		s2SConnectivitySloChoiceInt.DcClusterGroupSlo = &ves_io_schema_views.ObjectRefType{}
		createSpec.S2SConnectivitySloChoice = s2SConnectivitySloChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				s2SConnectivitySloChoiceInt.DcClusterGroupSlo.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				s2SConnectivitySloChoiceInt.DcClusterGroupSlo.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				s2SConnectivitySloChoiceInt.DcClusterGroupSlo.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("no_s2s_connectivity_slo"); ok && !s2SConnectivitySloChoiceTypeFound {

		s2SConnectivitySloChoiceTypeFound = true

		if v.(bool) {
			s2SConnectivitySloChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_NoS2SConnectivitySlo{}
			s2SConnectivitySloChoiceInt.NoS2SConnectivitySlo = &ves_io_schema.Empty{}
			createSpec.S2SConnectivitySloChoice = s2SConnectivitySloChoiceInt
		}

	}

	if v, ok := d.GetOk("site_mesh_group_on_slo"); ok && !s2SConnectivitySloChoiceTypeFound {

		s2SConnectivitySloChoiceTypeFound = true
		s2SConnectivitySloChoiceInt := &ves_io_schema_views_securemesh_site_v2.CreateSpecType_SiteMeshGroupOnSlo{}
		s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo = &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType{}
		createSpec.S2SConnectivitySloChoice = s2SConnectivitySloChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			siteMeshGroupChoiceTypeFound := false

			if v, ok := cs["no_site_mesh_group"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType_NoSiteMeshGroup{}
					siteMeshGroupChoiceInt.NoSiteMeshGroup = &ves_io_schema.Empty{}
					s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			if v, ok := cs["site_mesh_group"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true
				siteMeshGroupChoiceInt := &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType_SiteMeshGroup{}
				siteMeshGroupChoiceInt.SiteMeshGroup = &ves_io_schema_views.ObjectRefType{}
				s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo.SiteMeshGroupChoice = siteMeshGroupChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						siteMeshGroupChoiceInt.SiteMeshGroup.Name = v.(string)

					}

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						siteMeshGroupChoiceInt.SiteMeshGroup.Namespace = v.(string)

					}

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						siteMeshGroupChoiceInt.SiteMeshGroup.Tenant = v.(string)

					}

				}

			}

			siteMeshGroupIpChoiceTypeFound := false

			if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupIpChoiceTypeFound {

				siteMeshGroupIpChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupIpChoiceInt := &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType_SmConnectionPublicIp{}
					siteMeshGroupIpChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
					s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo.SiteMeshGroupIpChoice = siteMeshGroupIpChoiceInt
				}

			}

			if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupIpChoiceTypeFound {

				siteMeshGroupIpChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupIpChoiceInt := &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType_SmConnectionPvtIp{}
					siteMeshGroupIpChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
					s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo.SiteMeshGroupIpChoice = siteMeshGroupIpChoiceInt
				}

			}

		}

	}

	//software_settings
	if v, ok := d.GetOk("software_settings"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		softwareSettings := &ves_io_schema_views_securemesh_site_v2.SoftwareSettingsType{}
		createSpec.SoftwareSettings = softwareSettings
		for _, set := range sl {
			softwareSettingsMapStrToI := set.(map[string]interface{})

			if v, ok := softwareSettingsMapStrToI["os"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				os := &ves_io_schema_views.OperatingSystemType{}
				softwareSettings.Os = os
				for _, set := range sl {
					osMapStrToI := set.(map[string]interface{})

					operatingSystemVersionChoiceTypeFound := false

					if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

						operatingSystemVersionChoiceTypeFound = true

						if v.(bool) {
							operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
							operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
							os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
						}

					}

					if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

						operatingSystemVersionChoiceTypeFound = true
						operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

						os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

						operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

					}

				}

			}

			if v, ok := softwareSettingsMapStrToI["sw"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				sw := &ves_io_schema_views.VolterraSoftwareType{}
				softwareSettings.Sw = sw
				for _, set := range sl {
					swMapStrToI := set.(map[string]interface{})

					volterraSwVersionChoiceTypeFound := false

					if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

						volterraSwVersionChoiceTypeFound = true

						if v.(bool) {
							volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
							volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
							sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
						}

					}

					if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

						volterraSwVersionChoiceTypeFound = true
						volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

						sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

						volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

					}

				}

			}

		}

	}

	//tunnel_dead_timeout
	if v, ok := d.GetOk("tunnel_dead_timeout"); ok && !isIntfNil(v) {

		createSpec.TunnelDeadTimeout =
			uint32(v.(int))

	}

	//tunnel_type
	if v, ok := d.GetOk("tunnel_type"); ok && !isIntfNil(v) {

		createSpec.TunnelType = ves_io_schema.SiteToSiteTunnelType(ves_io_schema.SiteToSiteTunnelType_value[v.(string)])

	}

	//upgrade_settings
	if v, ok := d.GetOk("upgrade_settings"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		upgradeSettings := &ves_io_schema_views_securemesh_site_v2.UpgradeSettingsType{}
		createSpec.UpgradeSettings = upgradeSettings
		for _, set := range sl {
			upgradeSettingsMapStrToI := set.(map[string]interface{})

			if v, ok := upgradeSettingsMapStrToI["kubernetes_upgrade_drain"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				kubernetesUpgradeDrain := &ves_io_schema_views.KubernetesUpgradeDrain{}
				upgradeSettings.KubernetesUpgradeDrain = kubernetesUpgradeDrain
				for _, set := range sl {
					kubernetesUpgradeDrainMapStrToI := set.(map[string]interface{})

					kubernetesUpgradeDrainEnableChoiceTypeFound := false

					if v, ok := kubernetesUpgradeDrainMapStrToI["disable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

						kubernetesUpgradeDrainEnableChoiceTypeFound = true

						if v.(bool) {
							kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_DisableUpgradeDrain{}
							kubernetesUpgradeDrainEnableChoiceInt.DisableUpgradeDrain = &ves_io_schema.Empty{}
							kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt
						}

					}

					if v, ok := kubernetesUpgradeDrainMapStrToI["enable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

						kubernetesUpgradeDrainEnableChoiceTypeFound = true
						kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_EnableUpgradeDrain{}
						kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain = &ves_io_schema_views.KubernetesUpgradeDrainConfig{}
						kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							drainMaxUnavailableChoiceTypeFound := false

							if v, ok := cs["drain_max_unavailable_node_count"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodeCount = uint32(v.(int))

							}

							if v, ok := cs["drain_max_unavailable_node_percentage"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodePercentage{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodePercentage = uint32(v.(int))

							}

							if v, ok := cs["drain_node_timeout"]; ok && !isIntfNil(v) {

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainNodeTimeout = uint32(v.(int))

							}

							vegaUpgradeModeToggleChoiceTypeFound := false

							if v, ok := cs["disable_vega_upgrade_mode"]; ok && !isIntfNil(v) && !vegaUpgradeModeToggleChoiceTypeFound {

								vegaUpgradeModeToggleChoiceTypeFound = true

								if v.(bool) {
									vegaUpgradeModeToggleChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DisableVegaUpgradeMode{}
									vegaUpgradeModeToggleChoiceInt.DisableVegaUpgradeMode = &ves_io_schema.Empty{}
									kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.VegaUpgradeModeToggleChoice = vegaUpgradeModeToggleChoiceInt
								}

							}

							if v, ok := cs["enable_vega_upgrade_mode"]; ok && !isIntfNil(v) && !vegaUpgradeModeToggleChoiceTypeFound {

								vegaUpgradeModeToggleChoiceTypeFound = true

								if v.(bool) {
									vegaUpgradeModeToggleChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_EnableVegaUpgradeMode{}
									vegaUpgradeModeToggleChoiceInt.EnableVegaUpgradeMode = &ves_io_schema.Empty{}
									kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.VegaUpgradeModeToggleChoice = vegaUpgradeModeToggleChoiceInt
								}

							}

						}

					}

				}

			}

		}

	}

	log.Printf("[DEBUG] Creating Volterra SecuremeshSiteV2 object with struct: %+v", createReq)

	createSecuremeshSiteV2Resp, err := client.CreateObject(context.Background(), ves_io_schema_views_securemesh_site_v2.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating SecuremeshSiteV2: %s", err)
	}
	d.SetId(createSecuremeshSiteV2Resp.GetObjSystemMetadata().GetUid())

	return resourceVolterraSecuremeshSiteV2Read(d, meta)
}

func resourceVolterraSecuremeshSiteV2Read(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_securemesh_site_v2.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] SecuremeshSiteV2 %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra SecuremeshSiteV2 %q: %s", d.Id(), err)
	}
	return setSecuremeshSiteV2Fields(client, d, resp)
}

func setSecuremeshSiteV2Fields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraSecuremeshSiteV2Update updates SecuremeshSiteV2 resource
func resourceVolterraSecuremeshSiteV2Update(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_securemesh_site_v2.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("block_all_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_BlockAllServices{}
			blockedServicesChoiceInt.BlockAllServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		updateSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
				blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
				for i, set := range sl {
					blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
					blockedSeviceMapStrToI := set.(map[string]interface{})

					blockedServicesValueTypeChoiceTypeFound := false

					if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
							blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
							blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
							blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

						blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

					}

				}

			}

		}

	}

	forwardProxyChoiceTypeFound := false

	if v, ok := d.GetOk("active_forward_proxy_policies"); ok && !forwardProxyChoiceTypeFound {

		forwardProxyChoiceTypeFound = true
		forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_ActiveForwardProxyPolicies{}
		forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
		updateSpec.ForwardProxyChoice = forwardProxyChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
				forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
				for i, ps := range sl {

					fppMapToStrVal := ps.(map[string]interface{})
					forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

					if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
						forwardProxyPoliciesInt[i].Name = v.(string)
					}

					if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						forwardProxyPoliciesInt[i].Namespace = v.(string)
					}

					if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						forwardProxyPoliciesInt[i].Tenant = v.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("no_forward_proxy"); ok && !forwardProxyChoiceTypeFound {

		forwardProxyChoiceTypeFound = true

		if v.(bool) {
			forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_NoForwardProxy{}
			forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
			updateSpec.ForwardProxyChoice = forwardProxyChoiceInt
		}

	}

	if v, ok := d.GetOk("load_balancing"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		loadBalancing := &ves_io_schema_views_securemesh_site_v2.LoadBalancingSettingsType{}
		updateSpec.LoadBalancing = loadBalancing
		for _, set := range sl {
			loadBalancingMapStrToI := set.(map[string]interface{})

			if v, ok := loadBalancingMapStrToI["vip_vrrp_mode"]; ok && !isIntfNil(v) {

				loadBalancing.VipVrrpMode = ves_io_schema.VipVrrpType(ves_io_schema.VipVrrpType_value[v.(string)])

			}

		}

	}

	if v, ok := d.GetOk("local_vrf"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		localVrf := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType{}
		updateSpec.LocalVrf = localVrf
		for _, set := range sl {
			localVrfMapStrToI := set.(map[string]interface{})

			sliChoiceTypeFound := false

			if v, ok := localVrfMapStrToI["default_sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true

				if v.(bool) {
					sliChoiceInt := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType_DefaultSliConfig{}
					sliChoiceInt.DefaultSliConfig = &ves_io_schema.Empty{}
					localVrf.SliChoice = sliChoiceInt
				}

			}

			if v, ok := localVrfMapStrToI["sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true
				sliChoiceInt := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType_SliConfig{}
				sliChoiceInt.SliConfig = &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration{}
				localVrf.SliChoice = sliChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sliChoiceInt.SliConfig.Labels = ms
					}

					if v, ok := cs["nameserver"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.Nameserver = v.(string)

					}

					if v, ok := cs["nameserver_v6"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.NameserverV6 = v.(string)

					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_securemesh_site_v2.StaticRoutesListType{}
						sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					staticV6RouteChoiceTypeFound := false

					if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true

						if v.(bool) {
							staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_NoV6StaticRoutes{}
							staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
						}

					}

					if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true
						staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_StaticV6Routes{}
						staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
						sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
								staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					if v, ok := cs["vip"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.Vip = v.(string)

					}

					if v, ok := cs["vip_v6"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.VipV6 = v.(string)

					}

				}

			}

			sloChoiceTypeFound := false

			if v, ok := localVrfMapStrToI["default_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true

				if v.(bool) {
					sloChoiceInt := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType_DefaultConfig{}
					sloChoiceInt.DefaultConfig = &ves_io_schema.Empty{}
					localVrf.SloChoice = sloChoiceInt
				}

			}

			if v, ok := localVrfMapStrToI["slo_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true
				sloChoiceInt := &ves_io_schema_views_securemesh_site_v2.LocalVRFSettingType_SloConfig{}
				sloChoiceInt.SloConfig = &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration{}
				localVrf.SloChoice = sloChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sloChoiceInt.SloConfig.Labels = ms
					}

					if v, ok := cs["nameserver"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.Nameserver = v.(string)

					}

					if v, ok := cs["nameserver_v6"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.NameserverV6 = v.(string)

					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_securemesh_site_v2.StaticRoutesListType{}
						sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					staticV6RouteChoiceTypeFound := false

					if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true

						if v.(bool) {
							staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_NoV6StaticRoutes{}
							staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
						}

					}

					if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true
						staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site_v2.VirtualNetworkConfiguration_StaticV6Routes{}
						staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
						sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
								staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					if v, ok := cs["vip"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.Vip = v.(string)

					}

					if v, ok := cs["vip_v6"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.VipV6 = v.(string)

					}

				}

			}

		}

	}

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		updateSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			updateSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	networkPolicyChoiceTypeFound := false

	if v, ok := d.GetOk("active_enhanced_firewall_policies"); ok && !networkPolicyChoiceTypeFound {

		networkPolicyChoiceTypeFound = true
		networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_ActiveEnhancedFirewallPolicies{}
		networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
		updateSpec.NetworkPolicyChoice = networkPolicyChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
				networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
				for i, ps := range sl {

					efpMapToStrVal := ps.(map[string]interface{})
					enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

					if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
						enhancedFirewallPoliciesInt[i].Name = v.(string)
					}

					if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						enhancedFirewallPoliciesInt[i].Namespace = v.(string)
					}

					if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						enhancedFirewallPoliciesInt[i].Tenant = v.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("no_network_policy"); ok && !networkPolicyChoiceTypeFound {

		networkPolicyChoiceTypeFound = true

		if v.(bool) {
			networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_NoNetworkPolicy{}
			networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
			updateSpec.NetworkPolicyChoice = networkPolicyChoiceInt
		}

	}

	nodeHaChoiceTypeFound := false

	if v, ok := d.GetOk("disable_ha"); ok && !nodeHaChoiceTypeFound {

		nodeHaChoiceTypeFound = true

		if v.(bool) {
			nodeHaChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_DisableHa{}
			nodeHaChoiceInt.DisableHa = &ves_io_schema.Empty{}
			updateSpec.NodeHaChoice = nodeHaChoiceInt
		}

	}

	if v, ok := d.GetOk("enable_ha"); ok && !nodeHaChoiceTypeFound {

		nodeHaChoiceTypeFound = true

		if v.(bool) {
			nodeHaChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_EnableHa{}
			nodeHaChoiceInt.EnableHa = &ves_io_schema.Empty{}
			updateSpec.NodeHaChoice = nodeHaChoiceInt
		}

	}

	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		updateSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

			offlineSurvivabilityModeChoiceTypeFound := false

			if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

			if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

		}

	}

	if v, ok := d.GetOk("performance_enhancement_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
		updateSpec.PerformanceEnhancementMode = performanceEnhancementMode
		for _, set := range sl {
			performanceEnhancementModeMapStrToI := set.(map[string]interface{})

			perfModeChoiceTypeFound := false

			if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

				perfModeChoiceTypeFound = true
				perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
				perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
				performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					perfModeChoiceTypeFound := false

					if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
							perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
							perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
						}

					}

					if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
							perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
							perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
						}

					}

				}

			}

			if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

				perfModeChoiceTypeFound = true

				if v.(bool) {
					perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
					perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
					performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
				}

			}

		}

	}

	providerChoiceTypeFound := false

	if v, ok := d.GetOk("aws"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_Aws{}
		providerChoiceInt.Aws = &ves_io_schema_views_securemesh_site_v2.AWSProviderType{}
		updateSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.AWSProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Aws.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("azure"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_Azure{}
		providerChoiceInt.Azure = &ves_io_schema_views_securemesh_site_v2.AzureProviderType{}
		updateSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.AzureProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Azure.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("baremetal"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_Baremetal{}
		providerChoiceInt.Baremetal = &ves_io_schema_views_securemesh_site_v2.BaremetalProviderType{}
		updateSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.BaremetalProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Baremetal.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("gcp"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_Gcp{}
		providerChoiceInt.Gcp = &ves_io_schema_views_securemesh_site_v2.GCPProviderType{}
		updateSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.GCPProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Gcp.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("kvm"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_Kvm{}
		providerChoiceInt.Kvm = &ves_io_schema_views_securemesh_site_v2.KVMProviderType{}
		updateSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.KVMProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Kvm.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("oci"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_Oci{}
		providerChoiceInt.Oci = &ves_io_schema_views_securemesh_site_v2.OCIProviderType{}
		updateSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.OCIProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Oci.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("rseries"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_Rseries{}
		providerChoiceInt.Rseries = &ves_io_schema_views_securemesh_site_v2.RSeriesProviderType{}
		updateSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.RSeriesProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Rseries.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("vmware"); ok && !providerChoiceTypeFound {

		providerChoiceTypeFound = true
		providerChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_Vmware{}
		providerChoiceInt.Vmware = &ves_io_schema_views_securemesh_site_v2.VMwareProviderType{}
		updateSpec.ProviderChoice = providerChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			orchestrationChoiceTypeFound := false

			if v, ok := cs["not_managed"]; ok && !isIntfNil(v) && !orchestrationChoiceTypeFound {

				orchestrationChoiceTypeFound = true
				orchestrationChoiceInt := &ves_io_schema_views_securemesh_site_v2.VMwareProviderType_NotManaged{}
				orchestrationChoiceInt.NotManaged = &ves_io_schema_views_securemesh_site_v2.NodeList{}
				providerChoiceInt.Vmware.OrchestrationChoice = orchestrationChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["node_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						nodeList := make([]*ves_io_schema_views_securemesh_site_v2.Node, len(sl))
						orchestrationChoiceInt.NotManaged.NodeList = nodeList
						for i, set := range sl {
							nodeList[i] = &ves_io_schema_views_securemesh_site_v2.Node{}
							nodeListMapStrToI := set.(map[string]interface{})

							if w, ok := nodeListMapStrToI["hostname"]; ok && !isIntfNil(w) {
								nodeList[i].Hostname = w.(string)
							}

							if v, ok := nodeListMapStrToI["interface_list"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								interfaceList := make([]*ves_io_schema_views_securemesh_site_v2.Interface, len(sl))
								nodeList[i].InterfaceList = interfaceList
								for i, set := range sl {
									interfaceList[i] = &ves_io_schema_views_securemesh_site_v2.Interface{}
									interfaceListMapStrToI := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv4_address"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv4Address{}
											addressChoiceInt.NoIpv4Address = &ves_io_schema.Empty{}
											interfaceList[i].AddressChoice = addressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										interfaceList[i].AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DefaultGw = v.(string)

											}

											if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.DnsServer = v.(string)

											}

											if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

												addressChoiceInt.StaticIp.IpAddress = v.(string)

											}

										}

									}

									if w, ok := interfaceListMapStrToI["description"]; ok && !isIntfNil(w) {
										interfaceList[i].Description = w.(string)
									}

									interfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["bond_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_BondInterface{}
										interfaceChoiceInt.BondInterface = &ves_io_schema_fleet.FleetBondDeviceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["devices"]; ok && !isIntfNil(v) {

												ls := make([]string, len(v.([]interface{})))
												for i, v := range v.([]interface{}) {
													ls[i] = v.(string)
												}
												interfaceChoiceInt.BondInterface.Devices = ls

											}

											lacpChoiceTypeFound := false

											if v, ok := cs["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true

												if v.(bool) {
													lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
													lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
													interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt
												}

											}

											if v, ok := cs["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

												lacpChoiceTypeFound = true
												lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
												lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
												interfaceChoiceInt.BondInterface.LacpChoice = lacpChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["rate"]; ok && !isIntfNil(v) {

														lacpChoiceInt.Lacp.Rate = uint32(v.(int))

													}

												}

											}

											if v, ok := cs["link_polling_interval"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkPollingInterval = uint32(v.(int))

											}

											if v, ok := cs["link_up_delay"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.LinkUpDelay = uint32(v.(int))

											}

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.BondInterface.Name = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_EthernetInterface{}
										interfaceChoiceInt.EthernetInterface = &ves_io_schema_views_securemesh_site_v2.EthernetInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Device = v.(string)

											}

											if v, ok := cs["mac"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.EthernetInterface.Mac = v.(string)

											}

										}

									}

									if v, ok := interfaceListMapStrToI["vlan_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

										interfaceChoiceTypeFound = true
										interfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_VlanInterface{}
										interfaceChoiceInt.VlanInterface = &ves_io_schema_views_securemesh_site_v2.VlanInterfaceType{}
										interfaceList[i].InterfaceChoice = interfaceChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["device"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.Device = v.(string)

											}

											if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) {

												interfaceChoiceInt.VlanInterface.VlanId = uint32(v.(int))

											}

										}

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

																		dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := interfaceListMapStrToI["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceList[i].Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["is_management"]; ok && !isIntfNil(w) {
										interfaceList[i].IsManagement = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["is_primary"]; ok && !isIntfNil(w) {
										interfaceList[i].IsPrimary = w.(bool)
									}

									if w, ok := interfaceListMapStrToI["labels"]; ok && !isIntfNil(w) {
										ms := map[string]string{}
										for k, v := range w.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										interfaceList[i].Labels = ms
									}

									monitoringChoiceTypeFound := false

									if _, ok := interfaceListMapStrToI["monitor"]; ok && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_Monitor{}
										monitoringChoiceInt.Monitor = &ves_io_schema_network_interface.LinkQualityMonitorConfig{}
										interfaceList[i].MonitoringChoice = monitoringChoiceInt

									}

									if v, ok := interfaceListMapStrToI["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceList[i].MonitoringChoice = monitoringChoiceInt
										}

									}

									if w, ok := interfaceListMapStrToI["mtu"]; ok && !isIntfNil(w) {
										interfaceList[i].Mtu = uint32(w.(int))
									}

									if w, ok := interfaceListMapStrToI["name"]; ok && !isIntfNil(w) {
										interfaceList[i].Name = w.(string)
									}

									if v, ok := interfaceListMapStrToI["network_option"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										networkOption := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType{}
										interfaceList[i].NetworkOption = networkOption
										for _, set := range sl {
											networkOptionMapStrToI := set.(map[string]interface{})

											networkChoiceTypeFound := false

											if v, ok := networkOptionMapStrToI["segment_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true
												networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SegmentNetwork{}
												networkChoiceInt.SegmentNetwork = &ves_io_schema_views.ObjectRefType{}
												networkOption.NetworkChoice = networkChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["name"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Name = v.(string)

													}

													if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Namespace = v.(string)

													}

													if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

														networkChoiceInt.SegmentNetwork.Tenant = v.(string)

													}

												}

											}

											if v, ok := networkOptionMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalInsideNetwork{}
													networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

											if v, ok := networkOptionMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

												networkChoiceTypeFound = true

												if v.(bool) {
													networkChoiceInt := &ves_io_schema_views_securemesh_site_v2.NetworkSelectType_SiteLocalNetwork{}
													networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
													networkOption.NetworkChoice = networkChoiceInt
												}

											}

										}

									}

									if w, ok := interfaceListMapStrToI["priority"]; ok && !isIntfNil(w) {
										interfaceList[i].Priority = uint32(w.(int))
									}

									siteToSiteConnectivityInterfaceChoiceTypeFound := false

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceDisabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

									if v, ok := interfaceListMapStrToI["site_to_site_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !siteToSiteConnectivityInterfaceChoiceTypeFound {

										siteToSiteConnectivityInterfaceChoiceTypeFound = true

										if v.(bool) {
											siteToSiteConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site_v2.Interface_SiteToSiteConnectivityInterfaceEnabled{}
											siteToSiteConnectivityInterfaceChoiceInt.SiteToSiteConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
											interfaceList[i].SiteToSiteConnectivityInterfaceChoice = siteToSiteConnectivityInterfaceChoiceInt
										}

									}

								}

							}

							if w, ok := nodeListMapStrToI["public_ip"]; ok && !isIntfNil(w) {
								nodeList[i].PublicIp = w.(string)
							}

							if w, ok := nodeListMapStrToI["type"]; ok && !isIntfNil(w) {
								nodeList[i].Type = w.(string)
							}

						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("re_select"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		reSelect := &ves_io_schema_views.RegionalEdgeSelection{}
		updateSpec.ReSelect = reSelect
		for _, set := range sl {
			reSelectMapStrToI := set.(map[string]interface{})

			reSelectionChoiceTypeFound := false

			if v, ok := reSelectMapStrToI["geo_proximity"]; ok && !isIntfNil(v) && !reSelectionChoiceTypeFound {

				reSelectionChoiceTypeFound = true

				if v.(bool) {
					reSelectionChoiceInt := &ves_io_schema_views.RegionalEdgeSelection_GeoProximity{}
					reSelectionChoiceInt.GeoProximity = &ves_io_schema.Empty{}
					reSelect.ReSelectionChoice = reSelectionChoiceInt
				}

			}

			if v, ok := reSelectMapStrToI["specific_geography"]; ok && !isIntfNil(v) && !reSelectionChoiceTypeFound {

				reSelectionChoiceTypeFound = true
				reSelectionChoiceInt := &ves_io_schema_views.RegionalEdgeSelection_SpecificGeography{}

				reSelect.ReSelectionChoice = reSelectionChoiceInt

				reSelectionChoiceInt.SpecificGeography = v.(string)

			}

			if v, ok := reSelectMapStrToI["specific_re"]; ok && !isIntfNil(v) && !reSelectionChoiceTypeFound {

				reSelectionChoiceTypeFound = true
				reSelectionChoiceInt := &ves_io_schema_views.RegionalEdgeSelection_SpecificRe{}
				reSelectionChoiceInt.SpecificRe = &ves_io_schema_views.SpecificRE{}
				reSelect.ReSelectionChoice = reSelectionChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["backup_re"]; ok && !isIntfNil(v) {

						reSelectionChoiceInt.SpecificRe.BackupRe = v.(string)

					}

					if v, ok := cs["primary_re"]; ok && !isIntfNil(v) {

						reSelectionChoiceInt.SpecificRe.PrimaryRe = v.(string)

					}

				}

			}

		}

	}

	s2SConnectivitySliChoiceTypeFound := false

	if v, ok := d.GetOk("dc_cluster_group_sli"); ok && !s2SConnectivitySliChoiceTypeFound {

		s2SConnectivitySliChoiceTypeFound = true
		s2SConnectivitySliChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_DcClusterGroupSli{}
		s2SConnectivitySliChoiceInt.DcClusterGroupSli = &ves_io_schema_views.ObjectRefType{}
		updateSpec.S2SConnectivitySliChoice = s2SConnectivitySliChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				s2SConnectivitySliChoiceInt.DcClusterGroupSli.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				s2SConnectivitySliChoiceInt.DcClusterGroupSli.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				s2SConnectivitySliChoiceInt.DcClusterGroupSli.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("no_s2s_connectivity_sli"); ok && !s2SConnectivitySliChoiceTypeFound {

		s2SConnectivitySliChoiceTypeFound = true

		if v.(bool) {
			s2SConnectivitySliChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_NoS2SConnectivitySli{}
			s2SConnectivitySliChoiceInt.NoS2SConnectivitySli = &ves_io_schema.Empty{}
			updateSpec.S2SConnectivitySliChoice = s2SConnectivitySliChoiceInt
		}

	}

	s2SConnectivitySloChoiceTypeFound := false

	if v, ok := d.GetOk("dc_cluster_group_slo"); ok && !s2SConnectivitySloChoiceTypeFound {

		s2SConnectivitySloChoiceTypeFound = true
		s2SConnectivitySloChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_DcClusterGroupSlo{}
		s2SConnectivitySloChoiceInt.DcClusterGroupSlo = &ves_io_schema_views.ObjectRefType{}
		updateSpec.S2SConnectivitySloChoice = s2SConnectivitySloChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				s2SConnectivitySloChoiceInt.DcClusterGroupSlo.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				s2SConnectivitySloChoiceInt.DcClusterGroupSlo.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				s2SConnectivitySloChoiceInt.DcClusterGroupSlo.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("no_s2s_connectivity_slo"); ok && !s2SConnectivitySloChoiceTypeFound {

		s2SConnectivitySloChoiceTypeFound = true

		if v.(bool) {
			s2SConnectivitySloChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_NoS2SConnectivitySlo{}
			s2SConnectivitySloChoiceInt.NoS2SConnectivitySlo = &ves_io_schema.Empty{}
			updateSpec.S2SConnectivitySloChoice = s2SConnectivitySloChoiceInt
		}

	}

	if v, ok := d.GetOk("site_mesh_group_on_slo"); ok && !s2SConnectivitySloChoiceTypeFound {

		s2SConnectivitySloChoiceTypeFound = true
		s2SConnectivitySloChoiceInt := &ves_io_schema_views_securemesh_site_v2.ReplaceSpecType_SiteMeshGroupOnSlo{}
		s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo = &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType{}
		updateSpec.S2SConnectivitySloChoice = s2SConnectivitySloChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			siteMeshGroupChoiceTypeFound := false

			if v, ok := cs["no_site_mesh_group"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType_NoSiteMeshGroup{}
					siteMeshGroupChoiceInt.NoSiteMeshGroup = &ves_io_schema.Empty{}
					s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			if v, ok := cs["site_mesh_group"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true
				siteMeshGroupChoiceInt := &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType_SiteMeshGroup{}
				siteMeshGroupChoiceInt.SiteMeshGroup = &ves_io_schema_views.ObjectRefType{}
				s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo.SiteMeshGroupChoice = siteMeshGroupChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						siteMeshGroupChoiceInt.SiteMeshGroup.Name = v.(string)

					}

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						siteMeshGroupChoiceInt.SiteMeshGroup.Namespace = v.(string)

					}

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						siteMeshGroupChoiceInt.SiteMeshGroup.Tenant = v.(string)

					}

				}

			}

			siteMeshGroupIpChoiceTypeFound := false

			if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupIpChoiceTypeFound {

				siteMeshGroupIpChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupIpChoiceInt := &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType_SmConnectionPublicIp{}
					siteMeshGroupIpChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
					s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo.SiteMeshGroupIpChoice = siteMeshGroupIpChoiceInt
				}

			}

			if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupIpChoiceTypeFound {

				siteMeshGroupIpChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupIpChoiceInt := &ves_io_schema_views_securemesh_site_v2.SiteMeshGroupType_SmConnectionPvtIp{}
					siteMeshGroupIpChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
					s2SConnectivitySloChoiceInt.SiteMeshGroupOnSlo.SiteMeshGroupIpChoice = siteMeshGroupIpChoiceInt
				}

			}

		}

	}

	if v, ok := d.GetOk("software_settings"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		softwareSettings := &ves_io_schema_views_securemesh_site_v2.SoftwareSettingsType{}
		updateSpec.SoftwareSettings = softwareSettings
		for _, set := range sl {
			softwareSettingsMapStrToI := set.(map[string]interface{})

			if v, ok := softwareSettingsMapStrToI["os"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				os := &ves_io_schema_views.OperatingSystemType{}
				softwareSettings.Os = os
				for _, set := range sl {
					osMapStrToI := set.(map[string]interface{})

					operatingSystemVersionChoiceTypeFound := false

					if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

						operatingSystemVersionChoiceTypeFound = true

						if v.(bool) {
							operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
							operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
							os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
						}

					}

					if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

						operatingSystemVersionChoiceTypeFound = true
						operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

						os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

						operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

					}

				}

			}

			if v, ok := softwareSettingsMapStrToI["sw"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				sw := &ves_io_schema_views.VolterraSoftwareType{}
				softwareSettings.Sw = sw
				for _, set := range sl {
					swMapStrToI := set.(map[string]interface{})

					volterraSwVersionChoiceTypeFound := false

					if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

						volterraSwVersionChoiceTypeFound = true

						if v.(bool) {
							volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
							volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
							sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
						}

					}

					if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

						volterraSwVersionChoiceTypeFound = true
						volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

						sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

						volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("tunnel_dead_timeout"); ok && !isIntfNil(v) {

		updateSpec.TunnelDeadTimeout =
			uint32(v.(int))

	}

	if v, ok := d.GetOk("tunnel_type"); ok && !isIntfNil(v) {

		updateSpec.TunnelType = ves_io_schema.SiteToSiteTunnelType(ves_io_schema.SiteToSiteTunnelType_value[v.(string)])

	}

	if v, ok := d.GetOk("upgrade_settings"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		upgradeSettings := &ves_io_schema_views_securemesh_site_v2.UpgradeSettingsType{}
		updateSpec.UpgradeSettings = upgradeSettings
		for _, set := range sl {
			upgradeSettingsMapStrToI := set.(map[string]interface{})

			if v, ok := upgradeSettingsMapStrToI["kubernetes_upgrade_drain"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				kubernetesUpgradeDrain := &ves_io_schema_views.KubernetesUpgradeDrain{}
				upgradeSettings.KubernetesUpgradeDrain = kubernetesUpgradeDrain
				for _, set := range sl {
					kubernetesUpgradeDrainMapStrToI := set.(map[string]interface{})

					kubernetesUpgradeDrainEnableChoiceTypeFound := false

					if v, ok := kubernetesUpgradeDrainMapStrToI["disable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

						kubernetesUpgradeDrainEnableChoiceTypeFound = true

						if v.(bool) {
							kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_DisableUpgradeDrain{}
							kubernetesUpgradeDrainEnableChoiceInt.DisableUpgradeDrain = &ves_io_schema.Empty{}
							kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt
						}

					}

					if v, ok := kubernetesUpgradeDrainMapStrToI["enable_upgrade_drain"]; ok && !isIntfNil(v) && !kubernetesUpgradeDrainEnableChoiceTypeFound {

						kubernetesUpgradeDrainEnableChoiceTypeFound = true
						kubernetesUpgradeDrainEnableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrain_EnableUpgradeDrain{}
						kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain = &ves_io_schema_views.KubernetesUpgradeDrainConfig{}
						kubernetesUpgradeDrain.KubernetesUpgradeDrainEnableChoice = kubernetesUpgradeDrainEnableChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							drainMaxUnavailableChoiceTypeFound := false

							if v, ok := cs["drain_max_unavailable_node_count"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodeCount = uint32(v.(int))

							}

							if v, ok := cs["drain_max_unavailable_node_percentage"]; ok && !isIntfNil(v) && !drainMaxUnavailableChoiceTypeFound {

								drainMaxUnavailableChoiceTypeFound = true
								drainMaxUnavailableChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodePercentage{}

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainMaxUnavailableChoice = drainMaxUnavailableChoiceInt

								drainMaxUnavailableChoiceInt.DrainMaxUnavailableNodePercentage = uint32(v.(int))

							}

							if v, ok := cs["drain_node_timeout"]; ok && !isIntfNil(v) {

								kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.DrainNodeTimeout = uint32(v.(int))

							}

							vegaUpgradeModeToggleChoiceTypeFound := false

							if v, ok := cs["disable_vega_upgrade_mode"]; ok && !isIntfNil(v) && !vegaUpgradeModeToggleChoiceTypeFound {

								vegaUpgradeModeToggleChoiceTypeFound = true

								if v.(bool) {
									vegaUpgradeModeToggleChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_DisableVegaUpgradeMode{}
									vegaUpgradeModeToggleChoiceInt.DisableVegaUpgradeMode = &ves_io_schema.Empty{}
									kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.VegaUpgradeModeToggleChoice = vegaUpgradeModeToggleChoiceInt
								}

							}

							if v, ok := cs["enable_vega_upgrade_mode"]; ok && !isIntfNil(v) && !vegaUpgradeModeToggleChoiceTypeFound {

								vegaUpgradeModeToggleChoiceTypeFound = true

								if v.(bool) {
									vegaUpgradeModeToggleChoiceInt := &ves_io_schema_views.KubernetesUpgradeDrainConfig_EnableVegaUpgradeMode{}
									vegaUpgradeModeToggleChoiceInt.EnableVegaUpgradeMode = &ves_io_schema.Empty{}
									kubernetesUpgradeDrainEnableChoiceInt.EnableUpgradeDrain.VegaUpgradeModeToggleChoice = vegaUpgradeModeToggleChoiceInt
								}

							}

						}

					}

				}

			}

		}

	}

	log.Printf("[DEBUG] Updating Volterra SecuremeshSiteV2 obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_securemesh_site_v2.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating SecuremeshSiteV2: %s", err)
	}

	return resourceVolterraSecuremeshSiteV2Read(d, meta)
}

func resourceVolterraSecuremeshSiteV2Delete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_securemesh_site_v2.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] SecuremeshSiteV2 %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra SecuremeshSiteV2 before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra SecuremeshSiteV2 obj with name %+v in namespace %+v", name, namespace)
	return client.DeleteObject(context.Background(), ves_io_schema_views_securemesh_site_v2.ObjectType, namespace, name)
}
