//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_network_interface "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_securemesh_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/securemesh_site"
	ves_io_schema_virtual_network "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_network"
)

// resourceVolterraSecuremeshSite is implementation of Volterra's SecuremeshSite resources
func resourceVolterraSecuremeshSite() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraSecuremeshSiteCreate,
		Read:   resourceVolterraSecuremeshSiteRead,
		Update: resourceVolterraSecuremeshSiteUpdate,
		Delete: resourceVolterraSecuremeshSiteDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"address": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"blocked_services": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"blocked_sevice": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ssh": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"web_user_interface": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"network_type": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"default_blocked_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"bond_device_list": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bond_devices": {

							Type:     schema.TypeList,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"devices": {

										Type: schema.TypeList,

										Required: true,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},

									"active_backup": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"lacp": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"rate": {
													Type:     schema.TypeInt,
													Optional: true,
												},
											},
										},
									},

									"link_polling_interval": {
										Type:     schema.TypeInt,
										Required: true,
									},

									"link_up_delay": {
										Type:     schema.TypeInt,
										Required: true,
									},

									"name": {
										Type:     schema.TypeString,
										Required: true,
									},
								},
							},
						},
					},
				},
			},

			"no_bond_devices": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"coordinates": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"latitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},

						"longitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},
					},
				},
			},

			"log_receiver": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"logs_streaming_disabled": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"master_node_configuration": {

				Type:     schema.TypeList,
				Required: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Required: true,
						},

						"public_ip": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"custom_network_config": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"bgp_peer_address": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"bgp_router_id": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"global_network_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"disable_forward_proxy": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"enable_forward_proxy": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"connection_timeout": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"max_connect_attempts": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"no_interception": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"tls_intercept": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"enable_for_all_domains": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"policy": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interception_rules": {

																						Type:     schema.TypeList,
																						Required: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"domain_match": {

																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"exact_value": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"regex_value": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"suffix_value": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"disable_interception": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"enable_interception": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"custom_certificate": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"certificate_url": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"description": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"custom_hash_algorithms": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"hash_algorithms": {

																									Type: schema.TypeList,

																									Required: true,
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																							},
																						},
																					},

																					"disable_ocsp_stapling": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"use_system_defaults": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"private_key": {

																						Type:     schema.TypeSet,
																						Required: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"blindfold_secret_info_internal": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"secret_encoding_type": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"blindfold_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"store_provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"clear_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"provider": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"url": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},

																								"vault_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"key": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"location": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"provider": {
																												Type:     schema.TypeString,
																												Required: true,
																											},

																											"secret_encoding": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"version": {
																												Type:     schema.TypeInt,
																												Optional: true,
																											},
																										},
																									},
																								},

																								"wingman_secret_info": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"name": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"volterra_certificate": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"trusted_ca_url": {

																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"volterra_trusted_ca": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},
																	},
																},
															},

															"white_listed_ports": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeInt,
																},
															},

															"white_listed_prefixes": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"default_interface_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"interface_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"interfaces": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"dc_cluster_group_connectivity_interface_disabled": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"dc_cluster_group_connectivity_interface_enabled": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"description": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"dedicated_interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"device": {
																Type:     schema.TypeString,
																Required: true,
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"is_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"not_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"dedicated_management_interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"device": {
																Type:     schema.TypeString,
																Required: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"ethernet_interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"device": {
																Type:     schema.TypeString,
																Required: true,
															},

															"ipv6_auto_config": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"host": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"router": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"stateful": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"dhcp_networks": {

																									Type:     schema.TypeList,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"network_prefix": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"network_prefix_allocator": {

																												Type:     schema.TypeSet,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"name": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																														"namespace": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																														"tenant": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},

																											"pools": {

																												Type:     schema.TypeList,
																												Optional: true,
																												Elem: &schema.Resource{
																													Schema: map[string]*schema.Schema{

																														"end_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},

																														"exclude": {
																															Type:     schema.TypeBool,
																															Optional: true,
																														},

																														"start_ip": {
																															Type:     schema.TypeString,
																															Optional: true,
																														},
																													},
																												},
																											},
																										},
																									},
																								},

																								"fixed_ip_map": {
																									Type:     schema.TypeMap,
																									Optional: true,
																								},

																								"automatic_from_end": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"automatic_from_start": {

																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"interface_ip_map": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"interface_ip_map": {
																												Type:     schema.TypeMap,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},

																					"dns_config": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"configured_list": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"dns_list": {

																												Type: schema.TypeList,

																												Required: true,
																												Elem: &schema.Schema{
																													Type: schema.TypeString,
																												},
																											},
																										},
																									},
																								},

																								"local_dns": {

																									Type:     schema.TypeSet,
																									Optional: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"configured_address": {

																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"first_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},

																											"last_address": {

																												Type:     schema.TypeBool,
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"monitor": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{},
																},
															},

															"monitor_disabled": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"inside_network": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_fabric_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_inside_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"srv6_network": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"storage_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},

															"is_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"not_primary": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"priority": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"untagged": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"vlan_id": {

																Type:     schema.TypeInt,
																Optional: true,
															},
														},
													},
												},

												"loopback_interface": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"dhcp_client": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"dhcp_server": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"dhcp_networks": {

																			Type:     schema.TypeList,
																			Required: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"dns_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"same_as_dgw": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"dgw_address": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"first_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"last_address": {

																						Type:     schema.TypeBool,
																						Optional: true,
																					},

																					"network_prefix": {

																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"pool_settings": {
																						Type:     schema.TypeString,
																						Required: true,
																					},

																					"pools": {

																						Type:     schema.TypeList,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"end_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},

																								"exclude": {
																									Type:     schema.TypeBool,
																									Optional: true,
																								},

																								"start_ip": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"dhcp_option82_tag": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"fixed_ip_map": {
																			Type:     schema.TypeMap,
																			Optional: true,
																		},

																		"automatic_from_end": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"automatic_from_start": {

																			Type:     schema.TypeBool,
																			Optional: true,
																		},

																		"interface_ip_map": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {
																						Type:     schema.TypeMap,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"static_ip": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"device": {
																Type:     schema.TypeString,
																Required: true,
															},

															"no_ipv6_address": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"static_ipv6_address": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"cluster_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interface_ip_map": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Required: true,
																								},
																								"value": {
																									Type:     schema.TypeSet,
																									Required: true,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"default_gw": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"dns_server": {
																												Type:     schema.TypeString,
																												Optional: true,
																											},

																											"ip_address": {
																												Type:     schema.TypeString,
																												Required: true,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"fleet_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"network_prefix_allocator": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"name": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"namespace": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																								"tenant": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"node_static_ip": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"default_gw": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"dns_server": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},

																					"ip_address": {
																						Type:     schema.TypeString,
																						Required: true,
																					},
																				},
																			},
																		},
																	},
																},
															},

															"mtu": {
																Type:     schema.TypeInt,
																Optional: true,
															},

															"ip_fabric_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_inside_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"site_local_network": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"cluster": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"node": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"labels": {
													Type:     schema.TypeMap,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_enhanced_firewall_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enhanced_firewall_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"default_sli_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sli_config": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dc_cluster_group": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"no_dc_cluster_group": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"dc_cluster_group_interface": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"nameserver": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"no_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"no_v6_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_v6_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"vip": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"vip_v6": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"default_config": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"slo_config": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dc_cluster_group": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"no_dc_cluster_group": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"dc_cluster_group_interface": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"nameserver": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"no_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"no_v6_static_routes": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"static_v6_routes": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"static_routes": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"ip_prefixes": {

																Type: schema.TypeList,

																Required: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"default_gateway": {

																Type:     schema.TypeBool,
																Optional: true,
															},

															"interface": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"ip_address": {

																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"vip": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"vip_v6": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"tunnel_dead_timeout": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"vip_vrrp_mode": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"default_network_config": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"offline_survivability_mode": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"enable_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"os": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_os_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"operating_system_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"performance_enhancement_mode": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"perf_mode_l3_enhanced": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"jumbo": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"no_jumbo": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"perf_mode_l7_enhanced": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"sw": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_sw_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"volterra_software_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"volterra_certified_hw": {
				Type:     schema.TypeString,
				Required: true,
			},

			"worker_nodes": {

				Type: schema.TypeList,

				Optional: true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
		},
	}
}

// resourceVolterraSecuremeshSiteCreate creates SecuremeshSite resource
func resourceVolterraSecuremeshSiteCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_securemesh_site.CreateSpecType{}
	createReq := &ves_io_schema_views_securemesh_site.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//address
	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		createSpec.Address =
			v.(string)

	}

	//blocked_services_choice

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_securemesh_site.CreateSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		createSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
				blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
				for i, set := range sl {
					blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
					blockedSeviceMapStrToI := set.(map[string]interface{})

					blockedServicesValueTypeChoiceTypeFound := false

					if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
							blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
							blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
							blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

						blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_securemesh_site.CreateSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	//bond_choice

	bondChoiceTypeFound := false

	if v, ok := d.GetOk("bond_device_list"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true
		bondChoiceInt := &ves_io_schema_views_securemesh_site.CreateSpecType_BondDeviceList{}
		bondChoiceInt.BondDeviceList = &ves_io_schema_fleet.FleetBondDevicesListType{}
		createSpec.BondChoice = bondChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bond_devices"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				bondDevices := make([]*ves_io_schema_fleet.FleetBondDeviceType, len(sl))
				bondChoiceInt.BondDeviceList.BondDevices = bondDevices
				for i, set := range sl {
					bondDevices[i] = &ves_io_schema_fleet.FleetBondDeviceType{}
					bondDevicesMapStrToI := set.(map[string]interface{})

					if w, ok := bondDevicesMapStrToI["devices"]; ok && !isIntfNil(w) {
						ls := make([]string, len(w.([]interface{})))
						for i, v := range w.([]interface{}) {
							ls[i] = v.(string)
						}
						bondDevices[i].Devices = ls
					}

					lacpChoiceTypeFound := false

					if v, ok := bondDevicesMapStrToI["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

						lacpChoiceTypeFound = true

						if v.(bool) {
							lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
							lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
							bondDevices[i].LacpChoice = lacpChoiceInt
						}

					}

					if v, ok := bondDevicesMapStrToI["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

						lacpChoiceTypeFound = true
						lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
						lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
						bondDevices[i].LacpChoice = lacpChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["rate"]; ok && !isIntfNil(v) {

								lacpChoiceInt.Lacp.Rate = uint32(v.(int))

							}

						}

					}

					if w, ok := bondDevicesMapStrToI["link_polling_interval"]; ok && !isIntfNil(w) {
						bondDevices[i].LinkPollingInterval = uint32(w.(int))
					}

					if w, ok := bondDevicesMapStrToI["link_up_delay"]; ok && !isIntfNil(w) {
						bondDevices[i].LinkUpDelay = uint32(w.(int))
					}

					if w, ok := bondDevicesMapStrToI["name"]; ok && !isIntfNil(w) {
						bondDevices[i].Name = w.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("no_bond_devices"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true

		if v.(bool) {
			bondChoiceInt := &ves_io_schema_views_securemesh_site.CreateSpecType_NoBondDevices{}
			bondChoiceInt.NoBondDevices = &ves_io_schema.Empty{}
			createSpec.BondChoice = bondChoiceInt
		}

	}

	//coordinates
	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		coordinates := &ves_io_schema_site.Coordinates{}
		createSpec.Coordinates = coordinates
		for _, set := range sl {
			coordinatesMapStrToI := set.(map[string]interface{})

			if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
				coordinates.Latitude = float32(w.(float64))
			}

			if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
				coordinates.Longitude = float32(w.(float64))
			}

		}

	}

	//logs_receiver_choice

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_securemesh_site.CreateSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		createSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_securemesh_site.CreateSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			createSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	//master_node_configuration
	if v, ok := d.GetOk("master_node_configuration"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		masterNodeConfiguration := make([]*ves_io_schema_views.MasterNode, len(sl))
		createSpec.MasterNodeConfiguration = masterNodeConfiguration
		for i, set := range sl {
			masterNodeConfiguration[i] = &ves_io_schema_views.MasterNode{}
			masterNodeConfigurationMapStrToI := set.(map[string]interface{})

			if w, ok := masterNodeConfigurationMapStrToI["name"]; ok && !isIntfNil(w) {
				masterNodeConfiguration[i].Name = w.(string)
			}

			if w, ok := masterNodeConfigurationMapStrToI["public_ip"]; ok && !isIntfNil(w) {
				masterNodeConfiguration[i].PublicIp = w.(string)
			}

		}

	}

	//network_cfg_choice

	networkCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true
		networkCfgChoiceInt := &ves_io_schema_views_securemesh_site.CreateSpecType_CustomNetworkConfig{}
		networkCfgChoiceInt.CustomNetworkConfig = &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration{}
		createSpec.NetworkCfgChoice = networkCfgChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bgp_peer_address"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.BgpPeerAddress = v.(string)

			}

			if v, ok := cs["bgp_router_id"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.BgpRouterId = v.(string)

			}

			forwardProxyChoiceTypeFound := false

			if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true
				forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_ActiveForwardProxyPolicies{}
				forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
						for i, ps := range sl {

							fppMapToStrVal := ps.(map[string]interface{})
							forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Name = v.(string)
							}

							if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_ForwardProxyAllowAll{}
					forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_NoForwardProxy{}
					forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			globalNetworkChoiceTypeFound := false

			if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true
				globalNetworkChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_GlobalNetworkList{}
				globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
				networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
						globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
						for i, set := range sl {
							globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
							globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

							connectionChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
								connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
								connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							forwardProxyChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true

								if v.(bool) {
									forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
									forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
									globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true
								forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
								forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
								globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

									}

									if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

									}

									tlsInterceptionChoiceTypeFound := false

									if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true

										if v.(bool) {
											tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
											tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
											forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
										}

									}

									if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true
										tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
										tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
										forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											interceptionPolicyChoiceTypeFound := false

											if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true

												if v.(bool) {
													interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
													interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
												}

											}

											if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true
												interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
												interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
												tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
														interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
														for i, set := range sl {
															interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
															interceptionRulesMapStrToI := set.(map[string]interface{})

															if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																domainMatch := &ves_io_schema.DomainType{}
																interceptionRules[i].DomainMatch = domainMatch
																for _, set := range sl {
																	domainMatchMapStrToI := set.(map[string]interface{})

																	domainChoiceTypeFound := false

																	if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.ExactValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.RegexValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.SuffixValue = v.(string)

																	}

																}

															}

															enableDisableChoiceTypeFound := false

															if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																	enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

															if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																	enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

														}

													}

												}

											}

											signingCertChoiceTypeFound := false

											if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true
												signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
												signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
												tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.Description = v.(string)

													}

													ocspStaplingChoiceTypeFound := false

													if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
														ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																for _, j := range v.([]interface{}) {
																	hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																}
																ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

															}

														}

													}

													if v, ok := cs["disable_ocsp_stapling"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														_ = v
													}

													if v, ok := cs["use_system_defaults"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														_ = v
													}

													if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														privateKey := &ves_io_schema.SecretType{}
														signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
														for _, set := range sl {
															privateKeyMapStrToI := set.(map[string]interface{})

															if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

												}

											}

											if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true

												if v.(bool) {
													signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
													signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
												}

											}

											trustedCaChoiceTypeFound := false

											if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true
												trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

												tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

												trustedCaChoiceInt.TrustedCaUrl = v.(string)

											}

											if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true

												if v.(bool) {
													trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
													trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
												}

											}

										}

									}

									if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

										ls := make([]uint32, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = uint32(v.(int))
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

									}

									if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

										ls := make([]string, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = v.(string)
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true

				if v.(bool) {
					globalNetworkChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_NoGlobalNetwork{}
					globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt
				}

			}

			interfaceChoiceTypeFound := false

			if v, ok := cs["default_interface_config"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

				interfaceChoiceTypeFound = true

				if v.(bool) {
					interfaceChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_DefaultInterfaceConfig{}
					interfaceChoiceInt.DefaultInterfaceConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt
				}

			}

			if v, ok := cs["interface_list"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

				interfaceChoiceTypeFound = true
				interfaceChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_InterfaceList{}
				interfaceChoiceInt.InterfaceList = &ves_io_schema_views_securemesh_site.InterfaceListType{}
				networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["interfaces"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						interfaces := make([]*ves_io_schema_views_securemesh_site.Interface, len(sl))
						interfaceChoiceInt.InterfaceList.Interfaces = interfaces
						for i, set := range sl {
							interfaces[i] = &ves_io_schema_views_securemesh_site.Interface{}
							interfacesMapStrToI := set.(map[string]interface{})

							dcClusterGroupConnectivityInterfaceChoiceTypeFound := false

							if v, ok := interfacesMapStrToI["dc_cluster_group_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !dcClusterGroupConnectivityInterfaceChoiceTypeFound {

								dcClusterGroupConnectivityInterfaceChoiceTypeFound = true

								if v.(bool) {
									dcClusterGroupConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_DcClusterGroupConnectivityInterfaceDisabled{}
									dcClusterGroupConnectivityInterfaceChoiceInt.DcClusterGroupConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
									interfaces[i].DcClusterGroupConnectivityInterfaceChoice = dcClusterGroupConnectivityInterfaceChoiceInt
								}

							}

							if v, ok := interfacesMapStrToI["dc_cluster_group_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !dcClusterGroupConnectivityInterfaceChoiceTypeFound {

								dcClusterGroupConnectivityInterfaceChoiceTypeFound = true

								if v.(bool) {
									dcClusterGroupConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_DcClusterGroupConnectivityInterfaceEnabled{}
									dcClusterGroupConnectivityInterfaceChoiceInt.DcClusterGroupConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
									interfaces[i].DcClusterGroupConnectivityInterfaceChoice = dcClusterGroupConnectivityInterfaceChoiceInt
								}

							}

							if w, ok := interfacesMapStrToI["description"]; ok && !isIntfNil(w) {
								interfaces[i].Description = w.(string)
							}

							interfaceChoiceTypeFound := false

							if v, ok := interfacesMapStrToI["dedicated_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_DedicatedInterface{}
								interfaceChoiceInt.DedicatedInterface = &ves_io_schema_network_interface.DedicatedInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Device = v.(string)

									}

									monitoringChoiceTypeFound := false

									if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Mtu = uint32(v.(int))

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Node{}

										interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Priority = uint32(v.(int))

									}

								}

							}

							if v, ok := interfacesMapStrToI["dedicated_management_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_DedicatedManagementInterface{}
								interfaceChoiceInt.DedicatedManagementInterface = &ves_io_schema_network_interface.DedicatedManagementInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedManagementInterface.Device = v.(string)

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedManagementInterface.Mtu = uint32(v.(int))

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Node{}

										interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

								}

							}

							if v, ok := interfacesMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_EthernetInterface{}
								interfaceChoiceInt.EthernetInterface = &ves_io_schema_network_interface.EthernetInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt
										}

									}

									if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Device = v.(string)

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := cs["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									monitoringChoiceTypeFound := false

									if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Mtu = uint32(v.(int))

									}

									networkChoiceTypeFound := false

									if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
										networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IpFabricNetwork{}
											networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
										networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
											networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

										interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Priority = uint32(v.(int))

									}

									vlanChoiceTypeFound := false

									if v, ok := cs["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true

										if v.(bool) {
											vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
											vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt
										}

									}

									if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true
										vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

										interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt

										vlanChoiceInt.VlanId = uint32(v.(int))

									}

								}

							}

							if v, ok := interfacesMapStrToI["loopback_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_LoopbackInterface{}
								interfaceChoiceInt.LoopbackInterface = &ves_io_schema_network_interface.LoopbackInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt
										}

									}

									if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.LoopbackInterface.Device = v.(string)

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.LoopbackInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.LoopbackInterface.Mtu = uint32(v.(int))

									}

									networkChoiceTypeFound := false

									if v, ok := cs["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_IpFabricNetwork{}
											networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_Node{}

										interfaceChoiceInt.LoopbackInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

								}

							}

							if w, ok := interfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								interfaces[i].Labels = ms
							}

						}

					}

				}

			}

			networkPolicyChoiceTypeFound := false

			if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_ActiveEnhancedFirewallPolicies{}
				networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
						for i, ps := range sl {

							efpMapToStrVal := ps.(map[string]interface{})
							enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Name = v.(string)
							}

							if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_ActiveNetworkPolicies{}
				networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
						for i, ps := range sl {

							npMapToStrVal := ps.(map[string]interface{})
							networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Name = v.(string)
							}

							if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true

				if v.(bool) {
					networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_NoNetworkPolicy{}
					networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt
				}

			}

			siteMeshGroupChoiceTypeFound := false

			if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_SmConnectionPublicIp{}
					siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_SmConnectionPvtIp{}
					siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			sliChoiceTypeFound := false

			if v, ok := cs["default_sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true

				if v.(bool) {
					sliChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_DefaultSliConfig{}
					sliChoiceInt.DefaultSliConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt
				}

			}

			if v, ok := cs["sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true
				sliChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_SliConfig{}
				sliChoiceInt.SliConfig = &ves_io_schema_views_securemesh_site.VnConfiguration{}
				networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					dcClusterGroupChoiceTypeFound := false

					if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true
						dcClusterGroupChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_DcClusterGroup{}
						dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
						sliChoiceInt.SliConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}

					}

					if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true

						if v.(bool) {
							dcClusterGroupChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoDcClusterGroup{}
							dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
						}

					}

					if v, ok := cs["dc_cluster_group_interface"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						dcClusterGroupInterfaceInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						sliChoiceInt.SliConfig.DcClusterGroupInterface = dcClusterGroupInterfaceInt
						for i, ps := range sl {

							dcgiMapToStrVal := ps.(map[string]interface{})
							dcClusterGroupInterfaceInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := dcgiMapToStrVal["name"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Name = v.(string)
							}

							if v, ok := dcgiMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Namespace = v.(string)
							}

							if v, ok := dcgiMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Tenant = v.(string)
							}

						}

					}

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sliChoiceInt.SliConfig.Labels = ms
					}

					if v, ok := cs["nameserver"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.Nameserver = v.(string)

					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_securemesh_site.StaticRoutesListType{}
						sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					staticV6RouteChoiceTypeFound := false

					if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true

						if v.(bool) {
							staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoV6StaticRoutes{}
							staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
						}

					}

					if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true
						staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_StaticV6Routes{}
						staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
						sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
								staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					if v, ok := cs["vip"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.Vip = v.(string)

					}

					if v, ok := cs["vip_v6"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.VipV6 = v.(string)

					}

				}

			}

			sloChoiceTypeFound := false

			if v, ok := cs["default_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true

				if v.(bool) {
					sloChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_DefaultConfig{}
					sloChoiceInt.DefaultConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt
				}

			}

			if v, ok := cs["slo_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true
				sloChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_SloConfig{}
				sloChoiceInt.SloConfig = &ves_io_schema_views_securemesh_site.VnConfiguration{}
				networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					dcClusterGroupChoiceTypeFound := false

					if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true
						dcClusterGroupChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_DcClusterGroup{}
						dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
						sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}

					}

					if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true

						if v.(bool) {
							dcClusterGroupChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoDcClusterGroup{}
							dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
						}

					}

					if v, ok := cs["dc_cluster_group_interface"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						dcClusterGroupInterfaceInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						sloChoiceInt.SloConfig.DcClusterGroupInterface = dcClusterGroupInterfaceInt
						for i, ps := range sl {

							dcgiMapToStrVal := ps.(map[string]interface{})
							dcClusterGroupInterfaceInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := dcgiMapToStrVal["name"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Name = v.(string)
							}

							if v, ok := dcgiMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Namespace = v.(string)
							}

							if v, ok := dcgiMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Tenant = v.(string)
							}

						}

					}

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sloChoiceInt.SloConfig.Labels = ms
					}

					if v, ok := cs["nameserver"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.Nameserver = v.(string)

					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_securemesh_site.StaticRoutesListType{}
						sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					staticV6RouteChoiceTypeFound := false

					if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true

						if v.(bool) {
							staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoV6StaticRoutes{}
							staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
						}

					}

					if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true
						staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_StaticV6Routes{}
						staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
						sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
								staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					if v, ok := cs["vip"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.Vip = v.(string)

					}

					if v, ok := cs["vip_v6"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.VipV6 = v.(string)

					}

				}

			}

			if v, ok := cs["tunnel_dead_timeout"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.TunnelDeadTimeout = uint32(v.(int))

			}

			if v, ok := cs["vip_vrrp_mode"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.VipVrrpMode = ves_io_schema.VipVrrpType(ves_io_schema.VipVrrpType_value[v.(string)])

			}

		}

	}

	if v, ok := d.GetOk("default_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true

		if v.(bool) {
			networkCfgChoiceInt := &ves_io_schema_views_securemesh_site.CreateSpecType_DefaultNetworkConfig{}
			networkCfgChoiceInt.DefaultNetworkConfig = &ves_io_schema.Empty{}
			createSpec.NetworkCfgChoice = networkCfgChoiceInt
		}

	}

	//offline_survivability_mode
	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		createSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

			offlineSurvivabilityModeChoiceTypeFound := false

			if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

			if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

		}

	}

	//os
	if v, ok := d.GetOk("os"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		os := &ves_io_schema_views.OperatingSystemType{}
		createSpec.Os = os
		for _, set := range sl {
			osMapStrToI := set.(map[string]interface{})

			operatingSystemVersionChoiceTypeFound := false

			if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

				operatingSystemVersionChoiceTypeFound = true

				if v.(bool) {
					operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
					operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
					os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
				}

			}

			if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

				operatingSystemVersionChoiceTypeFound = true
				operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

				os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

				operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

			}

		}

	}

	//performance_enhancement_mode
	if v, ok := d.GetOk("performance_enhancement_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
		createSpec.PerformanceEnhancementMode = performanceEnhancementMode
		for _, set := range sl {
			performanceEnhancementModeMapStrToI := set.(map[string]interface{})

			perfModeChoiceTypeFound := false

			if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

				perfModeChoiceTypeFound = true
				perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
				perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
				performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					perfModeChoiceTypeFound := false

					if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
							perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
							perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
						}

					}

					if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
							perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
							perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
						}

					}

				}

			}

			if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

				perfModeChoiceTypeFound = true

				if v.(bool) {
					perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
					perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
					performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
				}

			}

		}

	}

	//sw
	if v, ok := d.GetOk("sw"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		sw := &ves_io_schema_views.VolterraSoftwareType{}
		createSpec.Sw = sw
		for _, set := range sl {
			swMapStrToI := set.(map[string]interface{})

			volterraSwVersionChoiceTypeFound := false

			if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

				volterraSwVersionChoiceTypeFound = true

				if v.(bool) {
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
					volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
					sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
				}

			}

			if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

				volterraSwVersionChoiceTypeFound = true
				volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

				sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

				volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

			}

		}

	}

	//volterra_certified_hw
	if v, ok := d.GetOk("volterra_certified_hw"); ok && !isIntfNil(v) {

		createSpec.VolterraCertifiedHw =
			v.(string)

	}

	//worker_nodes
	if v, ok := d.GetOk("worker_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		createSpec.WorkerNodes = ls

	}

	log.Printf("[DEBUG] Creating Volterra SecuremeshSite object with struct: %+v", createReq)

	createSecuremeshSiteResp, err := client.CreateObject(context.Background(), ves_io_schema_views_securemesh_site.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating SecuremeshSite: %s", err)
	}
	d.SetId(createSecuremeshSiteResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraSecuremeshSiteRead(d, meta)
}

func resourceVolterraSecuremeshSiteRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_securemesh_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] SecuremeshSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra SecuremeshSite %q: %s", d.Id(), err)
	}
	return setSecuremeshSiteFields(client, d, resp)
}

func setSecuremeshSiteFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraSecuremeshSiteUpdate updates SecuremeshSite resource
func resourceVolterraSecuremeshSiteUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_securemesh_site.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_securemesh_site.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}
	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		updateSpec.Address =
			v.(string)

	}

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_securemesh_site.ReplaceSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		updateSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
				blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
				for i, set := range sl {
					blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
					blockedSeviceMapStrToI := set.(map[string]interface{})

					blockedServicesValueTypeChoiceTypeFound := false

					if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
							blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
							blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
							blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

						blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_securemesh_site.ReplaceSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	bondChoiceTypeFound := false

	if v, ok := d.GetOk("bond_device_list"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true
		bondChoiceInt := &ves_io_schema_views_securemesh_site.ReplaceSpecType_BondDeviceList{}
		bondChoiceInt.BondDeviceList = &ves_io_schema_fleet.FleetBondDevicesListType{}
		updateSpec.BondChoice = bondChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bond_devices"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				bondDevices := make([]*ves_io_schema_fleet.FleetBondDeviceType, len(sl))
				bondChoiceInt.BondDeviceList.BondDevices = bondDevices
				for i, set := range sl {
					bondDevices[i] = &ves_io_schema_fleet.FleetBondDeviceType{}
					bondDevicesMapStrToI := set.(map[string]interface{})

					if w, ok := bondDevicesMapStrToI["devices"]; ok && !isIntfNil(w) {
						ls := make([]string, len(w.([]interface{})))
						for i, v := range w.([]interface{}) {
							ls[i] = v.(string)
						}
						bondDevices[i].Devices = ls
					}

					lacpChoiceTypeFound := false

					if v, ok := bondDevicesMapStrToI["active_backup"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

						lacpChoiceTypeFound = true

						if v.(bool) {
							lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_ActiveBackup{}
							lacpChoiceInt.ActiveBackup = &ves_io_schema.Empty{}
							bondDevices[i].LacpChoice = lacpChoiceInt
						}

					}

					if v, ok := bondDevicesMapStrToI["lacp"]; ok && !isIntfNil(v) && !lacpChoiceTypeFound {

						lacpChoiceTypeFound = true
						lacpChoiceInt := &ves_io_schema_fleet.FleetBondDeviceType_Lacp{}
						lacpChoiceInt.Lacp = &ves_io_schema_fleet.BondLacpType{}
						bondDevices[i].LacpChoice = lacpChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["rate"]; ok && !isIntfNil(v) {

								lacpChoiceInt.Lacp.Rate = uint32(v.(int))

							}

						}

					}

					if w, ok := bondDevicesMapStrToI["link_polling_interval"]; ok && !isIntfNil(w) {
						bondDevices[i].LinkPollingInterval = uint32(w.(int))
					}

					if w, ok := bondDevicesMapStrToI["link_up_delay"]; ok && !isIntfNil(w) {
						bondDevices[i].LinkUpDelay = uint32(w.(int))
					}

					if w, ok := bondDevicesMapStrToI["name"]; ok && !isIntfNil(w) {
						bondDevices[i].Name = w.(string)
					}

				}

			}

		}

	}

	if v, ok := d.GetOk("no_bond_devices"); ok && !bondChoiceTypeFound {

		bondChoiceTypeFound = true

		if v.(bool) {
			bondChoiceInt := &ves_io_schema_views_securemesh_site.ReplaceSpecType_NoBondDevices{}
			bondChoiceInt.NoBondDevices = &ves_io_schema.Empty{}
			updateSpec.BondChoice = bondChoiceInt
		}

	}

	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		coordinates := &ves_io_schema_site.Coordinates{}
		updateSpec.Coordinates = coordinates
		for _, set := range sl {
			coordinatesMapStrToI := set.(map[string]interface{})

			if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
				coordinates.Latitude = float32(w.(float64))
			}

			if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
				coordinates.Longitude = float32(w.(float64))
			}

		}

	}

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_securemesh_site.ReplaceSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		updateSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_securemesh_site.ReplaceSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			updateSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	if v, ok := d.GetOk("master_node_configuration"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		masterNodeConfiguration := make([]*ves_io_schema_views.MasterNode, len(sl))
		updateSpec.MasterNodeConfiguration = masterNodeConfiguration
		for i, set := range sl {
			masterNodeConfiguration[i] = &ves_io_schema_views.MasterNode{}
			masterNodeConfigurationMapStrToI := set.(map[string]interface{})

			if w, ok := masterNodeConfigurationMapStrToI["name"]; ok && !isIntfNil(w) {
				masterNodeConfiguration[i].Name = w.(string)
			}

			if w, ok := masterNodeConfigurationMapStrToI["public_ip"]; ok && !isIntfNil(w) {
				masterNodeConfiguration[i].PublicIp = w.(string)
			}

		}

	}

	networkCfgChoiceTypeFound := false

	if v, ok := d.GetOk("custom_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true
		networkCfgChoiceInt := &ves_io_schema_views_securemesh_site.ReplaceSpecType_CustomNetworkConfig{}
		networkCfgChoiceInt.CustomNetworkConfig = &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration{}
		updateSpec.NetworkCfgChoice = networkCfgChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["bgp_peer_address"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.BgpPeerAddress = v.(string)

			}

			if v, ok := cs["bgp_router_id"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.BgpRouterId = v.(string)

			}

			forwardProxyChoiceTypeFound := false

			if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true
				forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_ActiveForwardProxyPolicies{}
				forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
						for i, ps := range sl {

							fppMapToStrVal := ps.(map[string]interface{})
							forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Name = v.(string)
							}

							if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_ForwardProxyAllowAll{}
					forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_NoForwardProxy{}
					forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			globalNetworkChoiceTypeFound := false

			if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true
				globalNetworkChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_GlobalNetworkList{}
				globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
				networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
						globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
						for i, set := range sl {
							globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
							globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

							connectionChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
								connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
								connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							forwardProxyChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true

								if v.(bool) {
									forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
									forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
									globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true
								forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
								forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
								globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

									}

									if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

									}

									tlsInterceptionChoiceTypeFound := false

									if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true

										if v.(bool) {
											tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
											tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
											forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
										}

									}

									if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true
										tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
										tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
										forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											interceptionPolicyChoiceTypeFound := false

											if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true

												if v.(bool) {
													interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
													interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
												}

											}

											if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true
												interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
												interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
												tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
														interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
														for i, set := range sl {
															interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
															interceptionRulesMapStrToI := set.(map[string]interface{})

															if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																domainMatch := &ves_io_schema.DomainType{}
																interceptionRules[i].DomainMatch = domainMatch
																for _, set := range sl {
																	domainMatchMapStrToI := set.(map[string]interface{})

																	domainChoiceTypeFound := false

																	if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.ExactValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.RegexValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.SuffixValue = v.(string)

																	}

																}

															}

															enableDisableChoiceTypeFound := false

															if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																	enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

															if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																	enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

														}

													}

												}

											}

											signingCertChoiceTypeFound := false

											if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true
												signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
												signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
												tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.Description = v.(string)

													}

													ocspStaplingChoiceTypeFound := false

													if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
														ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																for _, j := range v.([]interface{}) {
																	hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																}
																ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

															}

														}

													}

													if v, ok := cs["disable_ocsp_stapling"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														_ = v
													}

													if v, ok := cs["use_system_defaults"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														_ = v
													}

													if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														privateKey := &ves_io_schema.SecretType{}
														signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
														for _, set := range sl {
															privateKeyMapStrToI := set.(map[string]interface{})

															if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

												}

											}

											if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true

												if v.(bool) {
													signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
													signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
												}

											}

											trustedCaChoiceTypeFound := false

											if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true
												trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

												tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

												trustedCaChoiceInt.TrustedCaUrl = v.(string)

											}

											if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true

												if v.(bool) {
													trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
													trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
												}

											}

										}

									}

									if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

										ls := make([]uint32, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = uint32(v.(int))
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

									}

									if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

										ls := make([]string, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = v.(string)
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true

				if v.(bool) {
					globalNetworkChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_NoGlobalNetwork{}
					globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.GlobalNetworkChoice = globalNetworkChoiceInt
				}

			}

			interfaceChoiceTypeFound := false

			if v, ok := cs["default_interface_config"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

				interfaceChoiceTypeFound = true

				if v.(bool) {
					interfaceChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_DefaultInterfaceConfig{}
					interfaceChoiceInt.DefaultInterfaceConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt
				}

			}

			if v, ok := cs["interface_list"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

				interfaceChoiceTypeFound = true
				interfaceChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_InterfaceList{}
				interfaceChoiceInt.InterfaceList = &ves_io_schema_views_securemesh_site.InterfaceListType{}
				networkCfgChoiceInt.CustomNetworkConfig.InterfaceChoice = interfaceChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["interfaces"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						interfaces := make([]*ves_io_schema_views_securemesh_site.Interface, len(sl))
						interfaceChoiceInt.InterfaceList.Interfaces = interfaces
						for i, set := range sl {
							interfaces[i] = &ves_io_schema_views_securemesh_site.Interface{}
							interfacesMapStrToI := set.(map[string]interface{})

							dcClusterGroupConnectivityInterfaceChoiceTypeFound := false

							if v, ok := interfacesMapStrToI["dc_cluster_group_connectivity_interface_disabled"]; ok && !isIntfNil(v) && !dcClusterGroupConnectivityInterfaceChoiceTypeFound {

								dcClusterGroupConnectivityInterfaceChoiceTypeFound = true

								if v.(bool) {
									dcClusterGroupConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_DcClusterGroupConnectivityInterfaceDisabled{}
									dcClusterGroupConnectivityInterfaceChoiceInt.DcClusterGroupConnectivityInterfaceDisabled = &ves_io_schema.Empty{}
									interfaces[i].DcClusterGroupConnectivityInterfaceChoice = dcClusterGroupConnectivityInterfaceChoiceInt
								}

							}

							if v, ok := interfacesMapStrToI["dc_cluster_group_connectivity_interface_enabled"]; ok && !isIntfNil(v) && !dcClusterGroupConnectivityInterfaceChoiceTypeFound {

								dcClusterGroupConnectivityInterfaceChoiceTypeFound = true

								if v.(bool) {
									dcClusterGroupConnectivityInterfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_DcClusterGroupConnectivityInterfaceEnabled{}
									dcClusterGroupConnectivityInterfaceChoiceInt.DcClusterGroupConnectivityInterfaceEnabled = &ves_io_schema.Empty{}
									interfaces[i].DcClusterGroupConnectivityInterfaceChoice = dcClusterGroupConnectivityInterfaceChoiceInt
								}

							}

							if w, ok := interfacesMapStrToI["description"]; ok && !isIntfNil(w) {
								interfaces[i].Description = w.(string)
							}

							interfaceChoiceTypeFound := false

							if v, ok := interfacesMapStrToI["dedicated_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_DedicatedInterface{}
								interfaceChoiceInt.DedicatedInterface = &ves_io_schema_network_interface.DedicatedInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Device = v.(string)

									}

									monitoringChoiceTypeFound := false

									if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Mtu = uint32(v.(int))

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Node{}

										interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedInterface.Priority = uint32(v.(int))

									}

								}

							}

							if v, ok := interfacesMapStrToI["dedicated_management_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_DedicatedManagementInterface{}
								interfaceChoiceInt.DedicatedManagementInterface = &ves_io_schema_network_interface.DedicatedManagementInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedManagementInterface.Device = v.(string)

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.DedicatedManagementInterface.Mtu = uint32(v.(int))

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Node{}

										interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

								}

							}

							if v, ok := interfacesMapStrToI["ethernet_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_EthernetInterface{}
								interfaceChoiceInt.EthernetInterface = &ves_io_schema_network_interface.EthernetInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt
										}

									}

									if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Device = v.(string)

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := cs["ipv6_auto_config"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Ipv6AutoConfig{}
										ipv6AddressChoiceInt.Ipv6AutoConfig = &ves_io_schema_network_interface.IPV6AutoConfigType{}
										interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											autoconfigChoiceTypeFound := false

											if v, ok := cs["host"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true

												if v.(bool) {
													autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Host{}
													autoconfigChoiceInt.Host = &ves_io_schema.Empty{}
													ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt
												}

											}

											if v, ok := cs["router"]; ok && !isIntfNil(v) && !autoconfigChoiceTypeFound {

												autoconfigChoiceTypeFound = true
												autoconfigChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigType_Router{}
												autoconfigChoiceInt.Router = &ves_io_schema_network_interface.IPV6AutoConfigRouterType{}
												ipv6AddressChoiceInt.Ipv6AutoConfig.AutoconfigChoice = autoconfigChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													addressChoiceTypeFound := false

													if v, ok := cs["network_prefix"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_NetworkPrefix{}

														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														addressChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := cs["stateful"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

														addressChoiceTypeFound = true
														addressChoiceInt := &ves_io_schema_network_interface.IPV6AutoConfigRouterType_Stateful{}
														addressChoiceInt.Stateful = &ves_io_schema_network_interface.DHCPIPV6StatefulServer{}
														autoconfigChoiceInt.Router.AddressChoice = addressChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

																sl := v.([]interface{})
																dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPIPV6NetworkType, len(sl))
																addressChoiceInt.Stateful.DhcpNetworks = dhcpNetworks
																for i, set := range sl {
																	dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPIPV6NetworkType{}
																	dhcpNetworksMapStrToI := set.(map[string]interface{})

																	networkPrefixChoiceTypeFound := false

																	if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefix{}

																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		networkPrefixChoiceInt.NetworkPrefix = v.(string)

																	}

																	if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

																		networkPrefixChoiceTypeFound = true
																		networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{}
																		networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
																		dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

																		sl := v.(*schema.Set).List()
																		for _, set := range sl {
																			cs := set.(map[string]interface{})

																			if v, ok := cs["name"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

																			}

																			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

																			}

																			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																				networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

																			}

																		}

																	}

																	if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

																		sl := v.([]interface{})
																		pools := make([]*ves_io_schema_network_interface.DHCPIPV6PoolType, len(sl))
																		dhcpNetworks[i].Pools = pools
																		for i, set := range sl {
																			pools[i] = &ves_io_schema_network_interface.DHCPIPV6PoolType{}
																			poolsMapStrToI := set.(map[string]interface{})

																			if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																				pools[i].EndIp = w.(string)
																			}

																			if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																				pools[i].Exclude = w.(bool)
																			}

																			if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																				pools[i].StartIp = w.(string)
																			}

																		}

																	}

																}

															}

															if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

																ms := map[string]string{}
																for k, v := range v.(map[string]interface{}) {
																	ms[k] = v.(string)
																}
																addressChoiceInt.Stateful.FixedIpMap = ms
															}

															interfacesAddressingChoiceTypeFound := false

															if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{}
																	interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true

																if v.(bool) {
																	interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{}
																	interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
																	addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt
																}

															}

															if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

																interfacesAddressingChoiceTypeFound = true
																interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{}
																interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPV6Type{}
																addressChoiceInt.Stateful.InterfacesAddressingChoice = interfacesAddressingChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

																		ms := map[string]string{}
																		for k, v := range v.(map[string]interface{}) {
																			ms[k] = v.(string)
																		}
																		interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
																	}

																}

															}

														}

													}

													if v, ok := cs["dns_config"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														dnsConfig := &ves_io_schema_network_interface.IPV6DnsConfig{}
														autoconfigChoiceInt.Router.DnsConfig = dnsConfig
														for _, set := range sl {
															dnsConfigMapStrToI := set.(map[string]interface{})

															dnsChoiceTypeFound := false

															if v, ok := dnsConfigMapStrToI["configured_list"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_ConfiguredList{}
																dnsChoiceInt.ConfiguredList = &ves_io_schema_network_interface.IPV6DnsList{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["dns_list"]; ok && !isIntfNil(v) {

																		ls := make([]string, len(v.([]interface{})))
																		for i, v := range v.([]interface{}) {
																			ls[i] = v.(string)
																		}
																		dnsChoiceInt.ConfiguredList.DnsList = ls

																	}

																}

															}

															if v, ok := dnsConfigMapStrToI["local_dns"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

																dnsChoiceTypeFound = true
																dnsChoiceInt := &ves_io_schema_network_interface.IPV6DnsConfig_LocalDns{}
																dnsChoiceInt.LocalDns = &ves_io_schema_network_interface.IPV6LocalDnsAddress{}
																dnsConfig.DnsChoice = dnsChoiceInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	localDnsChoiceTypeFound := false

																	if v, ok := cs["configured_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true
																		localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_ConfiguredAddress{}

																		dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt

																		localDnsChoiceInt.ConfiguredAddress = v.(string)

																	}

																	if v, ok := cs["first_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_FirstAddress{}
																			localDnsChoiceInt.FirstAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																	if v, ok := cs["last_address"]; ok && !isIntfNil(v) && !localDnsChoiceTypeFound {

																		localDnsChoiceTypeFound = true

																		if v.(bool) {
																			localDnsChoiceInt := &ves_io_schema_network_interface.IPV6LocalDnsAddress_LastAddress{}
																			localDnsChoiceInt.LastAddress = &ves_io_schema.Empty{}
																			dnsChoiceInt.LocalDns.LocalDnsChoice = localDnsChoiceInt
																		}

																	}

																}

															}

														}

													}

												}

											}

										}

									}

									if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.EthernetInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									monitoringChoiceTypeFound := false

									if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true
										_ = v
									}

									if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

										monitoringChoiceTypeFound = true

										if v.(bool) {
											monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
											monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt
										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Mtu = uint32(v.(int))

									}

									networkChoiceTypeFound := false

									if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
										networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.InsideNetwork.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IpFabricNetwork{}
											networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["srv6_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true
										networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Srv6Network{}
										networkChoiceInt.Srv6Network = &ves_io_schema_views.ObjectRefType{}
										interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												networkChoiceInt.Srv6Network.Tenant = v.(string)

											}

										}

									}

									if v, ok := cs["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
											networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

										interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

									primaryChoiceTypeFound := false

									if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
											primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

										primaryChoiceTypeFound = true

										if v.(bool) {
											primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
											primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
										}

									}

									if v, ok := cs["priority"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.EthernetInterface.Priority = uint32(v.(int))

									}

									vlanChoiceTypeFound := false

									if v, ok := cs["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true

										if v.(bool) {
											vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
											vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
											interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt
										}

									}

									if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

										vlanChoiceTypeFound = true
										vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

										interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt

										vlanChoiceInt.VlanId = uint32(v.(int))

									}

								}

							}

							if v, ok := interfacesMapStrToI["loopback_interface"]; ok && !isIntfNil(v) && !interfaceChoiceTypeFound {

								interfaceChoiceTypeFound = true
								interfaceChoiceInt := &ves_io_schema_views_securemesh_site.Interface_LoopbackInterface{}
								interfaceChoiceInt.LoopbackInterface = &ves_io_schema_network_interface.LoopbackInterfaceType{}
								interfaces[i].InterfaceChoice = interfaceChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									addressChoiceTypeFound := false

									if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true

										if v.(bool) {
											addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_DhcpClient{}
											addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt
										}

									}

									if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_DhcpServer{}
										addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
										interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
												addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
												for i, set := range sl {
													dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
													dhcpNetworksMapStrToI := set.(map[string]interface{})

													dnsChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true
														dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

														dhcpNetworks[i].DnsChoice = dnsChoiceInt

														dnsChoiceInt.DnsAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

														dnsChoiceTypeFound = true

														if v.(bool) {
															dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
															dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
															dhcpNetworks[i].DnsChoice = dnsChoiceInt
														}

													}

													gatewayChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true
														gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

														dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

														gatewayChoiceInt.DgwAddress = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
															gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

														gatewayChoiceTypeFound = true

														if v.(bool) {
															gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
															gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
															dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
														}

													}

													networkPrefixChoiceTypeFound := false

													if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														networkPrefixChoiceInt.NetworkPrefix = v.(string)

													}

													if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

														networkPrefixChoiceTypeFound = true
														networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
														networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
														dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["name"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)

															}

															if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)

															}

															if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

																networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)

															}

														}

													}

													if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

														dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

													}

													if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
														dhcpNetworks[i].Pools = pools
														for i, set := range sl {
															pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
															poolsMapStrToI := set.(map[string]interface{})

															if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
																pools[i].EndIp = w.(string)
															}

															if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
																pools[i].Exclude = w.(bool)
															}

															if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
																pools[i].StartIp = w.(string)
															}

														}

													}

												}

											}

											if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

												addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)

											}

											if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

												ms := map[string]string{}
												for k, v := range v.(map[string]interface{}) {
													ms[k] = v.(string)
												}
												addressChoiceInt.DhcpServer.FixedIpMap = ms
											}

											interfacesAddressingChoiceTypeFound := false

											if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
													interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true

												if v.(bool) {
													interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
													interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
													addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
												}

											}

											if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

												interfacesAddressingChoiceTypeFound = true
												interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
												interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
												addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														ms := map[string]string{}
														for k, v := range v.(map[string]interface{}) {
															ms[k] = v.(string)
														}
														interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
													}

												}

											}

										}

									}

									if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

										addressChoiceTypeFound = true
										addressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_StaticIp{}
										addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.LoopbackInterface.AddressChoice = addressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["device"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.LoopbackInterface.Device = v.(string)

									}

									ipv6AddressChoiceTypeFound := false

									if v, ok := cs["no_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true

										if v.(bool) {
											ipv6AddressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_NoIpv6Address{}
											ipv6AddressChoiceInt.NoIpv6Address = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.Ipv6AddressChoice = ipv6AddressChoiceInt
										}

									}

									if v, ok := cs["static_ipv6_address"]; ok && !isIntfNil(v) && !ipv6AddressChoiceTypeFound {

										ipv6AddressChoiceTypeFound = true
										ipv6AddressChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_StaticIpv6Address{}
										ipv6AddressChoiceInt.StaticIpv6Address = &ves_io_schema_network_interface.StaticIPParametersType{}
										interfaceChoiceInt.LoopbackInterface.Ipv6AddressChoice = ipv6AddressChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											networkPrefixChoiceTypeFound := false

											if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
												networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
														networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
														for _, set := range sl {
															interfaceIpMapMapStrToI := set.(map[string]interface{})
															key, ok := interfaceIpMapMapStrToI["name"]
															if ok && !isIntfNil(key) {
																interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
																val, _ := interfaceIpMapMapStrToI["value"]

																interfaceIpMapVals := val.(*schema.Set).List()
																for _, intVal := range interfaceIpMapVals {

																	interfaceIpMapStaticMap := intVal.(map[string]interface{})

																	if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DefaultGw = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].DnsServer = w.(string)
																	}

																	if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
																		interfaceIpMap[key.(string)].IpAddress = w.(string)
																	}

																	// break after one loop
																	break
																}
															}
														}

													}

												}

											}

											if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
												networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
														networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

														for _, set := range sl {
															npaMapToStrVal := set.(map[string]interface{})
															if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Name = val.(string)
															}
															if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Namespace = val.(string)
															}

															if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
																networkPrefixAllocatorInt.Tenant = val.(string)
															}
														}

													}

												}

											}

											if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

												networkPrefixChoiceTypeFound = true
												networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
												networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
												ipv6AddressChoiceInt.StaticIpv6Address.NetworkPrefixChoice = networkPrefixChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)

													}

													if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)

													}

													if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

														networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)

													}

												}

											}

										}

									}

									if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

										interfaceChoiceInt.LoopbackInterface.Mtu = uint32(v.(int))

									}

									networkChoiceTypeFound := false

									if v, ok := cs["ip_fabric_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_IpFabricNetwork{}
											networkChoiceInt.IpFabricNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_SiteLocalInsideNetwork{}
											networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
										}

									}

									if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

										networkChoiceTypeFound = true

										if v.(bool) {
											networkChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_SiteLocalNetwork{}
											networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.NetworkChoice = networkChoiceInt
										}

									}

									nodeChoiceTypeFound := false

									if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true

										if v.(bool) {
											nodeChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_Cluster{}
											nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
											interfaceChoiceInt.LoopbackInterface.NodeChoice = nodeChoiceInt
										}

									}

									if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

										nodeChoiceTypeFound = true
										nodeChoiceInt := &ves_io_schema_network_interface.LoopbackInterfaceType_Node{}

										interfaceChoiceInt.LoopbackInterface.NodeChoice = nodeChoiceInt

										nodeChoiceInt.Node = v.(string)

									}

								}

							}

							if w, ok := interfacesMapStrToI["labels"]; ok && !isIntfNil(w) {
								ms := map[string]string{}
								for k, v := range w.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								interfaces[i].Labels = ms
							}

						}

					}

				}

			}

			networkPolicyChoiceTypeFound := false

			if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_ActiveEnhancedFirewallPolicies{}
				networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
						for i, ps := range sl {

							efpMapToStrVal := ps.(map[string]interface{})
							enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Name = v.(string)
							}

							if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_ActiveNetworkPolicies{}
				networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
				networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
						for i, ps := range sl {

							npMapToStrVal := ps.(map[string]interface{})
							networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Name = v.(string)
							}

							if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true

				if v.(bool) {
					networkPolicyChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_NoNetworkPolicy{}
					networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.NetworkPolicyChoice = networkPolicyChoiceInt
				}

			}

			siteMeshGroupChoiceTypeFound := false

			if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_SmConnectionPublicIp{}
					siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_SmConnectionPvtIp{}
					siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			sliChoiceTypeFound := false

			if v, ok := cs["default_sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true

				if v.(bool) {
					sliChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_DefaultSliConfig{}
					sliChoiceInt.DefaultSliConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt
				}

			}

			if v, ok := cs["sli_config"]; ok && !isIntfNil(v) && !sliChoiceTypeFound {

				sliChoiceTypeFound = true
				sliChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_SliConfig{}
				sliChoiceInt.SliConfig = &ves_io_schema_views_securemesh_site.VnConfiguration{}
				networkCfgChoiceInt.CustomNetworkConfig.SliChoice = sliChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					dcClusterGroupChoiceTypeFound := false

					if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true
						dcClusterGroupChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_DcClusterGroup{}
						dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
						sliChoiceInt.SliConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}

					}

					if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true

						if v.(bool) {
							dcClusterGroupChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoDcClusterGroup{}
							dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
						}

					}

					if v, ok := cs["dc_cluster_group_interface"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						dcClusterGroupInterfaceInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						sliChoiceInt.SliConfig.DcClusterGroupInterface = dcClusterGroupInterfaceInt
						for i, ps := range sl {

							dcgiMapToStrVal := ps.(map[string]interface{})
							dcClusterGroupInterfaceInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := dcgiMapToStrVal["name"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Name = v.(string)
							}

							if v, ok := dcgiMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Namespace = v.(string)
							}

							if v, ok := dcgiMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Tenant = v.(string)
							}

						}

					}

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sliChoiceInt.SliConfig.Labels = ms
					}

					if v, ok := cs["nameserver"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.Nameserver = v.(string)

					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_securemesh_site.StaticRoutesListType{}
						sliChoiceInt.SliConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					staticV6RouteChoiceTypeFound := false

					if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true

						if v.(bool) {
							staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoV6StaticRoutes{}
							staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
							sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
						}

					}

					if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true
						staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_StaticV6Routes{}
						staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
						sliChoiceInt.SliConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
								staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					if v, ok := cs["vip"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.Vip = v.(string)

					}

					if v, ok := cs["vip_v6"]; ok && !isIntfNil(v) {

						sliChoiceInt.SliConfig.VipV6 = v.(string)

					}

				}

			}

			sloChoiceTypeFound := false

			if v, ok := cs["default_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true

				if v.(bool) {
					sloChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_DefaultConfig{}
					sloChoiceInt.DefaultConfig = &ves_io_schema.Empty{}
					networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt
				}

			}

			if v, ok := cs["slo_config"]; ok && !isIntfNil(v) && !sloChoiceTypeFound {

				sloChoiceTypeFound = true
				sloChoiceInt := &ves_io_schema_views_securemesh_site.SmsNetworkConfiguration_SloConfig{}
				sloChoiceInt.SloConfig = &ves_io_schema_views_securemesh_site.VnConfiguration{}
				networkCfgChoiceInt.CustomNetworkConfig.SloChoice = sloChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					dcClusterGroupChoiceTypeFound := false

					if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true
						dcClusterGroupChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_DcClusterGroup{}
						dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
						sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

							}

							if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

							}

							if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

								dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

							}

						}

					}

					if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

						dcClusterGroupChoiceTypeFound = true

						if v.(bool) {
							dcClusterGroupChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoDcClusterGroup{}
							dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.DcClusterGroupChoice = dcClusterGroupChoiceInt
						}

					}

					if v, ok := cs["dc_cluster_group_interface"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						dcClusterGroupInterfaceInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						sloChoiceInt.SloConfig.DcClusterGroupInterface = dcClusterGroupInterfaceInt
						for i, ps := range sl {

							dcgiMapToStrVal := ps.(map[string]interface{})
							dcClusterGroupInterfaceInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := dcgiMapToStrVal["name"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Name = v.(string)
							}

							if v, ok := dcgiMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Namespace = v.(string)
							}

							if v, ok := dcgiMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								dcClusterGroupInterfaceInt[i].Tenant = v.(string)
							}

						}

					}

					if v, ok := cs["labels"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						sloChoiceInt.SloConfig.Labels = ms
					}

					if v, ok := cs["nameserver"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.Nameserver = v.(string)

					}

					staticRouteChoiceTypeFound := false

					if v, ok := cs["no_static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true

						if v.(bool) {
							staticRouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoStaticRoutes{}
							staticRouteChoiceInt.NoStaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt
						}

					}

					if v, ok := cs["static_routes"]; ok && !isIntfNil(v) && !staticRouteChoiceTypeFound {

						staticRouteChoiceTypeFound = true
						staticRouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_StaticRoutes{}
						staticRouteChoiceInt.StaticRoutes = &ves_io_schema_views_securemesh_site.StaticRoutesListType{}
						sloChoiceInt.SloConfig.StaticRouteChoice = staticRouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticRouteViewType, len(sl))
								staticRouteChoiceInt.StaticRoutes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticRouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticRouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					staticV6RouteChoiceTypeFound := false

					if v, ok := cs["no_v6_static_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true

						if v.(bool) {
							staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_NoV6StaticRoutes{}
							staticV6RouteChoiceInt.NoV6StaticRoutes = &ves_io_schema.Empty{}
							sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt
						}

					}

					if v, ok := cs["static_v6_routes"]; ok && !isIntfNil(v) && !staticV6RouteChoiceTypeFound {

						staticV6RouteChoiceTypeFound = true
						staticV6RouteChoiceInt := &ves_io_schema_views_securemesh_site.VnConfiguration_StaticV6Routes{}
						staticV6RouteChoiceInt.StaticV6Routes = &ves_io_schema_virtual_network.StaticV6RoutesListType{}
						sloChoiceInt.SloConfig.StaticV6RouteChoice = staticV6RouteChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["static_routes"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								staticRoutes := make([]*ves_io_schema_virtual_network.StaticV6RouteViewType, len(sl))
								staticV6RouteChoiceInt.StaticV6Routes.StaticRoutes = staticRoutes
								for i, set := range sl {
									staticRoutes[i] = &ves_io_schema_virtual_network.StaticV6RouteViewType{}
									staticRoutesMapStrToI := set.(map[string]interface{})

									if v, ok := staticRoutesMapStrToI["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										staticRoutes[i].Attrs = attrsList

									}

									if w, ok := staticRoutesMapStrToI["ip_prefixes"]; ok && !isIntfNil(w) {
										ls := make([]string, len(w.([]interface{})))
										for i, v := range w.([]interface{}) {
											ls[i] = v.(string)
										}
										staticRoutes[i].IpPrefixes = ls
									}

									nextHopChoiceTypeFound := false

									if v, ok := staticRoutesMapStrToI["default_gateway"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true

										if v.(bool) {
											nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_DefaultGateway{}
											nextHopChoiceInt.DefaultGateway = &ves_io_schema.Empty{}
											staticRoutes[i].NextHopChoice = nextHopChoiceInt
										}

									}

									if v, ok := staticRoutesMapStrToI["interface"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_Interface{}
										nextHopChoiceInt.Interface = &ves_io_schema_views.ObjectRefType{}
										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											if v, ok := cs["name"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Name = v.(string)

											}

											if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Namespace = v.(string)

											}

											if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

												nextHopChoiceInt.Interface.Tenant = v.(string)

											}

										}

									}

									if v, ok := staticRoutesMapStrToI["ip_address"]; ok && !isIntfNil(v) && !nextHopChoiceTypeFound {

										nextHopChoiceTypeFound = true
										nextHopChoiceInt := &ves_io_schema_virtual_network.StaticV6RouteViewType_IpAddress{}

										staticRoutes[i].NextHopChoice = nextHopChoiceInt

										nextHopChoiceInt.IpAddress = v.(string)

									}

								}

							}

						}

					}

					if v, ok := cs["vip"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.Vip = v.(string)

					}

					if v, ok := cs["vip_v6"]; ok && !isIntfNil(v) {

						sloChoiceInt.SloConfig.VipV6 = v.(string)

					}

				}

			}

			if v, ok := cs["tunnel_dead_timeout"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.TunnelDeadTimeout = uint32(v.(int))

			}

			if v, ok := cs["vip_vrrp_mode"]; ok && !isIntfNil(v) {

				networkCfgChoiceInt.CustomNetworkConfig.VipVrrpMode = ves_io_schema.VipVrrpType(ves_io_schema.VipVrrpType_value[v.(string)])

			}

		}

	}

	if v, ok := d.GetOk("default_network_config"); ok && !networkCfgChoiceTypeFound {

		networkCfgChoiceTypeFound = true

		if v.(bool) {
			networkCfgChoiceInt := &ves_io_schema_views_securemesh_site.ReplaceSpecType_DefaultNetworkConfig{}
			networkCfgChoiceInt.DefaultNetworkConfig = &ves_io_schema.Empty{}
			updateSpec.NetworkCfgChoice = networkCfgChoiceInt
		}

	}

	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		updateSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

			offlineSurvivabilityModeChoiceTypeFound := false

			if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

			if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

		}

	}

	if v, ok := d.GetOk("os"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		os := &ves_io_schema_views.OperatingSystemType{}
		updateSpec.Os = os
		for _, set := range sl {
			osMapStrToI := set.(map[string]interface{})

			operatingSystemVersionChoiceTypeFound := false

			if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

				operatingSystemVersionChoiceTypeFound = true

				if v.(bool) {
					operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
					operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
					os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
				}

			}

			if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

				operatingSystemVersionChoiceTypeFound = true
				operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

				os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

				operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("performance_enhancement_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
		updateSpec.PerformanceEnhancementMode = performanceEnhancementMode
		for _, set := range sl {
			performanceEnhancementModeMapStrToI := set.(map[string]interface{})

			perfModeChoiceTypeFound := false

			if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

				perfModeChoiceTypeFound = true
				perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
				perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
				performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					perfModeChoiceTypeFound := false

					if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
							perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
							perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
						}

					}

					if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
							perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
							perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
						}

					}

				}

			}

			if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

				perfModeChoiceTypeFound = true

				if v.(bool) {
					perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
					perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
					performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
				}

			}

		}

	}

	if v, ok := d.GetOk("sw"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		sw := &ves_io_schema_views.VolterraSoftwareType{}
		updateSpec.Sw = sw
		for _, set := range sl {
			swMapStrToI := set.(map[string]interface{})

			volterraSwVersionChoiceTypeFound := false

			if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

				volterraSwVersionChoiceTypeFound = true

				if v.(bool) {
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
					volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
					sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
				}

			}

			if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

				volterraSwVersionChoiceTypeFound = true
				volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

				sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

				volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("volterra_certified_hw"); ok && !isIntfNil(v) {

		updateSpec.VolterraCertifiedHw =
			v.(string)

	}

	if v, ok := d.GetOk("worker_nodes"); ok && !isIntfNil(v) {

		ls := make([]string, len(v.([]interface{})))
		for i, v := range v.([]interface{}) {
			ls[i] = v.(string)
		}
		updateSpec.WorkerNodes = ls

	}

	log.Printf("[DEBUG] Updating Volterra SecuremeshSite obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_securemesh_site.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating SecuremeshSite: %s", err)
	}

	return resourceVolterraSecuremeshSiteRead(d, meta)
}

func resourceVolterraSecuremeshSiteDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_securemesh_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] SecuremeshSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra SecuremeshSite before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra SecuremeshSite obj with name %+v in namespace %+v", name, namespace)
	return client.DeleteObject(context.Background(), ves_io_schema_views_securemesh_site.ObjectType, namespace, name)
}
