//
// Copyright (c) 2023 F5 Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_network_interface "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

// resourceVolterraNetworkInterface is implementation of Volterra's NetworkInterface resources
func resourceVolterraNetworkInterface() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraNetworkInterfaceCreate,
		Read:   resourceVolterraNetworkInterfaceRead,
		Update: resourceVolterraNetworkInterfaceUpdate,
		Delete: resourceVolterraNetworkInterfaceDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"dedicated_interface": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"device": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"monitor": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},

						"monitor_disabled": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"mtu": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"cluster": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"node": {

							Type:     schema.TypeString,
							Optional: true,
						},

						"is_primary": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"not_primary": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"priority": {
							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},

			"dedicated_management_interface": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"device": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"mtu": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"cluster": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"node": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"ethernet_interface": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"dhcp_client": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"dhcp_server": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dhcp_networks": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"dns_address": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"same_as_dgw": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"dgw_address": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"first_address": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"last_address": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"network_prefix": {

													Type:     schema.TypeString,
													Optional: true,
												},

												"network_prefix_allocator": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"pool_settings": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"pools": {

													Type:     schema.TypeList,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"end_ip": {
																Type:     schema.TypeString,
																Optional: true,
															},

															"exclude": {
																Type:     schema.TypeBool,
																Optional: true,
															},

															"start_ip": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"dhcp_option82_tag": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"fixed_ip_map": {
										Type:     schema.TypeMap,
										Optional: true,
									},

									"automatic_from_end": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"automatic_from_start": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"interface_ip_map": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"interface_ip_map": {
													Type:     schema.TypeMap,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"static_ip": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"cluster_static_ip": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"interface_ip_map": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:     schema.TypeString,
																Required: true,
															},
															"value": {
																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},

									"fleet_static_ip": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"default_gw": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"dns_server": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"network_prefix_allocator": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"node_static_ip": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"default_gw": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"dns_server": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"ip_address": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"device": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"monitor": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},

						"monitor_disabled": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"mtu": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"inside_network": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"site_local_inside_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"site_local_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"cluster": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"node": {

							Type:     schema.TypeString,
							Optional: true,
						},

						"is_primary": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"not_primary": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"priority": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"untagged": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"vlan_id": {

							Type:     schema.TypeInt,
							Optional: true,
						},
					},
				},
			},

			"legacy_interface": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"dhcp_server": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"dns_server": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns_mode": {
										Type:     schema.TypeString,
										Optional: true,
									},

									"dns_server": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"addr": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"address_allocator": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:     schema.TypeString,
										Computed: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"default_gateway": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"default_gateway_address": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"addr": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"default_gateway_mode": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"device_name": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"dhcp_address": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"monitor": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{},
							},
						},

						"monitor_disabled": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"mtu": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"priority": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"static_addresses": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"plen": {
										Type:     schema.TypeInt,
										Optional: true,
									},

									"prefix": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"tunnel": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"tunnel": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"kind": {
													Type:     schema.TypeString,
													Computed: true,
												},

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"type": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"virtual_network": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:     schema.TypeString,
										Computed: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"vlan_tag": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"vlan_tagging": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"tunnel_interface": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"mtu": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"inside_network": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"site_local_inside_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"site_local_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"cluster": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"node": {

							Type:     schema.TypeString,
							Optional: true,
						},

						"priority": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"static_ip": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"cluster_static_ip": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"interface_ip_map": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:     schema.TypeString,
																Required: true,
															},
															"value": {
																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"default_gw": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"dns_server": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},

																		"ip_address": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},

									"fleet_static_ip": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"default_gw": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"dns_server": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"network_prefix_allocator": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"node_static_ip": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"default_gw": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"dns_server": {
													Type:     schema.TypeString,
													Optional: true,
												},

												"ip_address": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"tunnel": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// resourceVolterraNetworkInterfaceCreate creates NetworkInterface resource
func resourceVolterraNetworkInterfaceCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_network_interface.CreateSpecType{}
	createReq := &ves_io_schema_network_interface.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//interface_choice

	interfaceChoiceTypeFound := false

	if v, ok := d.GetOk("dedicated_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.CreateSpecType_DedicatedInterface{}
		interfaceChoiceInt.DedicatedInterface = &ves_io_schema_network_interface.DedicatedInterfaceType{}
		createSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// device

			if v, ok := cs["device"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedInterface.Device = v.(string)
			}

			// monitoring_choice

			monitoringChoiceTypeFound := false

			if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true
				_ = v
			}

			if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true

				if v.(bool) {
					monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_MonitorDisabled{}
					monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt
				}

			}

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedInterface.Mtu = uint32(v.(int))
			}

			// node_choice

			nodeChoiceTypeFound := false

			if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true

				if v.(bool) {
					nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Cluster{}
					nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt
				}

			}

			if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true
				nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Node{}

				interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt

				nodeChoiceInt.Node = v.(string)

			}

			// primary_choice

			primaryChoiceTypeFound := false

			if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

				primaryChoiceTypeFound = true

				if v.(bool) {
					primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_IsPrimary{}
					primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
				}

			}

			if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

				primaryChoiceTypeFound = true

				if v.(bool) {
					primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_NotPrimary{}
					primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
				}

			}

			// priority

			if v, ok := cs["priority"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedInterface.Priority = uint32(v.(int))
			}

		}

	}

	if v, ok := d.GetOk("dedicated_management_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.CreateSpecType_DedicatedManagementInterface{}
		interfaceChoiceInt.DedicatedManagementInterface = &ves_io_schema_network_interface.DedicatedManagementInterfaceType{}
		createSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// device

			if v, ok := cs["device"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedManagementInterface.Device = v.(string)
			}

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedManagementInterface.Mtu = uint32(v.(int))
			}

			// node_choice

			nodeChoiceTypeFound := false

			if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true

				if v.(bool) {
					nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Cluster{}
					nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt
				}

			}

			if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true
				nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Node{}

				interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt

				nodeChoiceInt.Node = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("ethernet_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.CreateSpecType_EthernetInterface{}
		interfaceChoiceInt.EthernetInterface = &ves_io_schema_network_interface.EthernetInterfaceType{}
		createSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// address_choice

			addressChoiceTypeFound := false

			if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

				addressChoiceTypeFound = true

				if v.(bool) {
					addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
					addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt
				}

			}

			if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

				addressChoiceTypeFound = true
				addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
				addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
				interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					// dhcp_networks

					if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
						addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
						for i, set := range sl {
							dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
							dhcpNetworksMapStrToI := set.(map[string]interface{})

							// dns_choice

							dnsChoiceTypeFound := false

							if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

								dnsChoiceTypeFound = true
								dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

								dhcpNetworks[i].DnsChoice = dnsChoiceInt

								dnsChoiceInt.DnsAddress = v.(string)

							}

							if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

								dnsChoiceTypeFound = true

								if v.(bool) {
									dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
									dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
									dhcpNetworks[i].DnsChoice = dnsChoiceInt
								}

							}

							// gateway_choice

							gatewayChoiceTypeFound := false

							if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

								gatewayChoiceTypeFound = true
								gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

								dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

								gatewayChoiceInt.DgwAddress = v.(string)

							}

							if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

								gatewayChoiceTypeFound = true

								if v.(bool) {
									gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
									gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
									dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
								}

							}

							if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

								gatewayChoiceTypeFound = true

								if v.(bool) {
									gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
									gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
									dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
								}

							}

							// network_prefix_choice

							networkPrefixChoiceTypeFound := false

							if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

								networkPrefixChoiceTypeFound = true
								networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

								dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

								networkPrefixChoiceInt.NetworkPrefix = v.(string)

							}

							if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

								networkPrefixChoiceTypeFound = true
								networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
								networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
								dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									// name

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)
									}

									// namespace

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)
									}

									// tenant

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)
									}

								}

							}

							// pool_settings

							if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

								dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

							}

							// pools

							if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
								dhcpNetworks[i].Pools = pools
								for i, set := range sl {
									pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
									poolsMapStrToI := set.(map[string]interface{})

									// end_ip

									if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
										pools[i].EndIp = w.(string)
									}

									// exclude

									if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
										pools[i].Exclude = w.(bool)
									}

									// start_ip

									if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
										pools[i].StartIp = w.(string)
									}

								}

							}

						}

					}

					// dhcp_option82_tag

					if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

						addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)
					}

					// fixed_ip_map

					if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						addressChoiceInt.DhcpServer.FixedIpMap = ms
					}

					// interfaces_addressing_choice

					interfacesAddressingChoiceTypeFound := false

					if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

						interfacesAddressingChoiceTypeFound = true

						if v.(bool) {
							interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
							interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
							addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
						}

					}

					if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

						interfacesAddressingChoiceTypeFound = true

						if v.(bool) {
							interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
							interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
							addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
						}

					}

					if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

						interfacesAddressingChoiceTypeFound = true
						interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
						interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
						addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// interface_ip_map

							if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

								ms := map[string]string{}
								for k, v := range v.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
							}

						}

					}

				}

			}

			if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

				addressChoiceTypeFound = true
				addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
				addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
				interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					// network_prefix_choice

					networkPrefixChoiceTypeFound := false

					if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
						networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
						addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// interface_ip_map

							if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

								sl := v.(*schema.Set).List()
								interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
								networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
								for _, set := range sl {
									interfaceIpMapMapStrToI := set.(map[string]interface{})
									key, ok := interfaceIpMapMapStrToI["name"]
									if ok && !isIntfNil(key) {
										interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										val, _ := interfaceIpMapMapStrToI["value"]

										interfaceIpMapVals := val.(*schema.Set).List()
										for _, intVal := range interfaceIpMapVals {

											interfaceIpMapStaticMap := intVal.(map[string]interface{})

											if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].DefaultGw = w.(string)
											}

											if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].DnsServer = w.(string)
											}

											if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].IpAddress = w.(string)
											}

											// break after one loop
											break
										}
									}
								}

							}

						}

					}

					if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
						networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
						addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// default_gw

							if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)
							}

							// dns_server

							if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)
							}

							// network_prefix_allocator

							if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

								networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
								networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

								npaMapToStrVal := v.(map[string]interface{})
								if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Name = val.(string)
								}
								if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Namespace = val.(string)
								}

								if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Tenant = val.(string)
								}

							}

						}

					}

					if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
						networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
						addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// default_gw

							if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)
							}

							// dns_server

							if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)
							}

							// ip_address

							if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)
							}

						}

					}

				}

			}

			// device

			if v, ok := cs["device"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.EthernetInterface.Device = v.(string)
			}

			// monitoring_choice

			monitoringChoiceTypeFound := false

			if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true
				_ = v
			}

			if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true

				if v.(bool) {
					monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
					monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt
				}

			}

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.EthernetInterface.Mtu = uint32(v.(int))
			}

			// network_choice

			networkChoiceTypeFound := false

			if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true
				networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
				networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
				interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					// name

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Name = v.(string)
					}

					// namespace

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Namespace = v.(string)
					}

					// tenant

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Tenant = v.(string)
					}

				}

			}

			if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
					networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
				}

			}

			if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
					networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
				}

			}

			if v, ok := cs["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
					networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
				}

			}

			// node_choice

			nodeChoiceTypeFound := false

			if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true

				if v.(bool) {
					nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
					nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt
				}

			}

			if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true
				nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

				interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt

				nodeChoiceInt.Node = v.(string)

			}

			// primary_choice

			primaryChoiceTypeFound := false

			if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

				primaryChoiceTypeFound = true

				if v.(bool) {
					primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
					primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
				}

			}

			if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

				primaryChoiceTypeFound = true

				if v.(bool) {
					primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
					primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
				}

			}

			// priority

			if v, ok := cs["priority"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.EthernetInterface.Priority = uint32(v.(int))
			}

			// vlan_choice

			vlanChoiceTypeFound := false

			if v, ok := cs["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

				vlanChoiceTypeFound = true

				if v.(bool) {
					vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
					vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt
				}

			}

			if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

				vlanChoiceTypeFound = true
				vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

				interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt

				vlanChoiceInt.VlanId =
					uint32(v.(int))

			}

		}

	}

	if v, ok := d.GetOk("legacy_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.CreateSpecType_LegacyInterface{}
		interfaceChoiceInt.LegacyInterface = &ves_io_schema_network_interface.LegacyInterfaceType{}
		createSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// DHCP_server

			if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.DHCPServer = ves_io_schema_network_interface.NetworkInterfaceDHCPServer(ves_io_schema_network_interface.NetworkInterfaceDHCPServer_value[v.(string)])

			}

			// DNS_server

			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				dnsServer := &ves_io_schema_network_interface.NetworkInterfaceDNS{}
				interfaceChoiceInt.LegacyInterface.DNSServer = dnsServer
				for _, set := range sl {
					dnsServerMapStrToI := set.(map[string]interface{})

					// dns_mode

					if v, ok := dnsServerMapStrToI["dns_mode"]; ok && !isIntfNil(v) {

						dnsServer.DnsMode = ves_io_schema_network_interface.NetworkInterfaceDNSMode(ves_io_schema_network_interface.NetworkInterfaceDNSMode_value[v.(string)])

					}

					// dns_server

					if v, ok := dnsServerMapStrToI["dns_server"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						dnsServerIpv4s := make([]*ves_io_schema.Ipv4AddressType, len(sl))
						dnsServer.DnsServer = dnsServerIpv4s
						for i, set := range sl {
							dnsServerIpv4s[i] = &ves_io_schema.Ipv4AddressType{}
							dnsServerMapStrToI := set.(map[string]interface{})

							// addr

							if w, ok := dnsServerMapStrToI["addr"]; ok && !isIntfNil(w) {
								dnsServerIpv4s[i].Addr = w.(string)
							}

						}

					}

				}

			}

			// address_allocator

			if v, ok := cs["address_allocator"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				addressAllocatorInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				interfaceChoiceInt.LegacyInterface.AddressAllocator = addressAllocatorInt
				for i, ps := range sl {

					aaMapToStrVal := ps.(map[string]interface{})
					addressAllocatorInt[i] = &ves_io_schema.ObjectRefType{}

					addressAllocatorInt[i].Kind = "address_allocator"

					if v, ok := aaMapToStrVal["name"]; ok && !isIntfNil(v) {
						addressAllocatorInt[i].Name = v.(string)
					}

					if v, ok := aaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						addressAllocatorInt[i].Namespace = v.(string)
					}

					if v, ok := aaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						addressAllocatorInt[i].Tenant = v.(string)
					}

					if v, ok := aaMapToStrVal["uid"]; ok && !isIntfNil(v) {
						addressAllocatorInt[i].Uid = v.(string)
					}

				}

			}

			// default_gateway

			if v, ok := cs["default_gateway"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				defaultGateway := &ves_io_schema_network_interface.NetworkInterfaceDFGW{}
				interfaceChoiceInt.LegacyInterface.DefaultGateway = defaultGateway
				for _, set := range sl {
					defaultGatewayMapStrToI := set.(map[string]interface{})

					// default_gateway_address

					if v, ok := defaultGatewayMapStrToI["default_gateway_address"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						defaultGatewayAddress := &ves_io_schema.Ipv4AddressType{}
						defaultGateway.DefaultGatewayAddress = defaultGatewayAddress
						for _, set := range sl {
							defaultGatewayAddressMapStrToI := set.(map[string]interface{})

							// addr

							if w, ok := defaultGatewayAddressMapStrToI["addr"]; ok && !isIntfNil(w) {
								defaultGatewayAddress.Addr = w.(string)
							}

						}

					}

					// default_gateway_mode

					if v, ok := defaultGatewayMapStrToI["default_gateway_mode"]; ok && !isIntfNil(v) {

						defaultGateway.DefaultGatewayMode = ves_io_schema_network_interface.NetworkInterfaceGatewayMode(ves_io_schema_network_interface.NetworkInterfaceGatewayMode_value[v.(string)])

					}

				}

			}

			// device_name

			if v, ok := cs["device_name"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.DeviceName = v.(string)
			}

			// dhcp_address

			if v, ok := cs["dhcp_address"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.DhcpAddress = ves_io_schema_network_interface.NetworkInterfaceDHCP(ves_io_schema_network_interface.NetworkInterfaceDHCP_value[v.(string)])

			}

			// monitoring_choice

			monitoringChoiceTypeFound := false

			if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true
				_ = v
			}

			if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true

				if v.(bool) {
					monitoringChoiceInt := &ves_io_schema_network_interface.LegacyInterfaceType_MonitorDisabled{}
					monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
					interfaceChoiceInt.LegacyInterface.MonitoringChoice = monitoringChoiceInt
				}

			}

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.Mtu = uint32(v.(int))
			}

			// priority

			if v, ok := cs["priority"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.Priority = uint32(v.(int))
			}

			// static_addresses

			if v, ok := cs["static_addresses"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				staticAddresses := make([]*ves_io_schema.Ipv4SubnetType, len(sl))
				interfaceChoiceInt.LegacyInterface.StaticAddresses = staticAddresses
				for i, set := range sl {
					staticAddresses[i] = &ves_io_schema.Ipv4SubnetType{}
					staticAddressesMapStrToI := set.(map[string]interface{})

					// plen

					if w, ok := staticAddressesMapStrToI["plen"]; ok && !isIntfNil(w) {
						staticAddresses[i].Plen = uint32(w.(int))
					}

					// prefix

					if w, ok := staticAddressesMapStrToI["prefix"]; ok && !isIntfNil(w) {
						staticAddresses[i].Prefix = w.(string)
					}

				}

			}

			// tunnel

			if v, ok := cs["tunnel"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				tunnel := &ves_io_schema_network_interface.NetworkInterfaceTunnel{}
				interfaceChoiceInt.LegacyInterface.Tunnel = tunnel
				for _, set := range sl {
					tunnelMapStrToI := set.(map[string]interface{})

					// tunnel

					if v, ok := tunnelMapStrToI["tunnel"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						tunnelInt := make([]*ves_io_schema.ObjectRefType, len(sl))
						tunnel.Tunnel = tunnelInt
						for i, ps := range sl {

							tMapToStrVal := ps.(map[string]interface{})
							tunnelInt[i] = &ves_io_schema.ObjectRefType{}

							tunnelInt[i].Kind = "tunnel"

							if v, ok := tMapToStrVal["name"]; ok && !isIntfNil(v) {
								tunnelInt[i].Name = v.(string)
							}

							if v, ok := tMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								tunnelInt[i].Namespace = v.(string)
							}

							if v, ok := tMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								tunnelInt[i].Tenant = v.(string)
							}

							if v, ok := tMapToStrVal["uid"]; ok && !isIntfNil(v) {
								tunnelInt[i].Uid = v.(string)
							}

						}

					}

				}

			}

			// type

			if v, ok := cs["type"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.Type = ves_io_schema_network_interface.NetworkInterfaceType(ves_io_schema_network_interface.NetworkInterfaceType_value[v.(string)])

			}

			// virtual_network

			if v, ok := cs["virtual_network"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				virtualNetworkInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				interfaceChoiceInt.LegacyInterface.VirtualNetwork = virtualNetworkInt
				for i, ps := range sl {

					vnMapToStrVal := ps.(map[string]interface{})
					virtualNetworkInt[i] = &ves_io_schema.ObjectRefType{}

					virtualNetworkInt[i].Kind = "virtual_network"

					if v, ok := vnMapToStrVal["name"]; ok && !isIntfNil(v) {
						virtualNetworkInt[i].Name = v.(string)
					}

					if v, ok := vnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						virtualNetworkInt[i].Namespace = v.(string)
					}

					if v, ok := vnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						virtualNetworkInt[i].Tenant = v.(string)
					}

					if v, ok := vnMapToStrVal["uid"]; ok && !isIntfNil(v) {
						virtualNetworkInt[i].Uid = v.(string)
					}

				}

			}

			// vlan_tag

			if v, ok := cs["vlan_tag"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.VlanTag = uint32(v.(int))
			}

			// vlan_tagging

			if v, ok := cs["vlan_tagging"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.VlanTagging = ves_io_schema_network_interface.NetworkInterfaceVLANTagging(ves_io_schema_network_interface.NetworkInterfaceVLANTagging_value[v.(string)])

			}

		}

	}

	if v, ok := d.GetOk("tunnel_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.CreateSpecType_TunnelInterface{}
		interfaceChoiceInt.TunnelInterface = &ves_io_schema_network_interface.TunnelInterfaceType{}
		createSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.TunnelInterface.Mtu = uint32(v.(int))
			}

			// network_choice

			networkChoiceTypeFound := false

			if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true
				networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_InsideNetwork{}
				networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
				interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					// name

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Name = v.(string)
					}

					// namespace

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Namespace = v.(string)
					}

					// tenant

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Tenant = v.(string)
					}

				}

			}

			if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalInsideNetwork{}
					networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
				}

			}

			if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalNetwork{}
					networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
				}

			}

			// node_choice

			nodeChoiceTypeFound := false

			if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true

				if v.(bool) {
					nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Cluster{}
					nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
					interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt
				}

			}

			if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true
				nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Node{}

				interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt

				nodeChoiceInt.Node = v.(string)

			}

			// priority

			if v, ok := cs["priority"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.TunnelInterface.Priority = uint32(v.(int))
			}

			// static_ip

			if v, ok := cs["static_ip"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				staticIp := &ves_io_schema_network_interface.StaticIPParametersType{}
				interfaceChoiceInt.TunnelInterface.StaticIp = staticIp
				for _, set := range sl {
					staticIpMapStrToI := set.(map[string]interface{})

					// network_prefix_choice

					networkPrefixChoiceTypeFound := false

					if v, ok := staticIpMapStrToI["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
						networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
						staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// interface_ip_map

							if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

								sl := v.(*schema.Set).List()
								interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
								networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
								for _, set := range sl {
									interfaceIpMapMapStrToI := set.(map[string]interface{})
									key, ok := interfaceIpMapMapStrToI["name"]
									if ok && !isIntfNil(key) {
										interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										val, _ := interfaceIpMapMapStrToI["value"]

										interfaceIpMapVals := val.(*schema.Set).List()
										for _, intVal := range interfaceIpMapVals {

											interfaceIpMapStaticMap := intVal.(map[string]interface{})

											if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].DefaultGw = w.(string)
											}

											if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].DnsServer = w.(string)
											}

											if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].IpAddress = w.(string)
											}

											// break after one loop
											break
										}
									}
								}

							}

						}

					}

					if v, ok := staticIpMapStrToI["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
						networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
						staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// default_gw

							if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)
							}

							// dns_server

							if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)
							}

							// network_prefix_allocator

							if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

								networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
								networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

								npaMapToStrVal := v.(map[string]interface{})
								if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Name = val.(string)
								}
								if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Namespace = val.(string)
								}

								if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Tenant = val.(string)
								}

							}

						}

					}

					if v, ok := staticIpMapStrToI["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
						networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
						staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// default_gw

							if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)
							}

							// dns_server

							if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)
							}

							// ip_address

							if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)
							}

						}

					}

				}

			}

			// tunnel

			if v, ok := cs["tunnel"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				tunnelInt := &ves_io_schema_views.ObjectRefType{}
				interfaceChoiceInt.TunnelInterface.Tunnel = tunnelInt

				for _, set := range sl {

					tMapToStrVal := set.(map[string]interface{})
					if val, ok := tMapToStrVal["name"]; ok && !isIntfNil(v) {
						tunnelInt.Name = val.(string)
					}
					if val, ok := tMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						tunnelInt.Namespace = val.(string)
					}

					if val, ok := tMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						tunnelInt.Tenant = val.(string)
					}
				}
			}

		}

	}

	log.Printf("[DEBUG] Creating Volterra NetworkInterface object with struct: %+v", createReq)

	createNetworkInterfaceResp, err := client.CreateObject(context.Background(), ves_io_schema_network_interface.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating NetworkInterface: %s", err)
	}
	d.SetId(createNetworkInterfaceResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraNetworkInterfaceRead(d, meta)
}

func resourceVolterraNetworkInterfaceRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_network_interface.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] NetworkInterface %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra NetworkInterface %q: %s", d.Id(), err)
	}
	return setNetworkInterfaceFields(client, d, resp)
}

func setNetworkInterfaceFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraNetworkInterfaceUpdate updates NetworkInterface resource
func resourceVolterraNetworkInterfaceUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_network_interface.ReplaceSpecType{}
	updateReq := &ves_io_schema_network_interface.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}
	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	interfaceChoiceTypeFound := false

	if v, ok := d.GetOk("dedicated_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.ReplaceSpecType_DedicatedInterface{}
		interfaceChoiceInt.DedicatedInterface = &ves_io_schema_network_interface.DedicatedInterfaceType{}
		updateSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// device

			if v, ok := cs["device"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedInterface.Device = v.(string)
			}

			// monitoring_choice

			monitoringChoiceTypeFound := false

			if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true
				_ = v
			}

			if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true

				if v.(bool) {
					monitoringChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_MonitorDisabled{}
					monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedInterface.MonitoringChoice = monitoringChoiceInt
				}

			}

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedInterface.Mtu = uint32(v.(int))
			}

			// node_choice

			nodeChoiceTypeFound := false

			if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true

				if v.(bool) {
					nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Cluster{}
					nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt
				}

			}

			if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true
				nodeChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_Node{}

				interfaceChoiceInt.DedicatedInterface.NodeChoice = nodeChoiceInt

				nodeChoiceInt.Node = v.(string)

			}

			// primary_choice

			primaryChoiceTypeFound := false

			if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

				primaryChoiceTypeFound = true

				if v.(bool) {
					primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_IsPrimary{}
					primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
				}

			}

			if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

				primaryChoiceTypeFound = true

				if v.(bool) {
					primaryChoiceInt := &ves_io_schema_network_interface.DedicatedInterfaceType_NotPrimary{}
					primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedInterface.PrimaryChoice = primaryChoiceInt
				}

			}

			// priority

			if v, ok := cs["priority"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedInterface.Priority = uint32(v.(int))
			}

		}

	}

	if v, ok := d.GetOk("dedicated_management_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.ReplaceSpecType_DedicatedManagementInterface{}
		interfaceChoiceInt.DedicatedManagementInterface = &ves_io_schema_network_interface.DedicatedManagementInterfaceType{}
		updateSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// device

			if v, ok := cs["device"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedManagementInterface.Device = v.(string)
			}

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.DedicatedManagementInterface.Mtu = uint32(v.(int))
			}

			// node_choice

			nodeChoiceTypeFound := false

			if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true

				if v.(bool) {
					nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Cluster{}
					nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
					interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt
				}

			}

			if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true
				nodeChoiceInt := &ves_io_schema_network_interface.DedicatedManagementInterfaceType_Node{}

				interfaceChoiceInt.DedicatedManagementInterface.NodeChoice = nodeChoiceInt

				nodeChoiceInt.Node = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("ethernet_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.ReplaceSpecType_EthernetInterface{}
		interfaceChoiceInt.EthernetInterface = &ves_io_schema_network_interface.EthernetInterfaceType{}
		updateSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// address_choice

			addressChoiceTypeFound := false

			if v, ok := cs["dhcp_client"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

				addressChoiceTypeFound = true

				if v.(bool) {
					addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpClient{}
					addressChoiceInt.DhcpClient = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt
				}

			}

			if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

				addressChoiceTypeFound = true
				addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_DhcpServer{}
				addressChoiceInt.DhcpServer = &ves_io_schema_network_interface.DHCPServerParametersType{}
				interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					// dhcp_networks

					if v, ok := cs["dhcp_networks"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						dhcpNetworks := make([]*ves_io_schema_network_interface.DHCPNetworkType, len(sl))
						addressChoiceInt.DhcpServer.DhcpNetworks = dhcpNetworks
						for i, set := range sl {
							dhcpNetworks[i] = &ves_io_schema_network_interface.DHCPNetworkType{}
							dhcpNetworksMapStrToI := set.(map[string]interface{})

							// dns_choice

							dnsChoiceTypeFound := false

							if v, ok := dhcpNetworksMapStrToI["dns_address"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

								dnsChoiceTypeFound = true
								dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DnsAddress{}

								dhcpNetworks[i].DnsChoice = dnsChoiceInt

								dnsChoiceInt.DnsAddress = v.(string)

							}

							if v, ok := dhcpNetworksMapStrToI["same_as_dgw"]; ok && !isIntfNil(v) && !dnsChoiceTypeFound {

								dnsChoiceTypeFound = true

								if v.(bool) {
									dnsChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_SameAsDgw{}
									dnsChoiceInt.SameAsDgw = &ves_io_schema.Empty{}
									dhcpNetworks[i].DnsChoice = dnsChoiceInt
								}

							}

							// gateway_choice

							gatewayChoiceTypeFound := false

							if v, ok := dhcpNetworksMapStrToI["dgw_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

								gatewayChoiceTypeFound = true
								gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_DgwAddress{}

								dhcpNetworks[i].GatewayChoice = gatewayChoiceInt

								gatewayChoiceInt.DgwAddress = v.(string)

							}

							if v, ok := dhcpNetworksMapStrToI["first_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

								gatewayChoiceTypeFound = true

								if v.(bool) {
									gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_FirstAddress{}
									gatewayChoiceInt.FirstAddress = &ves_io_schema.Empty{}
									dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
								}

							}

							if v, ok := dhcpNetworksMapStrToI["last_address"]; ok && !isIntfNil(v) && !gatewayChoiceTypeFound {

								gatewayChoiceTypeFound = true

								if v.(bool) {
									gatewayChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_LastAddress{}
									gatewayChoiceInt.LastAddress = &ves_io_schema.Empty{}
									dhcpNetworks[i].GatewayChoice = gatewayChoiceInt
								}

							}

							// network_prefix_choice

							networkPrefixChoiceTypeFound := false

							if v, ok := dhcpNetworksMapStrToI["network_prefix"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

								networkPrefixChoiceTypeFound = true
								networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefix{}

								dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

								networkPrefixChoiceInt.NetworkPrefix = v.(string)

							}

							if v, ok := dhcpNetworksMapStrToI["network_prefix_allocator"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

								networkPrefixChoiceTypeFound = true
								networkPrefixChoiceInt := &ves_io_schema_network_interface.DHCPNetworkType_NetworkPrefixAllocator{}
								networkPrefixChoiceInt.NetworkPrefixAllocator = &ves_io_schema_views.ObjectRefType{}
								dhcpNetworks[i].NetworkPrefixChoice = networkPrefixChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									// name

									if v, ok := cs["name"]; ok && !isIntfNil(v) {

										networkPrefixChoiceInt.NetworkPrefixAllocator.Name = v.(string)
									}

									// namespace

									if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

										networkPrefixChoiceInt.NetworkPrefixAllocator.Namespace = v.(string)
									}

									// tenant

									if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

										networkPrefixChoiceInt.NetworkPrefixAllocator.Tenant = v.(string)
									}

								}

							}

							// pool_settings

							if v, ok := dhcpNetworksMapStrToI["pool_settings"]; ok && !isIntfNil(v) {

								dhcpNetworks[i].PoolSettings = ves_io_schema_network_interface.DHCPPoolSettingType(ves_io_schema_network_interface.DHCPPoolSettingType_value[v.(string)])

							}

							// pools

							if v, ok := dhcpNetworksMapStrToI["pools"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								pools := make([]*ves_io_schema_network_interface.DHCPPoolType, len(sl))
								dhcpNetworks[i].Pools = pools
								for i, set := range sl {
									pools[i] = &ves_io_schema_network_interface.DHCPPoolType{}
									poolsMapStrToI := set.(map[string]interface{})

									// end_ip

									if w, ok := poolsMapStrToI["end_ip"]; ok && !isIntfNil(w) {
										pools[i].EndIp = w.(string)
									}

									// exclude

									if w, ok := poolsMapStrToI["exclude"]; ok && !isIntfNil(w) {
										pools[i].Exclude = w.(bool)
									}

									// start_ip

									if w, ok := poolsMapStrToI["start_ip"]; ok && !isIntfNil(w) {
										pools[i].StartIp = w.(string)
									}

								}

							}

						}

					}

					// dhcp_option82_tag

					if v, ok := cs["dhcp_option82_tag"]; ok && !isIntfNil(v) {

						addressChoiceInt.DhcpServer.DhcpOption82Tag = v.(string)
					}

					// fixed_ip_map

					if v, ok := cs["fixed_ip_map"]; ok && !isIntfNil(v) {

						ms := map[string]string{}
						for k, v := range v.(map[string]interface{}) {
							ms[k] = v.(string)
						}
						addressChoiceInt.DhcpServer.FixedIpMap = ms
					}

					// interfaces_addressing_choice

					interfacesAddressingChoiceTypeFound := false

					if v, ok := cs["automatic_from_end"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

						interfacesAddressingChoiceTypeFound = true

						if v.(bool) {
							interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromEnd{}
							interfacesAddressingChoiceInt.AutomaticFromEnd = &ves_io_schema.Empty{}
							addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
						}

					}

					if v, ok := cs["automatic_from_start"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

						interfacesAddressingChoiceTypeFound = true

						if v.(bool) {
							interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_AutomaticFromStart{}
							interfacesAddressingChoiceInt.AutomaticFromStart = &ves_io_schema.Empty{}
							addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt
						}

					}

					if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) && !interfacesAddressingChoiceTypeFound {

						interfacesAddressingChoiceTypeFound = true
						interfacesAddressingChoiceInt := &ves_io_schema_network_interface.DHCPServerParametersType_InterfaceIpMap{}
						interfacesAddressingChoiceInt.InterfaceIpMap = &ves_io_schema_network_interface.DHCPInterfaceIPType{}
						addressChoiceInt.DhcpServer.InterfacesAddressingChoice = interfacesAddressingChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// interface_ip_map

							if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

								ms := map[string]string{}
								for k, v := range v.(map[string]interface{}) {
									ms[k] = v.(string)
								}
								interfacesAddressingChoiceInt.InterfaceIpMap.InterfaceIpMap = ms
							}

						}

					}

				}

			}

			if v, ok := cs["static_ip"]; ok && !isIntfNil(v) && !addressChoiceTypeFound {

				addressChoiceTypeFound = true
				addressChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StaticIp{}
				addressChoiceInt.StaticIp = &ves_io_schema_network_interface.StaticIPParametersType{}
				interfaceChoiceInt.EthernetInterface.AddressChoice = addressChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					// network_prefix_choice

					networkPrefixChoiceTypeFound := false

					if v, ok := cs["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
						networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
						addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// interface_ip_map

							if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

								sl := v.(*schema.Set).List()
								interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
								networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
								for _, set := range sl {
									interfaceIpMapMapStrToI := set.(map[string]interface{})
									key, ok := interfaceIpMapMapStrToI["name"]
									if ok && !isIntfNil(key) {
										interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										val, _ := interfaceIpMapMapStrToI["value"]

										interfaceIpMapVals := val.(*schema.Set).List()
										for _, intVal := range interfaceIpMapVals {

											interfaceIpMapStaticMap := intVal.(map[string]interface{})

											if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].DefaultGw = w.(string)
											}

											if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].DnsServer = w.(string)
											}

											if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].IpAddress = w.(string)
											}

											// break after one loop
											break
										}
									}
								}

							}

						}

					}

					if v, ok := cs["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
						networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
						addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// default_gw

							if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)
							}

							// dns_server

							if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)
							}

							// network_prefix_allocator

							if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

								networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
								networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

								npaMapToStrVal := v.(map[string]interface{})
								if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Name = val.(string)
								}
								if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Namespace = val.(string)
								}

								if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Tenant = val.(string)
								}

							}

						}

					}

					if v, ok := cs["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
						networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
						addressChoiceInt.StaticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// default_gw

							if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)
							}

							// dns_server

							if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)
							}

							// ip_address

							if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)
							}

						}

					}

				}

			}

			// device

			if v, ok := cs["device"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.EthernetInterface.Device = v.(string)
			}

			// monitoring_choice

			monitoringChoiceTypeFound := false

			if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true
				_ = v
			}

			if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true

				if v.(bool) {
					monitoringChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_MonitorDisabled{}
					monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.MonitoringChoice = monitoringChoiceInt
				}

			}

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.EthernetInterface.Mtu = uint32(v.(int))
			}

			// network_choice

			networkChoiceTypeFound := false

			if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true
				networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_InsideNetwork{}
				networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
				interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					// name

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Name = v.(string)
					}

					// namespace

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Namespace = v.(string)
					}

					// tenant

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Tenant = v.(string)
					}

				}

			}

			if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{}
					networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
				}

			}

			if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_SiteLocalNetwork{}
					networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
				}

			}

			if v, ok := cs["storage_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_StorageNetwork{}
					networkChoiceInt.StorageNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.NetworkChoice = networkChoiceInt
				}

			}

			// node_choice

			nodeChoiceTypeFound := false

			if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true

				if v.(bool) {
					nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Cluster{}
					nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt
				}

			}

			if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true
				nodeChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Node{}

				interfaceChoiceInt.EthernetInterface.NodeChoice = nodeChoiceInt

				nodeChoiceInt.Node = v.(string)

			}

			// primary_choice

			primaryChoiceTypeFound := false

			if v, ok := cs["is_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

				primaryChoiceTypeFound = true

				if v.(bool) {
					primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_IsPrimary{}
					primaryChoiceInt.IsPrimary = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
				}

			}

			if v, ok := cs["not_primary"]; ok && !isIntfNil(v) && !primaryChoiceTypeFound {

				primaryChoiceTypeFound = true

				if v.(bool) {
					primaryChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_NotPrimary{}
					primaryChoiceInt.NotPrimary = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.PrimaryChoice = primaryChoiceInt
				}

			}

			// priority

			if v, ok := cs["priority"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.EthernetInterface.Priority = uint32(v.(int))
			}

			// vlan_choice

			vlanChoiceTypeFound := false

			if v, ok := cs["untagged"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

				vlanChoiceTypeFound = true

				if v.(bool) {
					vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_Untagged{}
					vlanChoiceInt.Untagged = &ves_io_schema.Empty{}
					interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt
				}

			}

			if v, ok := cs["vlan_id"]; ok && !isIntfNil(v) && !vlanChoiceTypeFound {

				vlanChoiceTypeFound = true
				vlanChoiceInt := &ves_io_schema_network_interface.EthernetInterfaceType_VlanId{}

				interfaceChoiceInt.EthernetInterface.VlanChoice = vlanChoiceInt

				vlanChoiceInt.VlanId =
					uint32(v.(int))

			}

		}

	}

	if v, ok := d.GetOk("legacy_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.ReplaceSpecType_LegacyInterface{}
		interfaceChoiceInt.LegacyInterface = &ves_io_schema_network_interface.LegacyInterfaceType{}
		updateSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// DHCP_server

			if v, ok := cs["dhcp_server"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.DHCPServer = ves_io_schema_network_interface.NetworkInterfaceDHCPServer(ves_io_schema_network_interface.NetworkInterfaceDHCPServer_value[v.(string)])

			}

			// DNS_server

			if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				dnsServer := &ves_io_schema_network_interface.NetworkInterfaceDNS{}
				interfaceChoiceInt.LegacyInterface.DNSServer = dnsServer
				for _, set := range sl {
					dnsServerMapStrToI := set.(map[string]interface{})

					// dns_mode

					if v, ok := dnsServerMapStrToI["dns_mode"]; ok && !isIntfNil(v) {

						dnsServer.DnsMode = ves_io_schema_network_interface.NetworkInterfaceDNSMode(ves_io_schema_network_interface.NetworkInterfaceDNSMode_value[v.(string)])

					}

					// dns_server

					if v, ok := dnsServerMapStrToI["dns_server"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						dnsServerIpv4s := make([]*ves_io_schema.Ipv4AddressType, len(sl))
						dnsServer.DnsServer = dnsServerIpv4s
						for i, set := range sl {
							dnsServerIpv4s[i] = &ves_io_schema.Ipv4AddressType{}
							dnsServerMapStrToI := set.(map[string]interface{})

							// addr

							if w, ok := dnsServerMapStrToI["addr"]; ok && !isIntfNil(w) {
								dnsServerIpv4s[i].Addr = w.(string)
							}

						}

					}

				}

			}

			// address_allocator

			if v, ok := cs["address_allocator"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				addressAllocatorInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				interfaceChoiceInt.LegacyInterface.AddressAllocator = addressAllocatorInt
				for i, ps := range sl {

					aaMapToStrVal := ps.(map[string]interface{})
					addressAllocatorInt[i] = &ves_io_schema.ObjectRefType{}

					addressAllocatorInt[i].Kind = "address_allocator"

					if v, ok := aaMapToStrVal["name"]; ok && !isIntfNil(v) {
						addressAllocatorInt[i].Name = v.(string)
					}

					if v, ok := aaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						addressAllocatorInt[i].Namespace = v.(string)
					}

					if v, ok := aaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						addressAllocatorInt[i].Tenant = v.(string)
					}

					if v, ok := aaMapToStrVal["uid"]; ok && !isIntfNil(v) {
						addressAllocatorInt[i].Uid = v.(string)
					}

				}

			}

			// default_gateway

			if v, ok := cs["default_gateway"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				defaultGateway := &ves_io_schema_network_interface.NetworkInterfaceDFGW{}
				interfaceChoiceInt.LegacyInterface.DefaultGateway = defaultGateway
				for _, set := range sl {
					defaultGatewayMapStrToI := set.(map[string]interface{})

					// default_gateway_address

					if v, ok := defaultGatewayMapStrToI["default_gateway_address"]; ok && !isIntfNil(v) {

						sl := v.(*schema.Set).List()
						defaultGatewayAddress := &ves_io_schema.Ipv4AddressType{}
						defaultGateway.DefaultGatewayAddress = defaultGatewayAddress
						for _, set := range sl {
							defaultGatewayAddressMapStrToI := set.(map[string]interface{})

							// addr

							if w, ok := defaultGatewayAddressMapStrToI["addr"]; ok && !isIntfNil(w) {
								defaultGatewayAddress.Addr = w.(string)
							}

						}

					}

					// default_gateway_mode

					if v, ok := defaultGatewayMapStrToI["default_gateway_mode"]; ok && !isIntfNil(v) {

						defaultGateway.DefaultGatewayMode = ves_io_schema_network_interface.NetworkInterfaceGatewayMode(ves_io_schema_network_interface.NetworkInterfaceGatewayMode_value[v.(string)])

					}

				}

			}

			// device_name

			if v, ok := cs["device_name"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.DeviceName = v.(string)
			}

			// dhcp_address

			if v, ok := cs["dhcp_address"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.DhcpAddress = ves_io_schema_network_interface.NetworkInterfaceDHCP(ves_io_schema_network_interface.NetworkInterfaceDHCP_value[v.(string)])

			}

			// monitoring_choice

			monitoringChoiceTypeFound := false

			if v, ok := cs["monitor"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true
				_ = v
			}

			if v, ok := cs["monitor_disabled"]; ok && !isIntfNil(v) && !monitoringChoiceTypeFound {

				monitoringChoiceTypeFound = true

				if v.(bool) {
					monitoringChoiceInt := &ves_io_schema_network_interface.LegacyInterfaceType_MonitorDisabled{}
					monitoringChoiceInt.MonitorDisabled = &ves_io_schema.Empty{}
					interfaceChoiceInt.LegacyInterface.MonitoringChoice = monitoringChoiceInt
				}

			}

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.Mtu = uint32(v.(int))
			}

			// priority

			if v, ok := cs["priority"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.Priority = uint32(v.(int))
			}

			// static_addresses

			if v, ok := cs["static_addresses"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				staticAddresses := make([]*ves_io_schema.Ipv4SubnetType, len(sl))
				interfaceChoiceInt.LegacyInterface.StaticAddresses = staticAddresses
				for i, set := range sl {
					staticAddresses[i] = &ves_io_schema.Ipv4SubnetType{}
					staticAddressesMapStrToI := set.(map[string]interface{})

					// plen

					if w, ok := staticAddressesMapStrToI["plen"]; ok && !isIntfNil(w) {
						staticAddresses[i].Plen = uint32(w.(int))
					}

					// prefix

					if w, ok := staticAddressesMapStrToI["prefix"]; ok && !isIntfNil(w) {
						staticAddresses[i].Prefix = w.(string)
					}

				}

			}

			// tunnel

			if v, ok := cs["tunnel"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				tunnel := &ves_io_schema_network_interface.NetworkInterfaceTunnel{}
				interfaceChoiceInt.LegacyInterface.Tunnel = tunnel
				for _, set := range sl {
					tunnelMapStrToI := set.(map[string]interface{})

					// tunnel

					if v, ok := tunnelMapStrToI["tunnel"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						tunnelInt := make([]*ves_io_schema.ObjectRefType, len(sl))
						tunnel.Tunnel = tunnelInt
						for i, ps := range sl {

							tMapToStrVal := ps.(map[string]interface{})
							tunnelInt[i] = &ves_io_schema.ObjectRefType{}

							tunnelInt[i].Kind = "tunnel"

							if v, ok := tMapToStrVal["name"]; ok && !isIntfNil(v) {
								tunnelInt[i].Name = v.(string)
							}

							if v, ok := tMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								tunnelInt[i].Namespace = v.(string)
							}

							if v, ok := tMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								tunnelInt[i].Tenant = v.(string)
							}

							if v, ok := tMapToStrVal["uid"]; ok && !isIntfNil(v) {
								tunnelInt[i].Uid = v.(string)
							}

						}

					}

				}

			}

			// type

			if v, ok := cs["type"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.Type = ves_io_schema_network_interface.NetworkInterfaceType(ves_io_schema_network_interface.NetworkInterfaceType_value[v.(string)])

			}

			// virtual_network

			if v, ok := cs["virtual_network"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				virtualNetworkInt := make([]*ves_io_schema.ObjectRefType, len(sl))
				interfaceChoiceInt.LegacyInterface.VirtualNetwork = virtualNetworkInt
				for i, ps := range sl {

					vnMapToStrVal := ps.(map[string]interface{})
					virtualNetworkInt[i] = &ves_io_schema.ObjectRefType{}

					virtualNetworkInt[i].Kind = "virtual_network"

					if v, ok := vnMapToStrVal["name"]; ok && !isIntfNil(v) {
						virtualNetworkInt[i].Name = v.(string)
					}

					if v, ok := vnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						virtualNetworkInt[i].Namespace = v.(string)
					}

					if v, ok := vnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						virtualNetworkInt[i].Tenant = v.(string)
					}

					if v, ok := vnMapToStrVal["uid"]; ok && !isIntfNil(v) {
						virtualNetworkInt[i].Uid = v.(string)
					}

				}

			}

			// vlan_tag

			if v, ok := cs["vlan_tag"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.VlanTag = uint32(v.(int))
			}

			// vlan_tagging

			if v, ok := cs["vlan_tagging"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.LegacyInterface.VlanTagging = ves_io_schema_network_interface.NetworkInterfaceVLANTagging(ves_io_schema_network_interface.NetworkInterfaceVLANTagging_value[v.(string)])

			}

		}

	}

	if v, ok := d.GetOk("tunnel_interface"); ok && !interfaceChoiceTypeFound {

		interfaceChoiceTypeFound = true
		interfaceChoiceInt := &ves_io_schema_network_interface.ReplaceSpecType_TunnelInterface{}
		interfaceChoiceInt.TunnelInterface = &ves_io_schema_network_interface.TunnelInterfaceType{}
		updateSpec.InterfaceChoice = interfaceChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			// mtu

			if v, ok := cs["mtu"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.TunnelInterface.Mtu = uint32(v.(int))
			}

			// network_choice

			networkChoiceTypeFound := false

			if v, ok := cs["inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true
				networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_InsideNetwork{}
				networkChoiceInt.InsideNetwork = &ves_io_schema_views.ObjectRefType{}
				interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					// name

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Name = v.(string)
					}

					// namespace

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Namespace = v.(string)
					}

					// tenant

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						networkChoiceInt.InsideNetwork.Tenant = v.(string)
					}

				}

			}

			if v, ok := cs["site_local_inside_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalInsideNetwork{}
					networkChoiceInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
				}

			}

			if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) && !networkChoiceTypeFound {

				networkChoiceTypeFound = true

				if v.(bool) {
					networkChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_SiteLocalNetwork{}
					networkChoiceInt.SiteLocalNetwork = &ves_io_schema.Empty{}
					interfaceChoiceInt.TunnelInterface.NetworkChoice = networkChoiceInt
				}

			}

			// node_choice

			nodeChoiceTypeFound := false

			if v, ok := cs["cluster"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true

				if v.(bool) {
					nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Cluster{}
					nodeChoiceInt.Cluster = &ves_io_schema.Empty{}
					interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt
				}

			}

			if v, ok := cs["node"]; ok && !isIntfNil(v) && !nodeChoiceTypeFound {

				nodeChoiceTypeFound = true
				nodeChoiceInt := &ves_io_schema_network_interface.TunnelInterfaceType_Node{}

				interfaceChoiceInt.TunnelInterface.NodeChoice = nodeChoiceInt

				nodeChoiceInt.Node = v.(string)

			}

			// priority

			if v, ok := cs["priority"]; ok && !isIntfNil(v) {

				interfaceChoiceInt.TunnelInterface.Priority = uint32(v.(int))
			}

			// static_ip

			if v, ok := cs["static_ip"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				staticIp := &ves_io_schema_network_interface.StaticIPParametersType{}
				interfaceChoiceInt.TunnelInterface.StaticIp = staticIp
				for _, set := range sl {
					staticIpMapStrToI := set.(map[string]interface{})

					// network_prefix_choice

					networkPrefixChoiceTypeFound := false

					if v, ok := staticIpMapStrToI["cluster_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_ClusterStaticIp{}
						networkPrefixChoiceInt.ClusterStaticIp = &ves_io_schema_network_interface.StaticIpParametersClusterType{}
						staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// interface_ip_map

							if v, ok := cs["interface_ip_map"]; ok && !isIntfNil(v) {

								sl := v.(*schema.Set).List()
								interfaceIpMap := make(map[string]*ves_io_schema_network_interface.StaticIpParametersNodeType)
								networkPrefixChoiceInt.ClusterStaticIp.InterfaceIpMap = interfaceIpMap
								for _, set := range sl {
									interfaceIpMapMapStrToI := set.(map[string]interface{})
									key, ok := interfaceIpMapMapStrToI["name"]
									if ok && !isIntfNil(key) {
										interfaceIpMap[key.(string)] = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
										val, _ := interfaceIpMapMapStrToI["value"]

										interfaceIpMapVals := val.(*schema.Set).List()
										for _, intVal := range interfaceIpMapVals {

											interfaceIpMapStaticMap := intVal.(map[string]interface{})

											if w, ok := interfaceIpMapStaticMap["default_gw"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].DefaultGw = w.(string)
											}

											if w, ok := interfaceIpMapStaticMap["dns_server"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].DnsServer = w.(string)
											}

											if w, ok := interfaceIpMapStaticMap["ip_address"]; ok && !isIntfNil(w) {
												interfaceIpMap[key.(string)].IpAddress = w.(string)
											}

											// break after one loop
											break
										}
									}
								}

							}

						}

					}

					if v, ok := staticIpMapStrToI["fleet_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_FleetStaticIp{}
						networkPrefixChoiceInt.FleetStaticIp = &ves_io_schema_network_interface.StaticIpParametersFleetType{}
						staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// default_gw

							if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.FleetStaticIp.DefaultGw = v.(string)
							}

							// dns_server

							if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.FleetStaticIp.DnsServer = v.(string)
							}

							// network_prefix_allocator

							if v, ok := cs["network_prefix_allocator"]; ok && !isIntfNil(v) {

								networkPrefixAllocatorInt := &ves_io_schema_views.ObjectRefType{}
								networkPrefixChoiceInt.FleetStaticIp.NetworkPrefixAllocator = networkPrefixAllocatorInt

								npaMapToStrVal := v.(map[string]interface{})
								if val, ok := npaMapToStrVal["name"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Name = val.(string)
								}
								if val, ok := npaMapToStrVal["namespace"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Namespace = val.(string)
								}

								if val, ok := npaMapToStrVal["tenant"]; ok && !isIntfNil(v) {
									networkPrefixAllocatorInt.Tenant = val.(string)
								}

							}

						}

					}

					if v, ok := staticIpMapStrToI["node_static_ip"]; ok && !isIntfNil(v) && !networkPrefixChoiceTypeFound {

						networkPrefixChoiceTypeFound = true
						networkPrefixChoiceInt := &ves_io_schema_network_interface.StaticIPParametersType_NodeStaticIp{}
						networkPrefixChoiceInt.NodeStaticIp = &ves_io_schema_network_interface.StaticIpParametersNodeType{}
						staticIp.NetworkPrefixChoice = networkPrefixChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							// default_gw

							if v, ok := cs["default_gw"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.DefaultGw = v.(string)
							}

							// dns_server

							if v, ok := cs["dns_server"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.DnsServer = v.(string)
							}

							// ip_address

							if v, ok := cs["ip_address"]; ok && !isIntfNil(v) {

								networkPrefixChoiceInt.NodeStaticIp.IpAddress = v.(string)
							}

						}

					}

				}

			}

			// tunnel

			if v, ok := cs["tunnel"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				tunnelInt := &ves_io_schema_views.ObjectRefType{}
				interfaceChoiceInt.TunnelInterface.Tunnel = tunnelInt

				for _, set := range sl {

					tMapToStrVal := set.(map[string]interface{})
					if val, ok := tMapToStrVal["name"]; ok && !isIntfNil(v) {
						tunnelInt.Name = val.(string)
					}
					if val, ok := tMapToStrVal["namespace"]; ok && !isIntfNil(v) {
						tunnelInt.Namespace = val.(string)
					}

					if val, ok := tMapToStrVal["tenant"]; ok && !isIntfNil(v) {
						tunnelInt.Tenant = val.(string)
					}
				}
			}

		}

	}

	log.Printf("[DEBUG] Updating Volterra NetworkInterface obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_network_interface.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating NetworkInterface: %s", err)
	}

	return resourceVolterraNetworkInterfaceRead(d, meta)
}

func resourceVolterraNetworkInterfaceDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_network_interface.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] NetworkInterface %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra NetworkInterface before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra NetworkInterface obj with name %+v in namespace %+v", name, namespace)
	return client.DeleteObject(context.Background(), ves_io_schema_network_interface.ObjectType, namespace, name)
}
