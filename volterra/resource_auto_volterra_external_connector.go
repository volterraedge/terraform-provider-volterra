//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_external_connector "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/external_connector"
)

// resourceVolterraExternalConnector is implementation of Volterra's ExternalConnector resources
func resourceVolterraExternalConnector() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraExternalConnectorCreate,
		Read:   resourceVolterraExternalConnectorRead,
		Update: resourceVolterraExternalConnectorUpdate,
		Delete: resourceVolterraExternalConnectorDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"ce_site_reference": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Required: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"direct_connection": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{},
				},
			},

			"gre": {

				Type:       schema.TypeList,
				MaxItems:   1,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"gre_parameters": {

							Type:       schema.TypeList,
							MaxItems:   1,
							Optional:   true,
							Deprecated: "This field is deprecated and will be removed in future release.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"peer_ip_address": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"addr": {
													Type:       schema.TypeString,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"tunnel_eps": {

										Type:       schema.TypeList,
										Required:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"interface": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"local_tunnel_ip": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"node": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"remote_tunnel_ip": {
													Type:       schema.TypeString,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},

									"tunnel_mtu": {
										Type:       schema.TypeInt,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"segment": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"refs": {

													Type:       schema.TypeList,
													Required:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:       schema.TypeString,
																Computed:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"name": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"namespace": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"tenant": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"virtual_networks": {

													Type:       schema.TypeList,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:       schema.TypeString,
																Computed:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"name": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"namespace": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"tenant": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"site_local_inside_network": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"site_local_network": {

										Type:       schema.TypeBool,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},
								},
							},
						},
					},
				},
			},

			"ipsec": {

				Type:     schema.TypeList,
				MaxItems: 1,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"ike_parameters": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dpd_disabled": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"dpd_keep_alive_timer": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"timeout": {
													Type:     schema.TypeInt,
													Optional: true,
												},
											},
										},
									},

									"ike_phase1_profile": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"ike_phase2_profile": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"lc_hostname": {

										Type:       schema.TypeString,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
									},

									"lc_ip_address": {

										Type:       schema.TypeList,
										MaxItems:   1,
										Optional:   true,
										Deprecated: "This field is deprecated and will be removed in future release.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"ipv4": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"addr": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},

												"ipv6": {

													Type:       schema.TypeList,
													MaxItems:   1,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"addr": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"use_default_local_ike_id": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"initiator": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"responder": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"rm_hostname": {

										Type:     schema.TypeString,
										Optional: true,
									},

									"rm_ip_address": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"ipv4": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"addr": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"ipv6": {

													Type:     schema.TypeList,
													MaxItems: 1,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"addr": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},
											},
										},
									},

									"use_default_remote_ike_id": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"ipsec_tunnel_parameters": {

							Type:     schema.TypeList,
							MaxItems: 1,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"peer_ip_address": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"addr": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},

									"psk": {
										Type:     schema.TypeString,
										Required: true,
									},

									"tunnel_eps": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"interface": {
													Type:     schema.TypeString,
													Required: true,
												},

												"local_tunnel_ip": {
													Type:     schema.TypeString,
													Required: true,
												},

												"node": {
													Type:     schema.TypeString,
													Required: true,
												},

												"remote_tunnel_ip": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"tunnel_mtu": {
										Type:     schema.TypeInt,
										Required: true,
									},

									"segment": {

										Type:     schema.TypeList,
										MaxItems: 1,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"refs": {

													Type:     schema.TypeList,
													Required: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:     schema.TypeString,
																Computed: true,
															},

															"name": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"namespace": {
																Type:     schema.TypeString,
																Optional: true,
															},
															"tenant": {
																Type:     schema.TypeString,
																Optional: true,
															},
														},
													},
												},

												"virtual_networks": {

													Type:       schema.TypeList,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"kind": {
																Type:       schema.TypeString,
																Computed:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"name": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"namespace": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
															"tenant": {
																Type:       schema.TypeString,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},
														},
													},
												},
											},
										},
									},

									"site_local_inside_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"site_local_network": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// resourceVolterraExternalConnectorCreate creates ExternalConnector resource
func resourceVolterraExternalConnectorCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_external_connector.CreateSpecType{}
	createReq := &ves_io_schema_views_external_connector.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//ce_site_reference
	if v, ok := d.GetOk("ce_site_reference"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		ceSiteReferenceInt := &ves_io_schema_views.ObjectRefType{}
		createSpec.CeSiteReference = ceSiteReferenceInt

		for _, set := range sl {
			if set != nil {
				csrMapToStrVal := set.(map[string]interface{})
				if val, ok := csrMapToStrVal["name"]; ok && !isIntfNil(v) {
					ceSiteReferenceInt.Name = val.(string)
				}
				if val, ok := csrMapToStrVal["namespace"]; ok && !isIntfNil(v) {
					ceSiteReferenceInt.Namespace = val.(string)
				}

				if val, ok := csrMapToStrVal["tenant"]; ok && !isIntfNil(v) {
					ceSiteReferenceInt.Tenant = val.(string)
				}
			}
		}

	}

	//connection_type

	connectionTypeTypeFound := false

	if _, ok := d.GetOk("direct_connection"); ok && !connectionTypeTypeFound {

		connectionTypeTypeFound = true
		connectionTypeInt := &ves_io_schema_views_external_connector.CreateSpecType_DirectConnection{}
		connectionTypeInt.DirectConnection = &ves_io_schema_views_external_connector.ConnectionTypeDirect{}
		createSpec.ConnectionType = connectionTypeInt

	}

	if v, ok := d.GetOk("gre"); ok && !isIntfNil(v) && !connectionTypeTypeFound {

		connectionTypeTypeFound = true
		connectionTypeInt := &ves_io_schema_views_external_connector.CreateSpecType_Gre{}
		connectionTypeInt.Gre = &ves_io_schema_views_external_connector.ConnectionTypeGRE{}
		createSpec.ConnectionType = connectionTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["gre_parameters"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					greParameters := &ves_io_schema_views_external_connector.GRETunnelParameters{}
					connectionTypeInt.Gre.GreParameters = greParameters
					for _, set := range sl {
						if set != nil {
							greParametersMapStrToI := set.(map[string]interface{})

							if v, ok := greParametersMapStrToI["peer_ip_address"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								peerIpAddress := &ves_io_schema.Ipv4AddressType{}
								greParameters.PeerIpAddress = peerIpAddress
								for _, set := range sl {
									if set != nil {
										peerIpAddressMapStrToI := set.(map[string]interface{})

										if w, ok := peerIpAddressMapStrToI["addr"]; ok && !isIntfNil(w) {
											peerIpAddress.Addr = w.(string)
										}

									}
								}

							}

							if v, ok := greParametersMapStrToI["tunnel_eps"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								tunnelEps := make([]*ves_io_schema_views_external_connector.TunnelEndpoint, len(sl))
								greParameters.TunnelEps = tunnelEps
								for i, set := range sl {
									if set != nil {
										tunnelEps[i] = &ves_io_schema_views_external_connector.TunnelEndpoint{}
										tunnelEpsMapStrToI := set.(map[string]interface{})

										if w, ok := tunnelEpsMapStrToI["interface"]; ok && !isIntfNil(w) {
											tunnelEps[i].Interface = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["local_tunnel_ip"]; ok && !isIntfNil(w) {
											tunnelEps[i].LocalTunnelIp = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["node"]; ok && !isIntfNil(w) {
											tunnelEps[i].Node = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["remote_tunnel_ip"]; ok && !isIntfNil(w) {
											tunnelEps[i].RemoteTunnelIp = w.(string)
										}

									}
								}

							}

							if w, ok := greParametersMapStrToI["tunnel_mtu"]; ok && !isIntfNil(w) {
								greParameters.TunnelMtu = uint32(w.(int))
							}

							tunnelSourceVnTypeFound := false

							if v, ok := greParametersMapStrToI["segment"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true
								tunnelSourceVnInt := &ves_io_schema_views_external_connector.GRETunnelParameters_Segment{}
								tunnelSourceVnInt.Segment = &ves_io_schema.SegmentRefType{}
								greParameters.TunnelSourceVn = tunnelSourceVnInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["refs"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											refsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											tunnelSourceVnInt.Segment.Refs = refsInt
											for i, ps := range sl {
												if ps != nil {

													rMapToStrVal := ps.(map[string]interface{})
													refsInt[i] = &ves_io_schema.ObjectRefType{}

													refsInt[i].Kind = "segment"

													if v, ok := rMapToStrVal["name"]; ok && !isIntfNil(v) {
														refsInt[i].Name = v.(string)
													}

													if v, ok := rMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														refsInt[i].Namespace = v.(string)
													}

													if v, ok := rMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														refsInt[i].Tenant = v.(string)
													}

													if v, ok := rMapToStrVal["uid"]; ok && !isIntfNil(v) {
														refsInt[i].Uid = v.(string)
													}

												}
											}

										}

										if v, ok := cs["virtual_networks"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											virtualNetworksInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											tunnelSourceVnInt.Segment.VirtualNetworks = virtualNetworksInt
											for i, ps := range sl {
												if ps != nil {

													vnMapToStrVal := ps.(map[string]interface{})
													virtualNetworksInt[i] = &ves_io_schema.ObjectRefType{}

													virtualNetworksInt[i].Kind = "virtual_network"

													if v, ok := vnMapToStrVal["name"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Name = v.(string)
													}

													if v, ok := vnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Namespace = v.(string)
													}

													if v, ok := vnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Tenant = v.(string)
													}

													if v, ok := vnMapToStrVal["uid"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Uid = v.(string)
													}

												}
											}

										}

									}
								}

							}

							if v, ok := greParametersMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true

								if v.(bool) {
									tunnelSourceVnInt := &ves_io_schema_views_external_connector.GRETunnelParameters_SiteLocalInsideNetwork{}
									tunnelSourceVnInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
									greParameters.TunnelSourceVn = tunnelSourceVnInt
								}

							}

							if v, ok := greParametersMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true

								if v.(bool) {
									tunnelSourceVnInt := &ves_io_schema_views_external_connector.GRETunnelParameters_SiteLocalNetwork{}
									tunnelSourceVnInt.SiteLocalNetwork = &ves_io_schema.Empty{}
									greParameters.TunnelSourceVn = tunnelSourceVnInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ipsec"); ok && !isIntfNil(v) && !connectionTypeTypeFound {

		connectionTypeTypeFound = true
		connectionTypeInt := &ves_io_schema_views_external_connector.CreateSpecType_Ipsec{}
		connectionTypeInt.Ipsec = &ves_io_schema_views_external_connector.ConnectionTypeIPSec{}
		createSpec.ConnectionType = connectionTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["ike_parameters"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ikeParameters := &ves_io_schema_views_external_connector.IkeParameters{}
					connectionTypeInt.Ipsec.IkeParameters = ikeParameters
					for _, set := range sl {
						if set != nil {
							ikeParametersMapStrToI := set.(map[string]interface{})

							dpdChoiceTypeFound := false

							if v, ok := ikeParametersMapStrToI["dpd_disabled"]; ok && !isIntfNil(v) && !dpdChoiceTypeFound {

								dpdChoiceTypeFound = true

								if v.(bool) {
									dpdChoiceInt := &ves_io_schema_views_external_connector.IkeParameters_DpdDisabled{}
									dpdChoiceInt.DpdDisabled = &ves_io_schema.Empty{}
									ikeParameters.DpdChoice = dpdChoiceInt
								}

							}

							if v, ok := ikeParametersMapStrToI["dpd_keep_alive_timer"]; ok && !isIntfNil(v) && !dpdChoiceTypeFound {

								dpdChoiceTypeFound = true
								dpdChoiceInt := &ves_io_schema_views_external_connector.IkeParameters_DpdKeepAliveTimer{}
								dpdChoiceInt.DpdKeepAliveTimer = &ves_io_schema_views_external_connector.DpdKeepAliveTimer{}
								ikeParameters.DpdChoice = dpdChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["timeout"]; ok && !isIntfNil(v) {

											dpdChoiceInt.DpdKeepAliveTimer.Timeout = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := ikeParametersMapStrToI["ike_phase1_profile"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								ikePhase1ProfileInt := &ves_io_schema_views.ObjectRefType{}
								ikeParameters.IkePhase1Profile = ikePhase1ProfileInt

								for _, set := range sl {
									if set != nil {
										ippMapToStrVal := set.(map[string]interface{})
										if val, ok := ippMapToStrVal["name"]; ok && !isIntfNil(v) {
											ikePhase1ProfileInt.Name = val.(string)
										}
										if val, ok := ippMapToStrVal["namespace"]; ok && !isIntfNil(v) {
											ikePhase1ProfileInt.Namespace = val.(string)
										}

										if val, ok := ippMapToStrVal["tenant"]; ok && !isIntfNil(v) {
											ikePhase1ProfileInt.Tenant = val.(string)
										}
									}
								}

							}

							if v, ok := ikeParametersMapStrToI["ike_phase2_profile"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								ikePhase2ProfileInt := &ves_io_schema_views.ObjectRefType{}
								ikeParameters.IkePhase2Profile = ikePhase2ProfileInt

								for _, set := range sl {
									if set != nil {
										ippMapToStrVal := set.(map[string]interface{})
										if val, ok := ippMapToStrVal["name"]; ok && !isIntfNil(v) {
											ikePhase2ProfileInt.Name = val.(string)
										}
										if val, ok := ippMapToStrVal["namespace"]; ok && !isIntfNil(v) {
											ikePhase2ProfileInt.Namespace = val.(string)
										}

										if val, ok := ippMapToStrVal["tenant"]; ok && !isIntfNil(v) {
											ikePhase2ProfileInt.Tenant = val.(string)
										}
									}
								}

							}

							localIkeIdTypeFound := false

							if v, ok := ikeParametersMapStrToI["lc_hostname"]; ok && !isIntfNil(v) && !localIkeIdTypeFound {

								localIkeIdTypeFound = true
								localIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_LcHostname{}

								ikeParameters.LocalIkeId = localIkeIdInt

								localIkeIdInt.LcHostname = v.(string)

							}

							if v, ok := ikeParametersMapStrToI["lc_ip_address"]; ok && !isIntfNil(v) && !localIkeIdTypeFound {

								localIkeIdTypeFound = true
								localIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_LcIpAddress{}
								localIkeIdInt.LcIpAddress = &ves_io_schema.IpAddressType{}
								ikeParameters.LocalIkeId = localIkeIdInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										verTypeFound := false

										if v, ok := cs["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

											verTypeFound = true
											verInt := &ves_io_schema.IpAddressType_Ipv4{}
											verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
											localIkeIdInt.LcIpAddress.Ver = verInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["addr"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Addr = v.(string)

													}

												}
											}

										}

										if v, ok := cs["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

											verTypeFound = true
											verInt := &ves_io_schema.IpAddressType_Ipv6{}
											verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
											localIkeIdInt.LcIpAddress.Ver = verInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["addr"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Addr = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := ikeParametersMapStrToI["use_default_local_ike_id"]; ok && !isIntfNil(v) && !localIkeIdTypeFound {

								localIkeIdTypeFound = true

								if v.(bool) {
									localIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_UseDefaultLocalIkeId{}
									localIkeIdInt.UseDefaultLocalIkeId = &ves_io_schema.Empty{}
									ikeParameters.LocalIkeId = localIkeIdInt
								}

							}

							modeChoiceTypeFound := false

							if v, ok := ikeParametersMapStrToI["initiator"]; ok && !isIntfNil(v) && !modeChoiceTypeFound {

								modeChoiceTypeFound = true

								if v.(bool) {
									modeChoiceInt := &ves_io_schema_views_external_connector.IkeParameters_Initiator{}
									modeChoiceInt.Initiator = &ves_io_schema.Empty{}
									ikeParameters.ModeChoice = modeChoiceInt
								}

							}

							if v, ok := ikeParametersMapStrToI["responder"]; ok && !isIntfNil(v) && !modeChoiceTypeFound {

								modeChoiceTypeFound = true

								if v.(bool) {
									modeChoiceInt := &ves_io_schema_views_external_connector.IkeParameters_Responder{}
									modeChoiceInt.Responder = &ves_io_schema.Empty{}
									ikeParameters.ModeChoice = modeChoiceInt
								}

							}

							remoteIkeIdTypeFound := false

							if v, ok := ikeParametersMapStrToI["rm_hostname"]; ok && !isIntfNil(v) && !remoteIkeIdTypeFound {

								remoteIkeIdTypeFound = true
								remoteIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_RmHostname{}

								ikeParameters.RemoteIkeId = remoteIkeIdInt

								remoteIkeIdInt.RmHostname = v.(string)

							}

							if v, ok := ikeParametersMapStrToI["rm_ip_address"]; ok && !isIntfNil(v) && !remoteIkeIdTypeFound {

								remoteIkeIdTypeFound = true
								remoteIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_RmIpAddress{}
								remoteIkeIdInt.RmIpAddress = &ves_io_schema.IpAddressType{}
								ikeParameters.RemoteIkeId = remoteIkeIdInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										verTypeFound := false

										if v, ok := cs["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

											verTypeFound = true
											verInt := &ves_io_schema.IpAddressType_Ipv4{}
											verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
											remoteIkeIdInt.RmIpAddress.Ver = verInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["addr"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Addr = v.(string)

													}

												}
											}

										}

										if v, ok := cs["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

											verTypeFound = true
											verInt := &ves_io_schema.IpAddressType_Ipv6{}
											verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
											remoteIkeIdInt.RmIpAddress.Ver = verInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["addr"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Addr = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := ikeParametersMapStrToI["use_default_remote_ike_id"]; ok && !isIntfNil(v) && !remoteIkeIdTypeFound {

								remoteIkeIdTypeFound = true

								if v.(bool) {
									remoteIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_UseDefaultRemoteIkeId{}
									remoteIkeIdInt.UseDefaultRemoteIkeId = &ves_io_schema.Empty{}
									ikeParameters.RemoteIkeId = remoteIkeIdInt
								}

							}

						}
					}

				}

				if v, ok := cs["ipsec_tunnel_parameters"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ipsecTunnelParameters := &ves_io_schema_views_external_connector.TunnelParameters{}
					connectionTypeInt.Ipsec.IpsecTunnelParameters = ipsecTunnelParameters
					for _, set := range sl {
						if set != nil {
							ipsecTunnelParametersMapStrToI := set.(map[string]interface{})

							if v, ok := ipsecTunnelParametersMapStrToI["peer_ip_address"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								peerIpAddress := &ves_io_schema.Ipv4AddressType{}
								ipsecTunnelParameters.PeerIpAddress = peerIpAddress
								for _, set := range sl {
									if set != nil {
										peerIpAddressMapStrToI := set.(map[string]interface{})

										if w, ok := peerIpAddressMapStrToI["addr"]; ok && !isIntfNil(w) {
											peerIpAddress.Addr = w.(string)
										}

									}
								}

							}

							if w, ok := ipsecTunnelParametersMapStrToI["psk"]; ok && !isIntfNil(w) {
								ipsecTunnelParameters.Psk = w.(string)
							}

							if v, ok := ipsecTunnelParametersMapStrToI["tunnel_eps"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								tunnelEps := make([]*ves_io_schema_views_external_connector.TunnelEndpoint, len(sl))
								ipsecTunnelParameters.TunnelEps = tunnelEps
								for i, set := range sl {
									if set != nil {
										tunnelEps[i] = &ves_io_schema_views_external_connector.TunnelEndpoint{}
										tunnelEpsMapStrToI := set.(map[string]interface{})

										if w, ok := tunnelEpsMapStrToI["interface"]; ok && !isIntfNil(w) {
											tunnelEps[i].Interface = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["local_tunnel_ip"]; ok && !isIntfNil(w) {
											tunnelEps[i].LocalTunnelIp = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["node"]; ok && !isIntfNil(w) {
											tunnelEps[i].Node = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["remote_tunnel_ip"]; ok && !isIntfNil(w) {
											tunnelEps[i].RemoteTunnelIp = w.(string)
										}

									}
								}

							}

							if w, ok := ipsecTunnelParametersMapStrToI["tunnel_mtu"]; ok && !isIntfNil(w) {
								ipsecTunnelParameters.TunnelMtu = uint32(w.(int))
							}

							tunnelSourceVnTypeFound := false

							if v, ok := ipsecTunnelParametersMapStrToI["segment"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true
								tunnelSourceVnInt := &ves_io_schema_views_external_connector.TunnelParameters_Segment{}
								tunnelSourceVnInt.Segment = &ves_io_schema.SegmentRefType{}
								ipsecTunnelParameters.TunnelSourceVn = tunnelSourceVnInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["refs"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											refsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											tunnelSourceVnInt.Segment.Refs = refsInt
											for i, ps := range sl {
												if ps != nil {

													rMapToStrVal := ps.(map[string]interface{})
													refsInt[i] = &ves_io_schema.ObjectRefType{}

													refsInt[i].Kind = "segment"

													if v, ok := rMapToStrVal["name"]; ok && !isIntfNil(v) {
														refsInt[i].Name = v.(string)
													}

													if v, ok := rMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														refsInt[i].Namespace = v.(string)
													}

													if v, ok := rMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														refsInt[i].Tenant = v.(string)
													}

													if v, ok := rMapToStrVal["uid"]; ok && !isIntfNil(v) {
														refsInt[i].Uid = v.(string)
													}

												}
											}

										}

										if v, ok := cs["virtual_networks"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											virtualNetworksInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											tunnelSourceVnInt.Segment.VirtualNetworks = virtualNetworksInt
											for i, ps := range sl {
												if ps != nil {

													vnMapToStrVal := ps.(map[string]interface{})
													virtualNetworksInt[i] = &ves_io_schema.ObjectRefType{}

													virtualNetworksInt[i].Kind = "virtual_network"

													if v, ok := vnMapToStrVal["name"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Name = v.(string)
													}

													if v, ok := vnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Namespace = v.(string)
													}

													if v, ok := vnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Tenant = v.(string)
													}

													if v, ok := vnMapToStrVal["uid"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Uid = v.(string)
													}

												}
											}

										}

									}
								}

							}

							if v, ok := ipsecTunnelParametersMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true

								if v.(bool) {
									tunnelSourceVnInt := &ves_io_schema_views_external_connector.TunnelParameters_SiteLocalInsideNetwork{}
									tunnelSourceVnInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
									ipsecTunnelParameters.TunnelSourceVn = tunnelSourceVnInt
								}

							}

							if v, ok := ipsecTunnelParametersMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true

								if v.(bool) {
									tunnelSourceVnInt := &ves_io_schema_views_external_connector.TunnelParameters_SiteLocalNetwork{}
									tunnelSourceVnInt.SiteLocalNetwork = &ves_io_schema.Empty{}
									ipsecTunnelParameters.TunnelSourceVn = tunnelSourceVnInt
								}

							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Creating Volterra ExternalConnector object with struct: %+v", createReq)

	createExternalConnectorResp, err := client.CreateObject(context.Background(), ves_io_schema_views_external_connector.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating ExternalConnector: %s", err)
	}
	d.SetId(createExternalConnectorResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraExternalConnectorRead(d, meta)
}

func resourceVolterraExternalConnectorRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_external_connector.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] ExternalConnector %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra ExternalConnector %q: %s", d.Id(), err)
	}
	return setExternalConnectorFields(client, d, resp)
}

func setExternalConnectorFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraExternalConnectorUpdate updates ExternalConnector resource
func resourceVolterraExternalConnectorUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_external_connector.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_external_connector.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("ce_site_reference"); ok && !isIntfNil(v) {

		sl := v.([]interface{})
		ceSiteReferenceInt := &ves_io_schema_views.ObjectRefType{}
		updateSpec.CeSiteReference = ceSiteReferenceInt

		for _, set := range sl {
			if set != nil {
				csrMapToStrVal := set.(map[string]interface{})
				if val, ok := csrMapToStrVal["name"]; ok && !isIntfNil(v) {
					ceSiteReferenceInt.Name = val.(string)
				}
				if val, ok := csrMapToStrVal["namespace"]; ok && !isIntfNil(v) {
					ceSiteReferenceInt.Namespace = val.(string)
				}

				if val, ok := csrMapToStrVal["tenant"]; ok && !isIntfNil(v) {
					ceSiteReferenceInt.Tenant = val.(string)
				}
			}
		}

	}

	connectionTypeTypeFound := false

	if _, ok := d.GetOk("direct_connection"); ok && !connectionTypeTypeFound {

		connectionTypeTypeFound = true
		connectionTypeInt := &ves_io_schema_views_external_connector.ReplaceSpecType_DirectConnection{}
		connectionTypeInt.DirectConnection = &ves_io_schema_views_external_connector.ConnectionTypeDirect{}
		updateSpec.ConnectionType = connectionTypeInt

	}

	if v, ok := d.GetOk("gre"); ok && !isIntfNil(v) && !connectionTypeTypeFound {

		connectionTypeTypeFound = true
		connectionTypeInt := &ves_io_schema_views_external_connector.ReplaceSpecType_Gre{}
		connectionTypeInt.Gre = &ves_io_schema_views_external_connector.ConnectionTypeGRE{}
		updateSpec.ConnectionType = connectionTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["gre_parameters"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					greParameters := &ves_io_schema_views_external_connector.GRETunnelParameters{}
					connectionTypeInt.Gre.GreParameters = greParameters
					for _, set := range sl {
						if set != nil {
							greParametersMapStrToI := set.(map[string]interface{})

							if v, ok := greParametersMapStrToI["peer_ip_address"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								peerIpAddress := &ves_io_schema.Ipv4AddressType{}
								greParameters.PeerIpAddress = peerIpAddress
								for _, set := range sl {
									if set != nil {
										peerIpAddressMapStrToI := set.(map[string]interface{})

										if w, ok := peerIpAddressMapStrToI["addr"]; ok && !isIntfNil(w) {
											peerIpAddress.Addr = w.(string)
										}

									}
								}

							}

							if v, ok := greParametersMapStrToI["tunnel_eps"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								tunnelEps := make([]*ves_io_schema_views_external_connector.TunnelEndpoint, len(sl))
								greParameters.TunnelEps = tunnelEps
								for i, set := range sl {
									if set != nil {
										tunnelEps[i] = &ves_io_schema_views_external_connector.TunnelEndpoint{}
										tunnelEpsMapStrToI := set.(map[string]interface{})

										if w, ok := tunnelEpsMapStrToI["interface"]; ok && !isIntfNil(w) {
											tunnelEps[i].Interface = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["local_tunnel_ip"]; ok && !isIntfNil(w) {
											tunnelEps[i].LocalTunnelIp = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["node"]; ok && !isIntfNil(w) {
											tunnelEps[i].Node = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["remote_tunnel_ip"]; ok && !isIntfNil(w) {
											tunnelEps[i].RemoteTunnelIp = w.(string)
										}

									}
								}

							}

							if w, ok := greParametersMapStrToI["tunnel_mtu"]; ok && !isIntfNil(w) {
								greParameters.TunnelMtu = uint32(w.(int))
							}

							tunnelSourceVnTypeFound := false

							if v, ok := greParametersMapStrToI["segment"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true
								tunnelSourceVnInt := &ves_io_schema_views_external_connector.GRETunnelParameters_Segment{}
								tunnelSourceVnInt.Segment = &ves_io_schema.SegmentRefType{}
								greParameters.TunnelSourceVn = tunnelSourceVnInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["refs"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											refsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											tunnelSourceVnInt.Segment.Refs = refsInt
											for i, ps := range sl {
												if ps != nil {

													rMapToStrVal := ps.(map[string]interface{})
													refsInt[i] = &ves_io_schema.ObjectRefType{}

													refsInt[i].Kind = "segment"

													if v, ok := rMapToStrVal["name"]; ok && !isIntfNil(v) {
														refsInt[i].Name = v.(string)
													}

													if v, ok := rMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														refsInt[i].Namespace = v.(string)
													}

													if v, ok := rMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														refsInt[i].Tenant = v.(string)
													}

													if v, ok := rMapToStrVal["uid"]; ok && !isIntfNil(v) {
														refsInt[i].Uid = v.(string)
													}

												}
											}

										}

										if v, ok := cs["virtual_networks"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											virtualNetworksInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											tunnelSourceVnInt.Segment.VirtualNetworks = virtualNetworksInt
											for i, ps := range sl {
												if ps != nil {

													vnMapToStrVal := ps.(map[string]interface{})
													virtualNetworksInt[i] = &ves_io_schema.ObjectRefType{}

													virtualNetworksInt[i].Kind = "virtual_network"

													if v, ok := vnMapToStrVal["name"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Name = v.(string)
													}

													if v, ok := vnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Namespace = v.(string)
													}

													if v, ok := vnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Tenant = v.(string)
													}

													if v, ok := vnMapToStrVal["uid"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Uid = v.(string)
													}

												}
											}

										}

									}
								}

							}

							if v, ok := greParametersMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true

								if v.(bool) {
									tunnelSourceVnInt := &ves_io_schema_views_external_connector.GRETunnelParameters_SiteLocalInsideNetwork{}
									tunnelSourceVnInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
									greParameters.TunnelSourceVn = tunnelSourceVnInt
								}

							}

							if v, ok := greParametersMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true

								if v.(bool) {
									tunnelSourceVnInt := &ves_io_schema_views_external_connector.GRETunnelParameters_SiteLocalNetwork{}
									tunnelSourceVnInt.SiteLocalNetwork = &ves_io_schema.Empty{}
									greParameters.TunnelSourceVn = tunnelSourceVnInt
								}

							}

						}
					}

				}

			}
		}

	}

	if v, ok := d.GetOk("ipsec"); ok && !isIntfNil(v) && !connectionTypeTypeFound {

		connectionTypeTypeFound = true
		connectionTypeInt := &ves_io_schema_views_external_connector.ReplaceSpecType_Ipsec{}
		connectionTypeInt.Ipsec = &ves_io_schema_views_external_connector.ConnectionTypeIPSec{}
		updateSpec.ConnectionType = connectionTypeInt

		sl := v.([]interface{})
		for _, set := range sl {
			if set != nil {
				cs := set.(map[string]interface{})

				if v, ok := cs["ike_parameters"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ikeParameters := &ves_io_schema_views_external_connector.IkeParameters{}
					connectionTypeInt.Ipsec.IkeParameters = ikeParameters
					for _, set := range sl {
						if set != nil {
							ikeParametersMapStrToI := set.(map[string]interface{})

							dpdChoiceTypeFound := false

							if v, ok := ikeParametersMapStrToI["dpd_disabled"]; ok && !isIntfNil(v) && !dpdChoiceTypeFound {

								dpdChoiceTypeFound = true

								if v.(bool) {
									dpdChoiceInt := &ves_io_schema_views_external_connector.IkeParameters_DpdDisabled{}
									dpdChoiceInt.DpdDisabled = &ves_io_schema.Empty{}
									ikeParameters.DpdChoice = dpdChoiceInt
								}

							}

							if v, ok := ikeParametersMapStrToI["dpd_keep_alive_timer"]; ok && !isIntfNil(v) && !dpdChoiceTypeFound {

								dpdChoiceTypeFound = true
								dpdChoiceInt := &ves_io_schema_views_external_connector.IkeParameters_DpdKeepAliveTimer{}
								dpdChoiceInt.DpdKeepAliveTimer = &ves_io_schema_views_external_connector.DpdKeepAliveTimer{}
								ikeParameters.DpdChoice = dpdChoiceInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["timeout"]; ok && !isIntfNil(v) {

											dpdChoiceInt.DpdKeepAliveTimer.Timeout = uint32(v.(int))

										}

									}
								}

							}

							if v, ok := ikeParametersMapStrToI["ike_phase1_profile"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								ikePhase1ProfileInt := &ves_io_schema_views.ObjectRefType{}
								ikeParameters.IkePhase1Profile = ikePhase1ProfileInt

								for _, set := range sl {
									if set != nil {
										ippMapToStrVal := set.(map[string]interface{})
										if val, ok := ippMapToStrVal["name"]; ok && !isIntfNil(v) {
											ikePhase1ProfileInt.Name = val.(string)
										}
										if val, ok := ippMapToStrVal["namespace"]; ok && !isIntfNil(v) {
											ikePhase1ProfileInt.Namespace = val.(string)
										}

										if val, ok := ippMapToStrVal["tenant"]; ok && !isIntfNil(v) {
											ikePhase1ProfileInt.Tenant = val.(string)
										}
									}
								}

							}

							if v, ok := ikeParametersMapStrToI["ike_phase2_profile"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								ikePhase2ProfileInt := &ves_io_schema_views.ObjectRefType{}
								ikeParameters.IkePhase2Profile = ikePhase2ProfileInt

								for _, set := range sl {
									if set != nil {
										ippMapToStrVal := set.(map[string]interface{})
										if val, ok := ippMapToStrVal["name"]; ok && !isIntfNil(v) {
											ikePhase2ProfileInt.Name = val.(string)
										}
										if val, ok := ippMapToStrVal["namespace"]; ok && !isIntfNil(v) {
											ikePhase2ProfileInt.Namespace = val.(string)
										}

										if val, ok := ippMapToStrVal["tenant"]; ok && !isIntfNil(v) {
											ikePhase2ProfileInt.Tenant = val.(string)
										}
									}
								}

							}

							localIkeIdTypeFound := false

							if v, ok := ikeParametersMapStrToI["lc_hostname"]; ok && !isIntfNil(v) && !localIkeIdTypeFound {

								localIkeIdTypeFound = true
								localIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_LcHostname{}

								ikeParameters.LocalIkeId = localIkeIdInt

								localIkeIdInt.LcHostname = v.(string)

							}

							if v, ok := ikeParametersMapStrToI["lc_ip_address"]; ok && !isIntfNil(v) && !localIkeIdTypeFound {

								localIkeIdTypeFound = true
								localIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_LcIpAddress{}
								localIkeIdInt.LcIpAddress = &ves_io_schema.IpAddressType{}
								ikeParameters.LocalIkeId = localIkeIdInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										verTypeFound := false

										if v, ok := cs["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

											verTypeFound = true
											verInt := &ves_io_schema.IpAddressType_Ipv4{}
											verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
											localIkeIdInt.LcIpAddress.Ver = verInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["addr"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Addr = v.(string)

													}

												}
											}

										}

										if v, ok := cs["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

											verTypeFound = true
											verInt := &ves_io_schema.IpAddressType_Ipv6{}
											verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
											localIkeIdInt.LcIpAddress.Ver = verInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["addr"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Addr = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := ikeParametersMapStrToI["use_default_local_ike_id"]; ok && !isIntfNil(v) && !localIkeIdTypeFound {

								localIkeIdTypeFound = true

								if v.(bool) {
									localIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_UseDefaultLocalIkeId{}
									localIkeIdInt.UseDefaultLocalIkeId = &ves_io_schema.Empty{}
									ikeParameters.LocalIkeId = localIkeIdInt
								}

							}

							modeChoiceTypeFound := false

							if v, ok := ikeParametersMapStrToI["initiator"]; ok && !isIntfNil(v) && !modeChoiceTypeFound {

								modeChoiceTypeFound = true

								if v.(bool) {
									modeChoiceInt := &ves_io_schema_views_external_connector.IkeParameters_Initiator{}
									modeChoiceInt.Initiator = &ves_io_schema.Empty{}
									ikeParameters.ModeChoice = modeChoiceInt
								}

							}

							if v, ok := ikeParametersMapStrToI["responder"]; ok && !isIntfNil(v) && !modeChoiceTypeFound {

								modeChoiceTypeFound = true

								if v.(bool) {
									modeChoiceInt := &ves_io_schema_views_external_connector.IkeParameters_Responder{}
									modeChoiceInt.Responder = &ves_io_schema.Empty{}
									ikeParameters.ModeChoice = modeChoiceInt
								}

							}

							remoteIkeIdTypeFound := false

							if v, ok := ikeParametersMapStrToI["rm_hostname"]; ok && !isIntfNil(v) && !remoteIkeIdTypeFound {

								remoteIkeIdTypeFound = true
								remoteIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_RmHostname{}

								ikeParameters.RemoteIkeId = remoteIkeIdInt

								remoteIkeIdInt.RmHostname = v.(string)

							}

							if v, ok := ikeParametersMapStrToI["rm_ip_address"]; ok && !isIntfNil(v) && !remoteIkeIdTypeFound {

								remoteIkeIdTypeFound = true
								remoteIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_RmIpAddress{}
								remoteIkeIdInt.RmIpAddress = &ves_io_schema.IpAddressType{}
								ikeParameters.RemoteIkeId = remoteIkeIdInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										verTypeFound := false

										if v, ok := cs["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

											verTypeFound = true
											verInt := &ves_io_schema.IpAddressType_Ipv4{}
											verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
											remoteIkeIdInt.RmIpAddress.Ver = verInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["addr"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Addr = v.(string)

													}

												}
											}

										}

										if v, ok := cs["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

											verTypeFound = true
											verInt := &ves_io_schema.IpAddressType_Ipv6{}
											verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
											remoteIkeIdInt.RmIpAddress.Ver = verInt

											sl := v.([]interface{})
											for _, set := range sl {
												if set != nil {
													cs := set.(map[string]interface{})

													if v, ok := cs["addr"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Addr = v.(string)

													}

												}
											}

										}

									}
								}

							}

							if v, ok := ikeParametersMapStrToI["use_default_remote_ike_id"]; ok && !isIntfNil(v) && !remoteIkeIdTypeFound {

								remoteIkeIdTypeFound = true

								if v.(bool) {
									remoteIkeIdInt := &ves_io_schema_views_external_connector.IkeParameters_UseDefaultRemoteIkeId{}
									remoteIkeIdInt.UseDefaultRemoteIkeId = &ves_io_schema.Empty{}
									ikeParameters.RemoteIkeId = remoteIkeIdInt
								}

							}

						}
					}

				}

				if v, ok := cs["ipsec_tunnel_parameters"]; ok && !isIntfNil(v) {

					sl := v.([]interface{})
					ipsecTunnelParameters := &ves_io_schema_views_external_connector.TunnelParameters{}
					connectionTypeInt.Ipsec.IpsecTunnelParameters = ipsecTunnelParameters
					for _, set := range sl {
						if set != nil {
							ipsecTunnelParametersMapStrToI := set.(map[string]interface{})

							if v, ok := ipsecTunnelParametersMapStrToI["peer_ip_address"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								peerIpAddress := &ves_io_schema.Ipv4AddressType{}
								ipsecTunnelParameters.PeerIpAddress = peerIpAddress
								for _, set := range sl {
									if set != nil {
										peerIpAddressMapStrToI := set.(map[string]interface{})

										if w, ok := peerIpAddressMapStrToI["addr"]; ok && !isIntfNil(w) {
											peerIpAddress.Addr = w.(string)
										}

									}
								}

							}

							if w, ok := ipsecTunnelParametersMapStrToI["psk"]; ok && !isIntfNil(w) {
								ipsecTunnelParameters.Psk = w.(string)
							}

							if v, ok := ipsecTunnelParametersMapStrToI["tunnel_eps"]; ok && !isIntfNil(v) {

								sl := v.([]interface{})
								tunnelEps := make([]*ves_io_schema_views_external_connector.TunnelEndpoint, len(sl))
								ipsecTunnelParameters.TunnelEps = tunnelEps
								for i, set := range sl {
									if set != nil {
										tunnelEps[i] = &ves_io_schema_views_external_connector.TunnelEndpoint{}
										tunnelEpsMapStrToI := set.(map[string]interface{})

										if w, ok := tunnelEpsMapStrToI["interface"]; ok && !isIntfNil(w) {
											tunnelEps[i].Interface = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["local_tunnel_ip"]; ok && !isIntfNil(w) {
											tunnelEps[i].LocalTunnelIp = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["node"]; ok && !isIntfNil(w) {
											tunnelEps[i].Node = w.(string)
										}

										if w, ok := tunnelEpsMapStrToI["remote_tunnel_ip"]; ok && !isIntfNil(w) {
											tunnelEps[i].RemoteTunnelIp = w.(string)
										}

									}
								}

							}

							if w, ok := ipsecTunnelParametersMapStrToI["tunnel_mtu"]; ok && !isIntfNil(w) {
								ipsecTunnelParameters.TunnelMtu = uint32(w.(int))
							}

							tunnelSourceVnTypeFound := false

							if v, ok := ipsecTunnelParametersMapStrToI["segment"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true
								tunnelSourceVnInt := &ves_io_schema_views_external_connector.TunnelParameters_Segment{}
								tunnelSourceVnInt.Segment = &ves_io_schema.SegmentRefType{}
								ipsecTunnelParameters.TunnelSourceVn = tunnelSourceVnInt

								sl := v.([]interface{})
								for _, set := range sl {
									if set != nil {
										cs := set.(map[string]interface{})

										if v, ok := cs["refs"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											refsInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											tunnelSourceVnInt.Segment.Refs = refsInt
											for i, ps := range sl {
												if ps != nil {

													rMapToStrVal := ps.(map[string]interface{})
													refsInt[i] = &ves_io_schema.ObjectRefType{}

													refsInt[i].Kind = "segment"

													if v, ok := rMapToStrVal["name"]; ok && !isIntfNil(v) {
														refsInt[i].Name = v.(string)
													}

													if v, ok := rMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														refsInt[i].Namespace = v.(string)
													}

													if v, ok := rMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														refsInt[i].Tenant = v.(string)
													}

													if v, ok := rMapToStrVal["uid"]; ok && !isIntfNil(v) {
														refsInt[i].Uid = v.(string)
													}

												}
											}

										}

										if v, ok := cs["virtual_networks"]; ok && !isIntfNil(v) {

											sl := v.([]interface{})
											virtualNetworksInt := make([]*ves_io_schema.ObjectRefType, len(sl))
											tunnelSourceVnInt.Segment.VirtualNetworks = virtualNetworksInt
											for i, ps := range sl {
												if ps != nil {

													vnMapToStrVal := ps.(map[string]interface{})
													virtualNetworksInt[i] = &ves_io_schema.ObjectRefType{}

													virtualNetworksInt[i].Kind = "virtual_network"

													if v, ok := vnMapToStrVal["name"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Name = v.(string)
													}

													if v, ok := vnMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Namespace = v.(string)
													}

													if v, ok := vnMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Tenant = v.(string)
													}

													if v, ok := vnMapToStrVal["uid"]; ok && !isIntfNil(v) {
														virtualNetworksInt[i].Uid = v.(string)
													}

												}
											}

										}

									}
								}

							}

							if v, ok := ipsecTunnelParametersMapStrToI["site_local_inside_network"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true

								if v.(bool) {
									tunnelSourceVnInt := &ves_io_schema_views_external_connector.TunnelParameters_SiteLocalInsideNetwork{}
									tunnelSourceVnInt.SiteLocalInsideNetwork = &ves_io_schema.Empty{}
									ipsecTunnelParameters.TunnelSourceVn = tunnelSourceVnInt
								}

							}

							if v, ok := ipsecTunnelParametersMapStrToI["site_local_network"]; ok && !isIntfNil(v) && !tunnelSourceVnTypeFound {

								tunnelSourceVnTypeFound = true

								if v.(bool) {
									tunnelSourceVnInt := &ves_io_schema_views_external_connector.TunnelParameters_SiteLocalNetwork{}
									tunnelSourceVnInt.SiteLocalNetwork = &ves_io_schema.Empty{}
									ipsecTunnelParameters.TunnelSourceVn = tunnelSourceVnInt
								}

							}

						}
					}

				}

			}
		}

	}

	log.Printf("[DEBUG] Updating Volterra ExternalConnector obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_external_connector.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating ExternalConnector: %s", err)
	}

	return resourceVolterraExternalConnectorRead(d, meta)
}

func resourceVolterraExternalConnectorDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_external_connector.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] ExternalConnector %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra ExternalConnector before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra ExternalConnector obj with name %+v in namespace %+v", name, namespace)
	opts := []vesapi.CallOpt{
		vesapi.WithFailIfReferred(),
	}
	return client.DeleteObject(context.Background(), ves_io_schema_views_external_connector.ObjectType, namespace, name, opts...)
}
