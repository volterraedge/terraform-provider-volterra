//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-tf-provider. DO NOT EDIT.
//

package volterra

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"gopkg.volterra.us/stdlib/client/vesapi"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_gcp_vpc_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/gcp_vpc_site"
)

// resourceVolterraGcpVpcSite is implementation of Volterra's GcpVpcSite resources
func resourceVolterraGcpVpcSite() *schema.Resource {
	return &schema.Resource{
		Create: resourceVolterraGcpVpcSiteCreate,
		Read:   resourceVolterraGcpVpcSiteRead,
		Update: resourceVolterraGcpVpcSiteUpdate,
		Delete: resourceVolterraGcpVpcSiteDelete,

		Schema: map[string]*schema.Schema{

			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"description": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"disable": {
				Type:     schema.TypeBool,
				Optional: true,
			},

			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"namespace": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"address": {
				Type:     schema.TypeString,
				Optional: true,
			},

			"block_all_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"blocked_services": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"blocked_sevice": {

							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"dns": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"ssh": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"web_user_interface": {

										Type:     schema.TypeBool,
										Optional: true,
									},

									"network_type": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"default_blocked_services": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"coordinates": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"latitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},

						"longitude": {
							Type:     schema.TypeFloat,
							Optional: true,
						},
					},
				},
			},

			"custom_dns": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"inside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"inside_nameserver_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_nameserver": {
							Type:     schema.TypeString,
							Optional: true,
						},

						"outside_nameserver_v6": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"cloud_credentials": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"disk_size": {
				Type:     schema.TypeInt,
				Optional: true,
			},

			"gcp_labels": {
				Type:     schema.TypeMap,
				Optional: true,
			},

			"gcp_region": {
				Type:     schema.TypeString,
				Required: true,
			},

			"instance_type": {
				Type:     schema.TypeString,
				Required: true,
			},

			"log_receiver": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"name": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"namespace": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"tenant": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"logs_streaming_disabled": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"nodes_per_az": {
				Type:       schema.TypeInt,
				Optional:   true,
				Deprecated: "This field is deprecated and will be removed in future release.",
			},

			"offline_survivability_mode": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"enable_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_offline_survivability_mode": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"os": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_os_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"operating_system_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"private_connect_disabled": {

				Type:     schema.TypeBool,
				Optional: true,
			},

			"private_connectivity": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"cloud_link": {

							Type:     schema.TypeSet,
							Required: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"kind": {
										Type:     schema.TypeString,
										Computed: true,
									},

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"inside": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"ingress_egress_gw": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"dc_cluster_group_inside_vn": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"dc_cluster_group_outside_vn": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_dc_cluster_group": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"gcp_certified_hw": {
							Type:     schema.TypeString,
							Required: true,
						},

						"gcp_zone_names": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"global_network_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"disable_forward_proxy": {

													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"enable_forward_proxy": {

													Type:       schema.TypeSet,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"connection_timeout": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"max_connect_attempts": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"no_interception": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"tls_intercept": {

																Type:       schema.TypeSet,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"enable_for_all_domains": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"policy": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interception_rules": {

																						Type:       schema.TypeList,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"domain_match": {

																									Type:       schema.TypeSet,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"exact_value": {

																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"regex_value": {

																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"suffix_value": {

																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"disable_interception": {

																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"enable_interception": {

																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"custom_certificate": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"certificate_url": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"description": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"custom_hash_algorithms": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"hash_algorithms": {

																									Type: schema.TypeList,

																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																							},
																						},
																					},

																					"disable_ocsp_stapling": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"use_system_defaults": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"private_key": {

																						Type:       schema.TypeSet,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"blindfold_secret_info_internal": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"store_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"secret_encoding_type": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"blindfold_secret_info": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"store_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"clear_secret_info": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"url": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"vault_secret_info": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"key": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"provider": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"secret_encoding": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"version": {
																												Type:       schema.TypeInt,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"wingman_secret_info": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"name": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"volterra_certificate": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"trusted_ca_url": {

																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"volterra_trusted_ca": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"white_listed_ports": {

																Type: schema.TypeList,

																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeInt,
																},
															},

															"white_listed_prefixes": {

																Type: schema.TypeList,

																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"inside_network": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"existing_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_network_autogenerate": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"autogenerate": {
													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"inside_static_routes": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_inside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"inside_subnet": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"existing_subnet": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet_name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_subnet": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"primary_ipv4": {
													Type:     schema.TypeString,
													Required: true,
												},

												"subnet_name": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_enhanced_firewall_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enhanced_firewall_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"node_number": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"outside_network": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"existing_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_network_autogenerate": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"autogenerate": {
													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"no_outside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_static_routes": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"outside_subnet": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"existing_subnet": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet_name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_subnet": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"primary_ipv4": {
													Type:     schema.TypeString,
													Required: true,
												},

												"subnet_name": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"performance_enhancement_mode": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"perf_mode_l3_enhanced": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"no_jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"perf_mode_l7_enhanced": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"ingress_gw": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"gcp_certified_hw": {
							Type:     schema.TypeString,
							Required: true,
						},

						"gcp_zone_names": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"local_network": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"existing_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_network_autogenerate": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"autogenerate": {
													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"local_subnet": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"existing_subnet": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet_name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_subnet": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"primary_ipv4": {
													Type:     schema.TypeString,
													Required: true,
												},

												"subnet_name": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"node_number": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"performance_enhancement_mode": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"perf_mode_l3_enhanced": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},

												"no_jumbo": {

													Type:     schema.TypeBool,
													Optional: true,
												},
											},
										},
									},

									"perf_mode_l7_enhanced": {

										Type:     schema.TypeBool,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"voltstack_cluster": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"dc_cluster_group": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_dc_cluster_group": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_forward_proxy_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"forward_proxy_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"forward_proxy_allow_all": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"no_forward_proxy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"gcp_certified_hw": {
							Type:     schema.TypeString,
							Required: true,
						},

						"gcp_zone_names": {

							Type: schema.TypeList,

							Required: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},

						"global_network_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"global_network_connections": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"sli_to_global_dr": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"slo_to_global_dr": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"global_vn": {

																Type:     schema.TypeSet,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"kind": {
																			Type:     schema.TypeString,
																			Computed: true,
																		},

																		"name": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"namespace": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																		"tenant": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},
														},
													},
												},

												"disable_forward_proxy": {

													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},

												"enable_forward_proxy": {

													Type:       schema.TypeSet,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"connection_timeout": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"max_connect_attempts": {
																Type:       schema.TypeInt,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"no_interception": {

																Type:       schema.TypeBool,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
															},

															"tls_intercept": {

																Type:       schema.TypeSet,
																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"enable_for_all_domains": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"policy": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"interception_rules": {

																						Type:       schema.TypeList,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"domain_match": {

																									Type:       schema.TypeSet,
																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"exact_value": {

																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"regex_value": {

																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"suffix_value": {

																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"disable_interception": {

																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"enable_interception": {

																									Type:       schema.TypeBool,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"custom_certificate": {

																			Type:       schema.TypeSet,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"certificate_url": {
																						Type:       schema.TypeString,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"description": {
																						Type:       schema.TypeString,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																					},

																					"custom_hash_algorithms": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"hash_algorithms": {

																									Type: schema.TypeList,

																									Required:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Schema{
																										Type: schema.TypeString,
																									},
																								},
																							},
																						},
																					},

																					"disable_ocsp_stapling": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"use_system_defaults": {

																						Type:       schema.TypeSet,
																						Optional:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{},
																						},
																					},

																					"private_key": {

																						Type:       schema.TypeSet,
																						Required:   true,
																						Deprecated: "This field is deprecated and will be removed in future release.",
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"blindfold_secret_info_internal": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"store_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"secret_encoding_type": {
																									Type:       schema.TypeString,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																								},

																								"blindfold_secret_info": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"decryption_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"store_provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"clear_secret_info": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"provider": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"url": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"vault_secret_info": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"key": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"location": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"provider": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"secret_encoding": {
																												Type:       schema.TypeString,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},

																											"version": {
																												Type:       schema.TypeInt,
																												Optional:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},

																								"wingman_secret_info": {

																									Type:       schema.TypeSet,
																									Optional:   true,
																									Deprecated: "This field is deprecated and will be removed in future release.",
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{

																											"name": {
																												Type:       schema.TypeString,
																												Required:   true,
																												Deprecated: "This field is deprecated and will be removed in future release.",
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"volterra_certificate": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"trusted_ca_url": {

																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},

																		"volterra_trusted_ca": {

																			Type:       schema.TypeBool,
																			Optional:   true,
																			Deprecated: "This field is deprecated and will be removed in future release.",
																		},
																	},
																},
															},

															"white_listed_ports": {

																Type: schema.TypeList,

																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeInt,
																},
															},

															"white_listed_prefixes": {

																Type: schema.TypeList,

																Optional:   true,
																Deprecated: "This field is deprecated and will be removed in future release.",
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},

						"no_global_network": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"k8s_cluster": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"name": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"tenant": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},

						"no_k8s_cluster": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"active_enhanced_firewall_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"enhanced_firewall_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"active_network_policies": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"network_policies": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"namespace": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"tenant": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"no_network_policy": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"node_number": {
							Type:     schema.TypeInt,
							Optional: true,
						},

						"no_outside_static_routes": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"outside_static_routes": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"static_route_list": {

										Type:     schema.TypeList,
										Required: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"custom_static_route": {

													Type:     schema.TypeSet,
													Optional: true,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{

															"attrs": {

																Type: schema.TypeList,

																Optional: true,
																Elem: &schema.Schema{
																	Type: schema.TypeString,
																},
															},

															"labels": {
																Type:     schema.TypeMap,
																Optional: true,
															},

															"nexthop": {

																Type:     schema.TypeSet,
																Optional: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"interface": {

																			Type:     schema.TypeList,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"kind": {
																						Type:     schema.TypeString,
																						Computed: true,
																					},

																					"name": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"namespace": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																					"tenant": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"nexthop_address": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"ipv4": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},

																					"ipv6": {

																						Type:     schema.TypeSet,
																						Optional: true,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{

																								"addr": {
																									Type:     schema.TypeString,
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																			},
																		},

																		"type": {
																			Type:     schema.TypeString,
																			Optional: true,
																		},
																	},
																},
															},

															"subnets": {

																Type:     schema.TypeList,
																Required: true,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{

																		"ipv4": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},

																		"ipv6": {

																			Type:     schema.TypeSet,
																			Optional: true,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{

																					"plen": {
																						Type:     schema.TypeInt,
																						Optional: true,
																					},

																					"prefix": {
																						Type:     schema.TypeString,
																						Optional: true,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},

												"simple_static_route": {

													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"site_local_network": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"existing_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_network": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_network_autogenerate": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"autogenerate": {
													Type:       schema.TypeBool,
													Optional:   true,
													Deprecated: "This field is deprecated and will be removed in future release.",
												},
											},
										},
									},
								},
							},
						},

						"site_local_subnet": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"existing_subnet": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"subnet_name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},

									"new_subnet": {

										Type:     schema.TypeSet,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"primary_ipv4": {
													Type:     schema.TypeString,
													Required: true,
												},

												"subnet_name": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},

						"sm_connection_public_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"sm_connection_pvt_ip": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"default_storage": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"storage_class_list": {

							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{

									"storage_classes": {

										Type:     schema.TypeList,
										Optional: true,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{

												"default_storage_class": {
													Type:     schema.TypeBool,
													Optional: true,
												},

												"storage_class_name": {
													Type:     schema.TypeString,
													Required: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},

			"ssh_key": {
				Type:     schema.TypeString,
				Required: true,
			},

			"sw": {

				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{

						"default_sw_version": {

							Type:     schema.TypeBool,
							Optional: true,
						},

						"volterra_software_version": {

							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},
		},
	}
}

// resourceVolterraGcpVpcSiteCreate creates GcpVpcSite resource
func resourceVolterraGcpVpcSiteCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	createMeta := &ves_io_schema.ObjectCreateMetaType{}
	createSpec := &ves_io_schema_views_gcp_vpc_site.CreateSpecType{}
	createReq := &ves_io_schema_views_gcp_vpc_site.CreateRequest{
		Metadata: createMeta,
		Spec:     createSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		createMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		createMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		createMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		createMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		createMeta.Namespace =
			v.(string)
	}

	//address
	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		createSpec.Address =
			v.(string)

	}

	//blocked_services_choice

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("block_all_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_BlockAllServices{}
			blockedServicesChoiceInt.BlockAllServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		createSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
				blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
				for i, set := range sl {
					blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
					blockedSeviceMapStrToI := set.(map[string]interface{})

					blockedServicesValueTypeChoiceTypeFound := false

					if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
							blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
							blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
							blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

						blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			createSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	//coordinates
	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		coordinates := &ves_io_schema_site.Coordinates{}
		createSpec.Coordinates = coordinates
		for _, set := range sl {
			coordinatesMapStrToI := set.(map[string]interface{})

			if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
				coordinates.Latitude = float32(w.(float64))
			}

			if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
				coordinates.Longitude = float32(w.(float64))
			}

		}

	}

	//custom_dns
	if v, ok := d.GetOk("custom_dns"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		customDns := &ves_io_schema_views.CustomDNS{}
		createSpec.CustomDns = customDns
		for _, set := range sl {
			customDnsMapStrToI := set.(map[string]interface{})

			if w, ok := customDnsMapStrToI["inside_nameserver"]; ok && !isIntfNil(w) {
				customDns.InsideNameserver = w.(string)
			}

			if w, ok := customDnsMapStrToI["inside_nameserver_v6"]; ok && !isIntfNil(w) {
				customDns.InsideNameserverV6 = w.(string)
			}

			if w, ok := customDnsMapStrToI["outside_nameserver"]; ok && !isIntfNil(w) {
				customDns.OutsideNameserver = w.(string)
			}

			if w, ok := customDnsMapStrToI["outside_nameserver_v6"]; ok && !isIntfNil(w) {
				customDns.OutsideNameserverV6 = w.(string)
			}

		}

	}

	//deployment

	deploymentTypeFound := false

	if v, ok := d.GetOk("cloud_credentials"); ok && !deploymentTypeFound {

		deploymentTypeFound = true
		deploymentInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_CloudCredentials{}
		deploymentInt.CloudCredentials = &ves_io_schema_views.ObjectRefType{}
		createSpec.Deployment = deploymentInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				deploymentInt.CloudCredentials.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				deploymentInt.CloudCredentials.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				deploymentInt.CloudCredentials.Tenant = v.(string)

			}

		}

	}

	//disk_size
	if v, ok := d.GetOk("disk_size"); ok && !isIntfNil(v) {

		createSpec.DiskSize =
			uint32(v.(int))

	}

	//gcp_labels
	if v, ok := d.GetOk("gcp_labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}
		for k, v := range v.(map[string]interface{}) {
			ms[k] = v.(string)
		}
		createSpec.GcpLabels = ms
	}

	//gcp_region
	if v, ok := d.GetOk("gcp_region"); ok && !isIntfNil(v) {

		createSpec.GcpRegion =
			v.(string)

	}

	//instance_type
	if v, ok := d.GetOk("instance_type"); ok && !isIntfNil(v) {

		createSpec.InstanceType =
			v.(string)

	}

	//logs_receiver_choice

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		createSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			createSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	//nodes_per_az
	if v, ok := d.GetOk("nodes_per_az"); ok && !isIntfNil(v) {

		createSpec.NodesPerAz =
			uint32(v.(int))

	}

	//offline_survivability_mode
	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		createSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

			offlineSurvivabilityModeChoiceTypeFound := false

			if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

			if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

		}

	}

	//os
	if v, ok := d.GetOk("os"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		os := &ves_io_schema_views.OperatingSystemType{}
		createSpec.Os = os
		for _, set := range sl {
			osMapStrToI := set.(map[string]interface{})

			operatingSystemVersionChoiceTypeFound := false

			if v, ok := osMapStrToI["default_os_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

				operatingSystemVersionChoiceTypeFound = true

				if v.(bool) {
					operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_DefaultOsVersion{}
					operatingSystemVersionChoiceInt.DefaultOsVersion = &ves_io_schema.Empty{}
					os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt
				}

			}

			if v, ok := osMapStrToI["operating_system_version"]; ok && !isIntfNil(v) && !operatingSystemVersionChoiceTypeFound {

				operatingSystemVersionChoiceTypeFound = true
				operatingSystemVersionChoiceInt := &ves_io_schema_views.OperatingSystemType_OperatingSystemVersion{}

				os.OperatingSystemVersionChoice = operatingSystemVersionChoiceInt

				operatingSystemVersionChoiceInt.OperatingSystemVersion = v.(string)

			}

		}

	}

	//private_connectivity_choice

	privateConnectivityChoiceTypeFound := false

	if v, ok := d.GetOk("private_connect_disabled"); ok && !privateConnectivityChoiceTypeFound {

		privateConnectivityChoiceTypeFound = true

		if v.(bool) {
			privateConnectivityChoiceInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_PrivateConnectDisabled{}
			privateConnectivityChoiceInt.PrivateConnectDisabled = &ves_io_schema.Empty{}
			createSpec.PrivateConnectivityChoice = privateConnectivityChoiceInt
		}

	}

	if v, ok := d.GetOk("private_connectivity"); ok && !privateConnectivityChoiceTypeFound {

		privateConnectivityChoiceTypeFound = true
		privateConnectivityChoiceInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_PrivateConnectivity{}
		privateConnectivityChoiceInt.PrivateConnectivity = &ves_io_schema_views.PrivateConnectConfigType{}
		createSpec.PrivateConnectivityChoice = privateConnectivityChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["cloud_link"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				cloudLink := &ves_io_schema_views.ObjectRefType{}
				privateConnectivityChoiceInt.PrivateConnectivity.CloudLink = cloudLink
				for _, set := range sl {
					cloudLinkMapStrToI := set.(map[string]interface{})

					if w, ok := cloudLinkMapStrToI["name"]; ok && !isIntfNil(w) {
						cloudLink.Name = w.(string)
					}

					if w, ok := cloudLinkMapStrToI["namespace"]; ok && !isIntfNil(w) {
						cloudLink.Namespace = w.(string)
					}

					if w, ok := cloudLinkMapStrToI["tenant"]; ok && !isIntfNil(w) {
						cloudLink.Tenant = w.(string)
					}

				}

			}

			networkOptionsTypeFound := false

			if v, ok := cs["inside"]; ok && !isIntfNil(v) && !networkOptionsTypeFound {

				networkOptionsTypeFound = true

				if v.(bool) {
					networkOptionsInt := &ves_io_schema_views.PrivateConnectConfigType_Inside{}
					networkOptionsInt.Inside = &ves_io_schema.Empty{}
					privateConnectivityChoiceInt.PrivateConnectivity.NetworkOptions = networkOptionsInt
				}

			}

			if v, ok := cs["outside"]; ok && !isIntfNil(v) && !networkOptionsTypeFound {

				networkOptionsTypeFound = true

				if v.(bool) {
					networkOptionsInt := &ves_io_schema_views.PrivateConnectConfigType_Outside{}
					networkOptionsInt.Outside = &ves_io_schema.Empty{}
					privateConnectivityChoiceInt.PrivateConnectivity.NetworkOptions = networkOptionsInt
				}

			}

		}

	}

	//site_type

	siteTypeTypeFound := false

	if v, ok := d.GetOk("ingress_egress_gw"); ok && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_IngressEgressGw{}
		siteTypeInt.IngressEgressGw = &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType{}
		createSpec.SiteType = siteTypeInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			dcClusterGroupChoiceTypeFound := false

			if v, ok := cs["dc_cluster_group_inside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true
				dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_DcClusterGroupInsideVn{}
				dcClusterGroupChoiceInt.DcClusterGroupInsideVn = &ves_io_schema_views.ObjectRefType{}
				siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Name = v.(string)

					}

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Namespace = v.(string)

					}

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Tenant = v.(string)

					}

				}

			}

			if v, ok := cs["dc_cluster_group_outside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true
				dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_DcClusterGroupOutsideVn{}
				dcClusterGroupChoiceInt.DcClusterGroupOutsideVn = &ves_io_schema_views.ObjectRefType{}
				siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Name = v.(string)

					}

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Namespace = v.(string)

					}

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Tenant = v.(string)

					}

				}

			}

			if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true

				if v.(bool) {
					dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_NoDcClusterGroup{}
					dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt
				}

			}

			forwardProxyChoiceTypeFound := false

			if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true
				forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_ActiveForwardProxyPolicies{}
				forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
				siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
						for i, ps := range sl {

							fppMapToStrVal := ps.(map[string]interface{})
							forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Name = v.(string)
							}

							if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_ForwardProxyAllowAll{}
					forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_NoForwardProxy{}
					forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["gcp_certified_hw"]; ok && !isIntfNil(v) {

				siteTypeInt.IngressEgressGw.GcpCertifiedHw = v.(string)

			}

			if v, ok := cs["gcp_zone_names"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				siteTypeInt.IngressEgressGw.GcpZoneNames = ls

			}

			globalNetworkChoiceTypeFound := false

			if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true
				globalNetworkChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_GlobalNetworkList{}
				globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
				siteTypeInt.IngressEgressGw.GlobalNetworkChoice = globalNetworkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
						globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
						for i, set := range sl {
							globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
							globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

							connectionChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
								connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
								connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							forwardProxyChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true

								if v.(bool) {
									forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
									forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
									globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true
								forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
								forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
								globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

									}

									if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

									}

									tlsInterceptionChoiceTypeFound := false

									if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true

										if v.(bool) {
											tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
											tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
											forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
										}

									}

									if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true
										tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
										tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
										forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											interceptionPolicyChoiceTypeFound := false

											if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true

												if v.(bool) {
													interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
													interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
												}

											}

											if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true
												interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
												interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
												tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
														interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
														for i, set := range sl {
															interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
															interceptionRulesMapStrToI := set.(map[string]interface{})

															if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																domainMatch := &ves_io_schema.DomainType{}
																interceptionRules[i].DomainMatch = domainMatch
																for _, set := range sl {
																	domainMatchMapStrToI := set.(map[string]interface{})

																	domainChoiceTypeFound := false

																	if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.ExactValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.RegexValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.SuffixValue = v.(string)

																	}

																}

															}

															enableDisableChoiceTypeFound := false

															if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																	enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

															if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																	enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

														}

													}

												}

											}

											signingCertChoiceTypeFound := false

											if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true
												signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
												signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
												tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.Description = v.(string)

													}

													ocspStaplingChoiceTypeFound := false

													if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
														ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																for _, j := range v.([]interface{}) {
																	hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																}
																ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

															}

														}

													}

													if _, ok := cs["disable_ocsp_stapling"]; ok && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_DisableOcspStapling{}
														ocspStaplingChoiceInt.DisableOcspStapling = &ves_io_schema.Empty{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

													}

													if _, ok := cs["use_system_defaults"]; ok && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_UseSystemDefaults{}
														ocspStaplingChoiceInt.UseSystemDefaults = &ves_io_schema.Empty{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

													}

													if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														privateKey := &ves_io_schema.SecretType{}
														signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
														for _, set := range sl {
															privateKeyMapStrToI := set.(map[string]interface{})

															if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

												}

											}

											if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true

												if v.(bool) {
													signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
													signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
												}

											}

											trustedCaChoiceTypeFound := false

											if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true
												trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

												tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

												trustedCaChoiceInt.TrustedCaUrl = v.(string)

											}

											if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true

												if v.(bool) {
													trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
													trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
												}

											}

										}

									}

									if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

										ls := make([]uint32, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = uint32(v.(int))
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

									}

									if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

										ls := make([]string, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = v.(string)
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true

				if v.(bool) {
					globalNetworkChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_NoGlobalNetwork{}
					globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.GlobalNetworkChoice = globalNetworkChoiceInt
				}

			}

			if v, ok := cs["inside_network"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				insideNetwork := &ves_io_schema_views.GCPVPCNetworkChoiceType{}
				siteTypeInt.IngressEgressGw.InsideNetwork = insideNetwork
				for _, set := range sl {
					insideNetworkMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := insideNetworkMapStrToI["existing_network"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_ExistingNetwork{}
						choiceInt.ExistingNetwork = &ves_io_schema_views.GCPVPCNetworkType{}
						insideNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingNetwork.Name = v.(string)

							}

						}

					}

					if v, ok := insideNetworkMapStrToI["new_network"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_NewNetwork{}
						choiceInt.NewNetwork = &ves_io_schema_views.GCPVPCNetworkParamsType{}
						insideNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								choiceInt.NewNetwork.Name = v.(string)

							}

						}

					}

					if v, ok := insideNetworkMapStrToI["new_network_autogenerate"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_NewNetworkAutogenerate{}
						choiceInt.NewNetworkAutogenerate = &ves_io_schema_views.GCPVPCNetworkAutogenerateParamsType{}
						insideNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["autogenerate"]; ok && !isIntfNil(v) {

								choiceInt.NewNetworkAutogenerate.Autogenerate = v.(bool)

							}

						}

					}

				}

			}

			insideStaticRouteChoiceTypeFound := false

			if v, ok := cs["inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

				insideStaticRouteChoiceTypeFound = true
				insideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_InsideStaticRoutes{}
				insideStaticRouteChoiceInt.InsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
				siteTypeInt.IngressEgressGw.InsideStaticRouteChoice = insideStaticRouteChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
						insideStaticRouteChoiceInt.InsideStaticRoutes.StaticRouteList = staticRouteList
						for i, set := range sl {
							staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
							staticRouteListMapStrToI := set.(map[string]interface{})

							configModeChoiceTypeFound := false

							if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
								configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

									}

									if v, ok := cs["labels"]; ok && !isIntfNil(v) {

										ms := map[string]string{}
										for k, v := range v.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										configModeChoiceInt.CustomStaticRoute.Labels = ms
									}

									if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										nexthop := &ves_io_schema.NextHopType{}
										configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
										for _, set := range sl {
											nexthopMapStrToI := set.(map[string]interface{})

											if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
												nexthop.Interface = intfInt
												for i, ps := range sl {

													iMapToStrVal := ps.(map[string]interface{})
													intfInt[i] = &ves_io_schema.ObjectRefType{}

													intfInt[i].Kind = "network_interface"

													if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
														intfInt[i].Name = v.(string)
													}

													if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														intfInt[i].Namespace = v.(string)
													}

													if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														intfInt[i].Tenant = v.(string)
													}

													if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
														intfInt[i].Uid = v.(string)
													}

												}

											}

											if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												nexthopAddress := &ves_io_schema.IpAddressType{}
												nexthop.NexthopAddress = nexthopAddress
												for _, set := range sl {
													nexthopAddressMapStrToI := set.(map[string]interface{})

													verTypeFound := false

													if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv4{}
														verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv4.Addr = v.(string)

															}

														}

													}

													if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv6{}
														verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv6.Addr = v.(string)

															}

														}

													}

												}

											}

											if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

												nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

											}

										}

									}

									if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

										sl := v.([]interface{})
										subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
										configModeChoiceInt.CustomStaticRoute.Subnets = subnets
										for i, set := range sl {
											subnets[i] = &ves_io_schema.IpSubnetType{}
											subnetsMapStrToI := set.(map[string]interface{})

											verTypeFound := false

											if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv4{}
												verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Prefix = v.(string)

													}

												}

											}

											if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv6{}
												verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Prefix = v.(string)

													}

												}

											}

										}

									}

								}

							}

							if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								configModeChoiceInt.SimpleStaticRoute = v.(string)

							}

						}

					}

				}

			}

			if v, ok := cs["no_inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

				insideStaticRouteChoiceTypeFound = true

				if v.(bool) {
					insideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_NoInsideStaticRoutes{}
					insideStaticRouteChoiceInt.NoInsideStaticRoutes = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.InsideStaticRouteChoice = insideStaticRouteChoiceInt
				}

			}

			if v, ok := cs["inside_subnet"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				insideSubnet := &ves_io_schema_views.GCPVPCSubnetChoiceType{}
				siteTypeInt.IngressEgressGw.InsideSubnet = insideSubnet
				for _, set := range sl {
					insideSubnetMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := insideSubnetMapStrToI["existing_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCSubnetChoiceType_ExistingSubnet{}
						choiceInt.ExistingSubnet = &ves_io_schema_views.GCPSubnetType{}
						insideSubnet.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingSubnet.SubnetName = v.(string)

							}

						}

					}

					if v, ok := insideSubnetMapStrToI["new_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCSubnetChoiceType_NewSubnet{}
						choiceInt.NewSubnet = &ves_io_schema_views.GCPSubnetParamsType{}
						insideSubnet.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["primary_ipv4"]; ok && !isIntfNil(v) {

								choiceInt.NewSubnet.PrimaryIpv4 = v.(string)

							}

							if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

								choiceInt.NewSubnet.SubnetName = v.(string)

							}

						}

					}

				}

			}

			networkPolicyChoiceTypeFound := false

			if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_ActiveEnhancedFirewallPolicies{}
				networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
				siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
						for i, ps := range sl {

							efpMapToStrVal := ps.(map[string]interface{})
							enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Name = v.(string)
							}

							if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_ActiveNetworkPolicies{}
				networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
				siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
						for i, ps := range sl {

							npMapToStrVal := ps.(map[string]interface{})
							networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Name = v.(string)
							}

							if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true

				if v.(bool) {
					networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_NoNetworkPolicy{}
					networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt
				}

			}

			if v, ok := cs["node_number"]; ok && !isIntfNil(v) {

				siteTypeInt.IngressEgressGw.NodeNumber = uint32(v.(int))

			}

			if v, ok := cs["outside_network"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				outsideNetwork := &ves_io_schema_views.GCPVPCNetworkChoiceType{}
				siteTypeInt.IngressEgressGw.OutsideNetwork = outsideNetwork
				for _, set := range sl {
					outsideNetworkMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := outsideNetworkMapStrToI["existing_network"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_ExistingNetwork{}
						choiceInt.ExistingNetwork = &ves_io_schema_views.GCPVPCNetworkType{}
						outsideNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingNetwork.Name = v.(string)

							}

						}

					}

					if v, ok := outsideNetworkMapStrToI["new_network"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_NewNetwork{}
						choiceInt.NewNetwork = &ves_io_schema_views.GCPVPCNetworkParamsType{}
						outsideNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								choiceInt.NewNetwork.Name = v.(string)

							}

						}

					}

					if v, ok := outsideNetworkMapStrToI["new_network_autogenerate"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_NewNetworkAutogenerate{}
						choiceInt.NewNetworkAutogenerate = &ves_io_schema_views.GCPVPCNetworkAutogenerateParamsType{}
						outsideNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["autogenerate"]; ok && !isIntfNil(v) {

								choiceInt.NewNetworkAutogenerate.Autogenerate = v.(bool)

							}

						}

					}

				}

			}

			outsideStaticRouteChoiceTypeFound := false

			if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

				outsideStaticRouteChoiceTypeFound = true

				if v.(bool) {
					outsideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_NoOutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
				}

			}

			if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

				outsideStaticRouteChoiceTypeFound = true
				outsideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_OutsideStaticRoutes{}
				outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
				siteTypeInt.IngressEgressGw.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
						outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
						for i, set := range sl {
							staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
							staticRouteListMapStrToI := set.(map[string]interface{})

							configModeChoiceTypeFound := false

							if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
								configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

									}

									if v, ok := cs["labels"]; ok && !isIntfNil(v) {

										ms := map[string]string{}
										for k, v := range v.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										configModeChoiceInt.CustomStaticRoute.Labels = ms
									}

									if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										nexthop := &ves_io_schema.NextHopType{}
										configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
										for _, set := range sl {
											nexthopMapStrToI := set.(map[string]interface{})

											if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
												nexthop.Interface = intfInt
												for i, ps := range sl {

													iMapToStrVal := ps.(map[string]interface{})
													intfInt[i] = &ves_io_schema.ObjectRefType{}

													intfInt[i].Kind = "network_interface"

													if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
														intfInt[i].Name = v.(string)
													}

													if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														intfInt[i].Namespace = v.(string)
													}

													if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														intfInt[i].Tenant = v.(string)
													}

													if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
														intfInt[i].Uid = v.(string)
													}

												}

											}

											if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												nexthopAddress := &ves_io_schema.IpAddressType{}
												nexthop.NexthopAddress = nexthopAddress
												for _, set := range sl {
													nexthopAddressMapStrToI := set.(map[string]interface{})

													verTypeFound := false

													if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv4{}
														verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv4.Addr = v.(string)

															}

														}

													}

													if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv6{}
														verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv6.Addr = v.(string)

															}

														}

													}

												}

											}

											if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

												nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

											}

										}

									}

									if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

										sl := v.([]interface{})
										subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
										configModeChoiceInt.CustomStaticRoute.Subnets = subnets
										for i, set := range sl {
											subnets[i] = &ves_io_schema.IpSubnetType{}
											subnetsMapStrToI := set.(map[string]interface{})

											verTypeFound := false

											if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv4{}
												verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Prefix = v.(string)

													}

												}

											}

											if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv6{}
												verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Prefix = v.(string)

													}

												}

											}

										}

									}

								}

							}

							if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								configModeChoiceInt.SimpleStaticRoute = v.(string)

							}

						}

					}

				}

			}

			if v, ok := cs["outside_subnet"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				outsideSubnet := &ves_io_schema_views.GCPVPCSubnetChoiceType{}
				siteTypeInt.IngressEgressGw.OutsideSubnet = outsideSubnet
				for _, set := range sl {
					outsideSubnetMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := outsideSubnetMapStrToI["existing_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCSubnetChoiceType_ExistingSubnet{}
						choiceInt.ExistingSubnet = &ves_io_schema_views.GCPSubnetType{}
						outsideSubnet.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingSubnet.SubnetName = v.(string)

							}

						}

					}

					if v, ok := outsideSubnetMapStrToI["new_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCSubnetChoiceType_NewSubnet{}
						choiceInt.NewSubnet = &ves_io_schema_views.GCPSubnetParamsType{}
						outsideSubnet.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["primary_ipv4"]; ok && !isIntfNil(v) {

								choiceInt.NewSubnet.PrimaryIpv4 = v.(string)

							}

							if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

								choiceInt.NewSubnet.SubnetName = v.(string)

							}

						}

					}

				}

			}

			if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
				siteTypeInt.IngressEgressGw.PerformanceEnhancementMode = performanceEnhancementMode
				for _, set := range sl {
					performanceEnhancementModeMapStrToI := set.(map[string]interface{})

					perfModeChoiceTypeFound := false

					if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true
						perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
						perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
						performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
									perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

							if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
									perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

						}

					}

					if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
							perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
							performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
						}

					}

				}

			}

			siteMeshGroupChoiceTypeFound := false

			if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_SmConnectionPublicIp{}
					siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwType_SmConnectionPvtIp{}
					siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

		}

	}

	if v, ok := d.GetOk("ingress_gw"); ok && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_IngressGw{}
		siteTypeInt.IngressGw = &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressGwType{}
		createSpec.SiteType = siteTypeInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["gcp_certified_hw"]; ok && !isIntfNil(v) {

				siteTypeInt.IngressGw.GcpCertifiedHw = v.(string)

			}

			if v, ok := cs["gcp_zone_names"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				siteTypeInt.IngressGw.GcpZoneNames = ls

			}

			if v, ok := cs["local_network"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				localNetwork := &ves_io_schema_views.GCPVPCNetworkChoiceType{}
				siteTypeInt.IngressGw.LocalNetwork = localNetwork
				for _, set := range sl {
					localNetworkMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := localNetworkMapStrToI["existing_network"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_ExistingNetwork{}
						choiceInt.ExistingNetwork = &ves_io_schema_views.GCPVPCNetworkType{}
						localNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingNetwork.Name = v.(string)

							}

						}

					}

					if v, ok := localNetworkMapStrToI["new_network"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_NewNetwork{}
						choiceInt.NewNetwork = &ves_io_schema_views.GCPVPCNetworkParamsType{}
						localNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								choiceInt.NewNetwork.Name = v.(string)

							}

						}

					}

					if v, ok := localNetworkMapStrToI["new_network_autogenerate"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_NewNetworkAutogenerate{}
						choiceInt.NewNetworkAutogenerate = &ves_io_schema_views.GCPVPCNetworkAutogenerateParamsType{}
						localNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["autogenerate"]; ok && !isIntfNil(v) {

								choiceInt.NewNetworkAutogenerate.Autogenerate = v.(bool)

							}

						}

					}

				}

			}

			if v, ok := cs["local_subnet"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				localSubnet := &ves_io_schema_views.GCPVPCSubnetChoiceType{}
				siteTypeInt.IngressGw.LocalSubnet = localSubnet
				for _, set := range sl {
					localSubnetMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := localSubnetMapStrToI["existing_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCSubnetChoiceType_ExistingSubnet{}
						choiceInt.ExistingSubnet = &ves_io_schema_views.GCPSubnetType{}
						localSubnet.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingSubnet.SubnetName = v.(string)

							}

						}

					}

					if v, ok := localSubnetMapStrToI["new_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCSubnetChoiceType_NewSubnet{}
						choiceInt.NewSubnet = &ves_io_schema_views.GCPSubnetParamsType{}
						localSubnet.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["primary_ipv4"]; ok && !isIntfNil(v) {

								choiceInt.NewSubnet.PrimaryIpv4 = v.(string)

							}

							if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

								choiceInt.NewSubnet.SubnetName = v.(string)

							}

						}

					}

				}

			}

			if v, ok := cs["node_number"]; ok && !isIntfNil(v) {

				siteTypeInt.IngressGw.NodeNumber = uint32(v.(int))

			}

			if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
				siteTypeInt.IngressGw.PerformanceEnhancementMode = performanceEnhancementMode
				for _, set := range sl {
					performanceEnhancementModeMapStrToI := set.(map[string]interface{})

					perfModeChoiceTypeFound := false

					if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true
						perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
						perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
						performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
									perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

							if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
									perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

						}

					}

					if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
							perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
							performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("voltstack_cluster"); ok && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_gcp_vpc_site.CreateSpecType_VoltstackCluster{}
		siteTypeInt.VoltstackCluster = &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType{}
		createSpec.SiteType = siteTypeInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			dcClusterGroupChoiceTypeFound := false

			if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true
				dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_DcClusterGroup{}
				dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
				siteTypeInt.VoltstackCluster.DcClusterGroupChoice = dcClusterGroupChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

					}

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

					}

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

					}

				}

			}

			if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true

				if v.(bool) {
					dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_NoDcClusterGroup{}
					dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.DcClusterGroupChoice = dcClusterGroupChoiceInt
				}

			}

			forwardProxyChoiceTypeFound := false

			if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true
				forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_ActiveForwardProxyPolicies{}
				forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
				siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
						for i, ps := range sl {

							fppMapToStrVal := ps.(map[string]interface{})
							forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Name = v.(string)
							}

							if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_ForwardProxyAllowAll{}
					forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_NoForwardProxy{}
					forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["gcp_certified_hw"]; ok && !isIntfNil(v) {

				siteTypeInt.VoltstackCluster.GcpCertifiedHw = v.(string)

			}

			if v, ok := cs["gcp_zone_names"]; ok && !isIntfNil(v) {

				ls := make([]string, len(v.([]interface{})))
				for i, v := range v.([]interface{}) {
					ls[i] = v.(string)
				}
				siteTypeInt.VoltstackCluster.GcpZoneNames = ls

			}

			globalNetworkChoiceTypeFound := false

			if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true
				globalNetworkChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_GlobalNetworkList{}
				globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
				siteTypeInt.VoltstackCluster.GlobalNetworkChoice = globalNetworkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
						globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
						for i, set := range sl {
							globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
							globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

							connectionChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
								connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
								connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							forwardProxyChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true

								if v.(bool) {
									forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
									forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
									globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true
								forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
								forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
								globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

									}

									if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

									}

									tlsInterceptionChoiceTypeFound := false

									if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true

										if v.(bool) {
											tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
											tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
											forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
										}

									}

									if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true
										tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
										tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
										forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											interceptionPolicyChoiceTypeFound := false

											if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true

												if v.(bool) {
													interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
													interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
												}

											}

											if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true
												interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
												interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
												tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
														interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
														for i, set := range sl {
															interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
															interceptionRulesMapStrToI := set.(map[string]interface{})

															if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																domainMatch := &ves_io_schema.DomainType{}
																interceptionRules[i].DomainMatch = domainMatch
																for _, set := range sl {
																	domainMatchMapStrToI := set.(map[string]interface{})

																	domainChoiceTypeFound := false

																	if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.ExactValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.RegexValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.SuffixValue = v.(string)

																	}

																}

															}

															enableDisableChoiceTypeFound := false

															if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																	enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

															if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																	enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

														}

													}

												}

											}

											signingCertChoiceTypeFound := false

											if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true
												signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
												signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
												tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.Description = v.(string)

													}

													ocspStaplingChoiceTypeFound := false

													if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
														ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																for _, j := range v.([]interface{}) {
																	hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																}
																ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

															}

														}

													}

													if _, ok := cs["disable_ocsp_stapling"]; ok && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_DisableOcspStapling{}
														ocspStaplingChoiceInt.DisableOcspStapling = &ves_io_schema.Empty{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

													}

													if _, ok := cs["use_system_defaults"]; ok && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_UseSystemDefaults{}
														ocspStaplingChoiceInt.UseSystemDefaults = &ves_io_schema.Empty{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

													}

													if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														privateKey := &ves_io_schema.SecretType{}
														signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
														for _, set := range sl {
															privateKeyMapStrToI := set.(map[string]interface{})

															if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

												}

											}

											if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true

												if v.(bool) {
													signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
													signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
												}

											}

											trustedCaChoiceTypeFound := false

											if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true
												trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

												tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

												trustedCaChoiceInt.TrustedCaUrl = v.(string)

											}

											if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true

												if v.(bool) {
													trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
													trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
												}

											}

										}

									}

									if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

										ls := make([]uint32, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = uint32(v.(int))
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

									}

									if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

										ls := make([]string, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = v.(string)
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true

				if v.(bool) {
					globalNetworkChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_NoGlobalNetwork{}
					globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.GlobalNetworkChoice = globalNetworkChoiceInt
				}

			}

			k8SClusterChoiceTypeFound := false

			if v, ok := cs["k8s_cluster"]; ok && !isIntfNil(v) && !k8SClusterChoiceTypeFound {

				k8SClusterChoiceTypeFound = true
				k8SClusterChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_K8SCluster{}
				k8SClusterChoiceInt.K8SCluster = &ves_io_schema_views.ObjectRefType{}
				siteTypeInt.VoltstackCluster.K8SClusterChoice = k8SClusterChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						k8SClusterChoiceInt.K8SCluster.Name = v.(string)

					}

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						k8SClusterChoiceInt.K8SCluster.Namespace = v.(string)

					}

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						k8SClusterChoiceInt.K8SCluster.Tenant = v.(string)

					}

				}

			}

			if v, ok := cs["no_k8s_cluster"]; ok && !isIntfNil(v) && !k8SClusterChoiceTypeFound {

				k8SClusterChoiceTypeFound = true

				if v.(bool) {
					k8SClusterChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_NoK8SCluster{}
					k8SClusterChoiceInt.NoK8SCluster = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.K8SClusterChoice = k8SClusterChoiceInt
				}

			}

			networkPolicyChoiceTypeFound := false

			if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_ActiveEnhancedFirewallPolicies{}
				networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
				siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
						for i, ps := range sl {

							efpMapToStrVal := ps.(map[string]interface{})
							enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Name = v.(string)
							}

							if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_ActiveNetworkPolicies{}
				networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
				siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
						for i, ps := range sl {

							npMapToStrVal := ps.(map[string]interface{})
							networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Name = v.(string)
							}

							if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true

				if v.(bool) {
					networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_NoNetworkPolicy{}
					networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt
				}

			}

			if v, ok := cs["node_number"]; ok && !isIntfNil(v) {

				siteTypeInt.VoltstackCluster.NodeNumber = uint32(v.(int))

			}

			outsideStaticRouteChoiceTypeFound := false

			if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

				outsideStaticRouteChoiceTypeFound = true

				if v.(bool) {
					outsideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_NoOutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
				}

			}

			if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

				outsideStaticRouteChoiceTypeFound = true
				outsideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_OutsideStaticRoutes{}
				outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
				siteTypeInt.VoltstackCluster.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
						outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
						for i, set := range sl {
							staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
							staticRouteListMapStrToI := set.(map[string]interface{})

							configModeChoiceTypeFound := false

							if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
								configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

									}

									if v, ok := cs["labels"]; ok && !isIntfNil(v) {

										ms := map[string]string{}
										for k, v := range v.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										configModeChoiceInt.CustomStaticRoute.Labels = ms
									}

									if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										nexthop := &ves_io_schema.NextHopType{}
										configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
										for _, set := range sl {
											nexthopMapStrToI := set.(map[string]interface{})

											if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
												nexthop.Interface = intfInt
												for i, ps := range sl {

													iMapToStrVal := ps.(map[string]interface{})
													intfInt[i] = &ves_io_schema.ObjectRefType{}

													intfInt[i].Kind = "network_interface"

													if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
														intfInt[i].Name = v.(string)
													}

													if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														intfInt[i].Namespace = v.(string)
													}

													if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														intfInt[i].Tenant = v.(string)
													}

													if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
														intfInt[i].Uid = v.(string)
													}

												}

											}

											if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												nexthopAddress := &ves_io_schema.IpAddressType{}
												nexthop.NexthopAddress = nexthopAddress
												for _, set := range sl {
													nexthopAddressMapStrToI := set.(map[string]interface{})

													verTypeFound := false

													if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv4{}
														verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv4.Addr = v.(string)

															}

														}

													}

													if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv6{}
														verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv6.Addr = v.(string)

															}

														}

													}

												}

											}

											if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

												nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

											}

										}

									}

									if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

										sl := v.([]interface{})
										subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
										configModeChoiceInt.CustomStaticRoute.Subnets = subnets
										for i, set := range sl {
											subnets[i] = &ves_io_schema.IpSubnetType{}
											subnetsMapStrToI := set.(map[string]interface{})

											verTypeFound := false

											if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv4{}
												verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Prefix = v.(string)

													}

												}

											}

											if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv6{}
												verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Prefix = v.(string)

													}

												}

											}

										}

									}

								}

							}

							if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								configModeChoiceInt.SimpleStaticRoute = v.(string)

							}

						}

					}

				}

			}

			if v, ok := cs["site_local_network"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				siteLocalNetwork := &ves_io_schema_views.GCPVPCNetworkChoiceType{}
				siteTypeInt.VoltstackCluster.SiteLocalNetwork = siteLocalNetwork
				for _, set := range sl {
					siteLocalNetworkMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := siteLocalNetworkMapStrToI["existing_network"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_ExistingNetwork{}
						choiceInt.ExistingNetwork = &ves_io_schema_views.GCPVPCNetworkType{}
						siteLocalNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingNetwork.Name = v.(string)

							}

						}

					}

					if v, ok := siteLocalNetworkMapStrToI["new_network"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_NewNetwork{}
						choiceInt.NewNetwork = &ves_io_schema_views.GCPVPCNetworkParamsType{}
						siteLocalNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["name"]; ok && !isIntfNil(v) {

								choiceInt.NewNetwork.Name = v.(string)

							}

						}

					}

					if v, ok := siteLocalNetworkMapStrToI["new_network_autogenerate"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCNetworkChoiceType_NewNetworkAutogenerate{}
						choiceInt.NewNetworkAutogenerate = &ves_io_schema_views.GCPVPCNetworkAutogenerateParamsType{}
						siteLocalNetwork.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["autogenerate"]; ok && !isIntfNil(v) {

								choiceInt.NewNetworkAutogenerate.Autogenerate = v.(bool)

							}

						}

					}

				}

			}

			if v, ok := cs["site_local_subnet"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				siteLocalSubnet := &ves_io_schema_views.GCPVPCSubnetChoiceType{}
				siteTypeInt.VoltstackCluster.SiteLocalSubnet = siteLocalSubnet
				for _, set := range sl {
					siteLocalSubnetMapStrToI := set.(map[string]interface{})

					choiceTypeFound := false

					if v, ok := siteLocalSubnetMapStrToI["existing_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCSubnetChoiceType_ExistingSubnet{}
						choiceInt.ExistingSubnet = &ves_io_schema_views.GCPSubnetType{}
						siteLocalSubnet.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

								choiceInt.ExistingSubnet.SubnetName = v.(string)

							}

						}

					}

					if v, ok := siteLocalSubnetMapStrToI["new_subnet"]; ok && !isIntfNil(v) && !choiceTypeFound {

						choiceTypeFound = true
						choiceInt := &ves_io_schema_views.GCPVPCSubnetChoiceType_NewSubnet{}
						choiceInt.NewSubnet = &ves_io_schema_views.GCPSubnetParamsType{}
						siteLocalSubnet.Choice = choiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							if v, ok := cs["primary_ipv4"]; ok && !isIntfNil(v) {

								choiceInt.NewSubnet.PrimaryIpv4 = v.(string)

							}

							if v, ok := cs["subnet_name"]; ok && !isIntfNil(v) {

								choiceInt.NewSubnet.SubnetName = v.(string)

							}

						}

					}

				}

			}

			siteMeshGroupChoiceTypeFound := false

			if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_SmConnectionPublicIp{}
					siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_SmConnectionPvtIp{}
					siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			storageClassChoiceTypeFound := false

			if v, ok := cs["default_storage"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

				storageClassChoiceTypeFound = true

				if v.(bool) {
					storageClassChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_DefaultStorage{}
					storageClassChoiceInt.DefaultStorage = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.StorageClassChoice = storageClassChoiceInt
				}

			}

			if v, ok := cs["storage_class_list"]; ok && !isIntfNil(v) && !storageClassChoiceTypeFound {

				storageClassChoiceTypeFound = true
				storageClassChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterType_StorageClassList{}
				storageClassChoiceInt.StorageClassList = &ves_io_schema_views.StorageClassListType{}
				siteTypeInt.VoltstackCluster.StorageClassChoice = storageClassChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["storage_classes"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						storageClasses := make([]*ves_io_schema_views.StorageClassType, len(sl))
						storageClassChoiceInt.StorageClassList.StorageClasses = storageClasses
						for i, set := range sl {
							storageClasses[i] = &ves_io_schema_views.StorageClassType{}
							storageClassesMapStrToI := set.(map[string]interface{})

							if w, ok := storageClassesMapStrToI["default_storage_class"]; ok && !isIntfNil(w) {
								storageClasses[i].DefaultStorageClass = w.(bool)
							}

							if w, ok := storageClassesMapStrToI["storage_class_name"]; ok && !isIntfNil(w) {
								storageClasses[i].StorageClassName = w.(string)
							}

						}

					}

				}

			}

		}

	}

	//ssh_key
	if v, ok := d.GetOk("ssh_key"); ok && !isIntfNil(v) {

		createSpec.SshKey =
			v.(string)

	}

	//sw
	if v, ok := d.GetOk("sw"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		sw := &ves_io_schema_views.VolterraSoftwareType{}
		createSpec.Sw = sw
		for _, set := range sl {
			swMapStrToI := set.(map[string]interface{})

			volterraSwVersionChoiceTypeFound := false

			if v, ok := swMapStrToI["default_sw_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

				volterraSwVersionChoiceTypeFound = true

				if v.(bool) {
					volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_DefaultSwVersion{}
					volterraSwVersionChoiceInt.DefaultSwVersion = &ves_io_schema.Empty{}
					sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt
				}

			}

			if v, ok := swMapStrToI["volterra_software_version"]; ok && !isIntfNil(v) && !volterraSwVersionChoiceTypeFound {

				volterraSwVersionChoiceTypeFound = true
				volterraSwVersionChoiceInt := &ves_io_schema_views.VolterraSoftwareType_VolterraSoftwareVersion{}

				sw.VolterraSwVersionChoice = volterraSwVersionChoiceInt

				volterraSwVersionChoiceInt.VolterraSoftwareVersion = v.(string)

			}

		}

	}

	log.Printf("[DEBUG] Creating Volterra GcpVpcSite object with struct: %+v", createReq)

	createGcpVpcSiteResp, err := client.CreateObject(context.Background(), ves_io_schema_views_gcp_vpc_site.ObjectType, createReq)
	if err != nil {
		return fmt.Errorf("error creating GcpVpcSite: %s", err)
	}
	d.SetId(createGcpVpcSiteResp.GetObjSystemMetadata().GetUid())

	return resourceVolterraGcpVpcSiteRead(d, meta)
}

func resourceVolterraGcpVpcSiteRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	resp, err := client.GetObject(context.Background(), ves_io_schema_views_gcp_vpc_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] GcpVpcSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra GcpVpcSite %q: %s", d.Id(), err)
	}
	return setGcpVpcSiteFields(client, d, resp)
}

func setGcpVpcSiteFields(client *APIClient, d *schema.ResourceData, resp vesapi.GetObjectResponse) error {
	metadata := resp.GetObjMetadata()

	d.Set("annotations", metadata.GetAnnotations())

	d.Set("description", metadata.GetDescription())

	d.Set("disable", metadata.GetDisable())

	d.Set("labels", metadata.GetLabels())

	d.Set("name", metadata.GetName())

	d.Set("namespace", metadata.GetNamespace())

	return nil
}

// resourceVolterraGcpVpcSiteUpdate updates GcpVpcSite resource
func resourceVolterraGcpVpcSiteUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)

	updateMeta := &ves_io_schema.ObjectReplaceMetaType{}
	updateSpec := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType{}
	updateReq := &ves_io_schema_views_gcp_vpc_site.ReplaceRequest{
		Metadata: updateMeta,
		Spec:     updateSpec,
	}

	if v, ok := d.GetOk("annotations"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Annotations = ms
	}

	if v, ok := d.GetOk("description"); ok && !isIntfNil(v) {
		updateMeta.Description =
			v.(string)
	}

	if v, ok := d.GetOk("disable"); ok && !isIntfNil(v) {
		updateMeta.Disable =
			v.(bool)
	}

	if v, ok := d.GetOk("labels"); ok && !isIntfNil(v) {

		ms := map[string]string{}

		for k, v := range v.(map[string]interface{}) {
			val := v.(string)
			ms[k] = val
		}
		updateMeta.Labels = ms
	}

	if v, ok := d.GetOk("name"); ok && !isIntfNil(v) {
		updateMeta.Name =
			v.(string)
	}

	if v, ok := d.GetOk("namespace"); ok && !isIntfNil(v) {
		updateMeta.Namespace =
			v.(string)
	}

	if v, ok := d.GetOk("address"); ok && !isIntfNil(v) {

		updateSpec.Address =
			v.(string)

	}

	blockedServicesChoiceTypeFound := false

	if v, ok := d.GetOk("block_all_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_BlockAllServices{}
			blockedServicesChoiceInt.BlockAllServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true
		blockedServicesChoiceInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_BlockedServices{}
		blockedServicesChoiceInt.BlockedServices = &ves_io_schema_fleet.BlockedServicesListType{}
		updateSpec.BlockedServicesChoice = blockedServicesChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["blocked_sevice"]; ok && !isIntfNil(v) {

				sl := v.([]interface{})
				blockedSevice := make([]*ves_io_schema_fleet.BlockedServices, len(sl))
				blockedServicesChoiceInt.BlockedServices.BlockedSevice = blockedSevice
				for i, set := range sl {
					blockedSevice[i] = &ves_io_schema_fleet.BlockedServices{}
					blockedSeviceMapStrToI := set.(map[string]interface{})

					blockedServicesValueTypeChoiceTypeFound := false

					if v, ok := blockedSeviceMapStrToI["dns"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Dns{}
							blockedServicesValueTypeChoiceInt.Dns = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["ssh"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_Ssh{}
							blockedServicesValueTypeChoiceInt.Ssh = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["web_user_interface"]; ok && !isIntfNil(v) && !blockedServicesValueTypeChoiceTypeFound {

						blockedServicesValueTypeChoiceTypeFound = true

						if v.(bool) {
							blockedServicesValueTypeChoiceInt := &ves_io_schema_fleet.BlockedServices_WebUserInterface{}
							blockedServicesValueTypeChoiceInt.WebUserInterface = &ves_io_schema.Empty{}
							blockedSevice[i].BlockedServicesValueTypeChoice = blockedServicesValueTypeChoiceInt
						}

					}

					if v, ok := blockedSeviceMapStrToI["network_type"]; ok && !isIntfNil(v) {

						blockedSevice[i].NetworkType = ves_io_schema.VirtualNetworkType(ves_io_schema.VirtualNetworkType_value[v.(string)])

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("default_blocked_services"); ok && !blockedServicesChoiceTypeFound {

		blockedServicesChoiceTypeFound = true

		if v.(bool) {
			blockedServicesChoiceInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_DefaultBlockedServices{}
			blockedServicesChoiceInt.DefaultBlockedServices = &ves_io_schema.Empty{}
			updateSpec.BlockedServicesChoice = blockedServicesChoiceInt
		}

	}

	if v, ok := d.GetOk("coordinates"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		coordinates := &ves_io_schema_site.Coordinates{}
		updateSpec.Coordinates = coordinates
		for _, set := range sl {
			coordinatesMapStrToI := set.(map[string]interface{})

			if w, ok := coordinatesMapStrToI["latitude"]; ok && !isIntfNil(w) {
				coordinates.Latitude = float32(w.(float64))
			}

			if w, ok := coordinatesMapStrToI["longitude"]; ok && !isIntfNil(w) {
				coordinates.Longitude = float32(w.(float64))
			}

		}

	}

	if v, ok := d.GetOk("custom_dns"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		customDns := &ves_io_schema_views.CustomDNS{}
		updateSpec.CustomDns = customDns
		for _, set := range sl {
			customDnsMapStrToI := set.(map[string]interface{})

			if w, ok := customDnsMapStrToI["inside_nameserver"]; ok && !isIntfNil(w) {
				customDns.InsideNameserver = w.(string)
			}

			if w, ok := customDnsMapStrToI["inside_nameserver_v6"]; ok && !isIntfNil(w) {
				customDns.InsideNameserverV6 = w.(string)
			}

			if w, ok := customDnsMapStrToI["outside_nameserver"]; ok && !isIntfNil(w) {
				customDns.OutsideNameserver = w.(string)
			}

			if w, ok := customDnsMapStrToI["outside_nameserver_v6"]; ok && !isIntfNil(w) {
				customDns.OutsideNameserverV6 = w.(string)
			}

		}

	}

	deploymentTypeFound := false

	if v, ok := d.GetOk("cloud_credentials"); ok && !deploymentTypeFound {

		deploymentTypeFound = true
		deploymentInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_CloudCredentials{}
		deploymentInt.CloudCredentials = &ves_io_schema_views.ObjectRefType{}
		updateSpec.Deployment = deploymentInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				deploymentInt.CloudCredentials.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				deploymentInt.CloudCredentials.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				deploymentInt.CloudCredentials.Tenant = v.(string)

			}

		}

	}

	logsReceiverChoiceTypeFound := false

	if v, ok := d.GetOk("log_receiver"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true
		logsReceiverChoiceInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_LogReceiver{}
		logsReceiverChoiceInt.LogReceiver = &ves_io_schema_views.ObjectRefType{}
		updateSpec.LogsReceiverChoice = logsReceiverChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["name"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Name = v.(string)

			}

			if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Namespace = v.(string)

			}

			if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

				logsReceiverChoiceInt.LogReceiver.Tenant = v.(string)

			}

		}

	}

	if v, ok := d.GetOk("logs_streaming_disabled"); ok && !logsReceiverChoiceTypeFound {

		logsReceiverChoiceTypeFound = true

		if v.(bool) {
			logsReceiverChoiceInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_LogsStreamingDisabled{}
			logsReceiverChoiceInt.LogsStreamingDisabled = &ves_io_schema.Empty{}
			updateSpec.LogsReceiverChoice = logsReceiverChoiceInt
		}

	}

	if v, ok := d.GetOk("offline_survivability_mode"); ok && !isIntfNil(v) {

		sl := v.(*schema.Set).List()
		offlineSurvivabilityMode := &ves_io_schema_views.OfflineSurvivabilityModeType{}
		updateSpec.OfflineSurvivabilityMode = offlineSurvivabilityMode
		for _, set := range sl {
			offlineSurvivabilityModeMapStrToI := set.(map[string]interface{})

			offlineSurvivabilityModeChoiceTypeFound := false

			if v, ok := offlineSurvivabilityModeMapStrToI["enable_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.EnableOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

			if v, ok := offlineSurvivabilityModeMapStrToI["no_offline_survivability_mode"]; ok && !isIntfNil(v) && !offlineSurvivabilityModeChoiceTypeFound {

				offlineSurvivabilityModeChoiceTypeFound = true

				if v.(bool) {
					offlineSurvivabilityModeChoiceInt := &ves_io_schema_views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{}
					offlineSurvivabilityModeChoiceInt.NoOfflineSurvivabilityMode = &ves_io_schema.Empty{}
					offlineSurvivabilityMode.OfflineSurvivabilityModeChoice = offlineSurvivabilityModeChoiceInt
				}

			}

		}

	}

	privateConnectivityChoiceTypeFound := false

	if v, ok := d.GetOk("private_connect_disabled"); ok && !privateConnectivityChoiceTypeFound {

		privateConnectivityChoiceTypeFound = true

		if v.(bool) {
			privateConnectivityChoiceInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_PrivateConnectDisabled{}
			privateConnectivityChoiceInt.PrivateConnectDisabled = &ves_io_schema.Empty{}
			updateSpec.PrivateConnectivityChoice = privateConnectivityChoiceInt
		}

	}

	if v, ok := d.GetOk("private_connectivity"); ok && !privateConnectivityChoiceTypeFound {

		privateConnectivityChoiceTypeFound = true
		privateConnectivityChoiceInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_PrivateConnectivity{}
		privateConnectivityChoiceInt.PrivateConnectivity = &ves_io_schema_views.PrivateConnectConfigType{}
		updateSpec.PrivateConnectivityChoice = privateConnectivityChoiceInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["cloud_link"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				cloudLink := &ves_io_schema_views.ObjectRefType{}
				privateConnectivityChoiceInt.PrivateConnectivity.CloudLink = cloudLink
				for _, set := range sl {
					cloudLinkMapStrToI := set.(map[string]interface{})

					if w, ok := cloudLinkMapStrToI["name"]; ok && !isIntfNil(w) {
						cloudLink.Name = w.(string)
					}

					if w, ok := cloudLinkMapStrToI["namespace"]; ok && !isIntfNil(w) {
						cloudLink.Namespace = w.(string)
					}

					if w, ok := cloudLinkMapStrToI["tenant"]; ok && !isIntfNil(w) {
						cloudLink.Tenant = w.(string)
					}

				}

			}

			networkOptionsTypeFound := false

			if v, ok := cs["inside"]; ok && !isIntfNil(v) && !networkOptionsTypeFound {

				networkOptionsTypeFound = true

				if v.(bool) {
					networkOptionsInt := &ves_io_schema_views.PrivateConnectConfigType_Inside{}
					networkOptionsInt.Inside = &ves_io_schema.Empty{}
					privateConnectivityChoiceInt.PrivateConnectivity.NetworkOptions = networkOptionsInt
				}

			}

			if v, ok := cs["outside"]; ok && !isIntfNil(v) && !networkOptionsTypeFound {

				networkOptionsTypeFound = true

				if v.(bool) {
					networkOptionsInt := &ves_io_schema_views.PrivateConnectConfigType_Outside{}
					networkOptionsInt.Outside = &ves_io_schema.Empty{}
					privateConnectivityChoiceInt.PrivateConnectivity.NetworkOptions = networkOptionsInt
				}

			}

		}

	}

	siteTypeTypeFound := false

	if v, ok := d.GetOk("ingress_egress_gw"); ok && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_IngressEgressGw{}
		siteTypeInt.IngressEgressGw = &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType{}
		updateSpec.SiteType = siteTypeInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			dcClusterGroupChoiceTypeFound := false

			if v, ok := cs["dc_cluster_group_inside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true
				dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_DcClusterGroupInsideVn{}
				dcClusterGroupChoiceInt.DcClusterGroupInsideVn = &ves_io_schema_views.ObjectRefType{}
				siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Name = v.(string)

					}

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Namespace = v.(string)

					}

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupInsideVn.Tenant = v.(string)

					}

				}

			}

			if v, ok := cs["dc_cluster_group_outside_vn"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true
				dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_DcClusterGroupOutsideVn{}
				dcClusterGroupChoiceInt.DcClusterGroupOutsideVn = &ves_io_schema_views.ObjectRefType{}
				siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Name = v.(string)

					}

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Namespace = v.(string)

					}

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroupOutsideVn.Tenant = v.(string)

					}

				}

			}

			if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true

				if v.(bool) {
					dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_NoDcClusterGroup{}
					dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.DcClusterGroupChoice = dcClusterGroupChoiceInt
				}

			}

			forwardProxyChoiceTypeFound := false

			if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true
				forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_ActiveForwardProxyPolicies{}
				forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
				siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
						for i, ps := range sl {

							fppMapToStrVal := ps.(map[string]interface{})
							forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Name = v.(string)
							}

							if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_ForwardProxyAllowAll{}
					forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_NoForwardProxy{}
					forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			globalNetworkChoiceTypeFound := false

			if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true
				globalNetworkChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_GlobalNetworkList{}
				globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
				siteTypeInt.IngressEgressGw.GlobalNetworkChoice = globalNetworkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
						globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
						for i, set := range sl {
							globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
							globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

							connectionChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
								connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
								connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							forwardProxyChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true

								if v.(bool) {
									forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
									forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
									globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true
								forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
								forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
								globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

									}

									if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

									}

									tlsInterceptionChoiceTypeFound := false

									if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true

										if v.(bool) {
											tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
											tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
											forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
										}

									}

									if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true
										tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
										tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
										forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											interceptionPolicyChoiceTypeFound := false

											if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true

												if v.(bool) {
													interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
													interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
												}

											}

											if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true
												interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
												interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
												tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
														interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
														for i, set := range sl {
															interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
															interceptionRulesMapStrToI := set.(map[string]interface{})

															if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																domainMatch := &ves_io_schema.DomainType{}
																interceptionRules[i].DomainMatch = domainMatch
																for _, set := range sl {
																	domainMatchMapStrToI := set.(map[string]interface{})

																	domainChoiceTypeFound := false

																	if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.ExactValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.RegexValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.SuffixValue = v.(string)

																	}

																}

															}

															enableDisableChoiceTypeFound := false

															if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																	enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

															if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																	enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

														}

													}

												}

											}

											signingCertChoiceTypeFound := false

											if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true
												signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
												signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
												tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.Description = v.(string)

													}

													ocspStaplingChoiceTypeFound := false

													if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
														ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																for _, j := range v.([]interface{}) {
																	hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																}
																ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

															}

														}

													}

													if _, ok := cs["disable_ocsp_stapling"]; ok && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_DisableOcspStapling{}
														ocspStaplingChoiceInt.DisableOcspStapling = &ves_io_schema.Empty{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

													}

													if _, ok := cs["use_system_defaults"]; ok && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_UseSystemDefaults{}
														ocspStaplingChoiceInt.UseSystemDefaults = &ves_io_schema.Empty{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

													}

													if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														privateKey := &ves_io_schema.SecretType{}
														signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
														for _, set := range sl {
															privateKeyMapStrToI := set.(map[string]interface{})

															if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

												}

											}

											if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true

												if v.(bool) {
													signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
													signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
												}

											}

											trustedCaChoiceTypeFound := false

											if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true
												trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

												tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

												trustedCaChoiceInt.TrustedCaUrl = v.(string)

											}

											if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true

												if v.(bool) {
													trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
													trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
												}

											}

										}

									}

									if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

										ls := make([]uint32, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = uint32(v.(int))
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

									}

									if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

										ls := make([]string, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = v.(string)
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true

				if v.(bool) {
					globalNetworkChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_NoGlobalNetwork{}
					globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.GlobalNetworkChoice = globalNetworkChoiceInt
				}

			}

			insideStaticRouteChoiceTypeFound := false

			if v, ok := cs["inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

				insideStaticRouteChoiceTypeFound = true
				insideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_InsideStaticRoutes{}
				insideStaticRouteChoiceInt.InsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
				siteTypeInt.IngressEgressGw.InsideStaticRouteChoice = insideStaticRouteChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
						insideStaticRouteChoiceInt.InsideStaticRoutes.StaticRouteList = staticRouteList
						for i, set := range sl {
							staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
							staticRouteListMapStrToI := set.(map[string]interface{})

							configModeChoiceTypeFound := false

							if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
								configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

									}

									if v, ok := cs["labels"]; ok && !isIntfNil(v) {

										ms := map[string]string{}
										for k, v := range v.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										configModeChoiceInt.CustomStaticRoute.Labels = ms
									}

									if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										nexthop := &ves_io_schema.NextHopType{}
										configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
										for _, set := range sl {
											nexthopMapStrToI := set.(map[string]interface{})

											if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
												nexthop.Interface = intfInt
												for i, ps := range sl {

													iMapToStrVal := ps.(map[string]interface{})
													intfInt[i] = &ves_io_schema.ObjectRefType{}

													intfInt[i].Kind = "network_interface"

													if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
														intfInt[i].Name = v.(string)
													}

													if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														intfInt[i].Namespace = v.(string)
													}

													if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														intfInt[i].Tenant = v.(string)
													}

													if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
														intfInt[i].Uid = v.(string)
													}

												}

											}

											if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												nexthopAddress := &ves_io_schema.IpAddressType{}
												nexthop.NexthopAddress = nexthopAddress
												for _, set := range sl {
													nexthopAddressMapStrToI := set.(map[string]interface{})

													verTypeFound := false

													if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv4{}
														verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv4.Addr = v.(string)

															}

														}

													}

													if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv6{}
														verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv6.Addr = v.(string)

															}

														}

													}

												}

											}

											if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

												nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

											}

										}

									}

									if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

										sl := v.([]interface{})
										subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
										configModeChoiceInt.CustomStaticRoute.Subnets = subnets
										for i, set := range sl {
											subnets[i] = &ves_io_schema.IpSubnetType{}
											subnetsMapStrToI := set.(map[string]interface{})

											verTypeFound := false

											if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv4{}
												verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Prefix = v.(string)

													}

												}

											}

											if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv6{}
												verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Prefix = v.(string)

													}

												}

											}

										}

									}

								}

							}

							if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								configModeChoiceInt.SimpleStaticRoute = v.(string)

							}

						}

					}

				}

			}

			if v, ok := cs["no_inside_static_routes"]; ok && !isIntfNil(v) && !insideStaticRouteChoiceTypeFound {

				insideStaticRouteChoiceTypeFound = true

				if v.(bool) {
					insideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_NoInsideStaticRoutes{}
					insideStaticRouteChoiceInt.NoInsideStaticRoutes = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.InsideStaticRouteChoice = insideStaticRouteChoiceInt
				}

			}

			networkPolicyChoiceTypeFound := false

			if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_ActiveEnhancedFirewallPolicies{}
				networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
				siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
						for i, ps := range sl {

							efpMapToStrVal := ps.(map[string]interface{})
							enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Name = v.(string)
							}

							if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_ActiveNetworkPolicies{}
				networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
				siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
						for i, ps := range sl {

							npMapToStrVal := ps.(map[string]interface{})
							networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Name = v.(string)
							}

							if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true

				if v.(bool) {
					networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_NoNetworkPolicy{}
					networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.NetworkPolicyChoice = networkPolicyChoiceInt
				}

			}

			outsideStaticRouteChoiceTypeFound := false

			if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

				outsideStaticRouteChoiceTypeFound = true

				if v.(bool) {
					outsideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_NoOutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
				}

			}

			if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

				outsideStaticRouteChoiceTypeFound = true
				outsideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_OutsideStaticRoutes{}
				outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
				siteTypeInt.IngressEgressGw.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
						outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
						for i, set := range sl {
							staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
							staticRouteListMapStrToI := set.(map[string]interface{})

							configModeChoiceTypeFound := false

							if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
								configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

									}

									if v, ok := cs["labels"]; ok && !isIntfNil(v) {

										ms := map[string]string{}
										for k, v := range v.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										configModeChoiceInt.CustomStaticRoute.Labels = ms
									}

									if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										nexthop := &ves_io_schema.NextHopType{}
										configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
										for _, set := range sl {
											nexthopMapStrToI := set.(map[string]interface{})

											if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
												nexthop.Interface = intfInt
												for i, ps := range sl {

													iMapToStrVal := ps.(map[string]interface{})
													intfInt[i] = &ves_io_schema.ObjectRefType{}

													intfInt[i].Kind = "network_interface"

													if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
														intfInt[i].Name = v.(string)
													}

													if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														intfInt[i].Namespace = v.(string)
													}

													if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														intfInt[i].Tenant = v.(string)
													}

													if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
														intfInt[i].Uid = v.(string)
													}

												}

											}

											if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												nexthopAddress := &ves_io_schema.IpAddressType{}
												nexthop.NexthopAddress = nexthopAddress
												for _, set := range sl {
													nexthopAddressMapStrToI := set.(map[string]interface{})

													verTypeFound := false

													if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv4{}
														verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv4.Addr = v.(string)

															}

														}

													}

													if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv6{}
														verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv6.Addr = v.(string)

															}

														}

													}

												}

											}

											if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

												nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

											}

										}

									}

									if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

										sl := v.([]interface{})
										subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
										configModeChoiceInt.CustomStaticRoute.Subnets = subnets
										for i, set := range sl {
											subnets[i] = &ves_io_schema.IpSubnetType{}
											subnetsMapStrToI := set.(map[string]interface{})

											verTypeFound := false

											if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv4{}
												verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Prefix = v.(string)

													}

												}

											}

											if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv6{}
												verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Prefix = v.(string)

													}

												}

											}

										}

									}

								}

							}

							if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								configModeChoiceInt.SimpleStaticRoute = v.(string)

							}

						}

					}

				}

			}

			if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
				siteTypeInt.IngressEgressGw.PerformanceEnhancementMode = performanceEnhancementMode
				for _, set := range sl {
					performanceEnhancementModeMapStrToI := set.(map[string]interface{})

					perfModeChoiceTypeFound := false

					if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true
						perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
						perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
						performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
									perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

							if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
									perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

						}

					}

					if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
							perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
							performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
						}

					}

				}

			}

			siteMeshGroupChoiceTypeFound := false

			if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_SmConnectionPublicIp{}
					siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressEgressGwReplaceType_SmConnectionPvtIp{}
					siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
					siteTypeInt.IngressEgressGw.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

		}

	}

	if v, ok := d.GetOk("ingress_gw"); ok && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_IngressGw{}
		siteTypeInt.IngressGw = &ves_io_schema_views_gcp_vpc_site.GCPVPCIngressGwReplaceType{}
		updateSpec.SiteType = siteTypeInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			if v, ok := cs["performance_enhancement_mode"]; ok && !isIntfNil(v) {

				sl := v.(*schema.Set).List()
				performanceEnhancementMode := &ves_io_schema_views.PerformanceEnhancementModeType{}
				siteTypeInt.IngressGw.PerformanceEnhancementMode = performanceEnhancementMode
				for _, set := range sl {
					performanceEnhancementModeMapStrToI := set.(map[string]interface{})

					perfModeChoiceTypeFound := false

					if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l3_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true
						perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL3Enhanced{}
						perfModeChoiceInt.PerfModeL3Enhanced = &ves_io_schema_views.L3PerformanceEnhancementType{}
						performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt

						sl := v.(*schema.Set).List()
						for _, set := range sl {
							cs := set.(map[string]interface{})

							perfModeChoiceTypeFound := false

							if v, ok := cs["jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_Jumbo{}
									perfModeChoiceIntNew.Jumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

							if v, ok := cs["no_jumbo"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

								perfModeChoiceTypeFound = true

								if v.(bool) {
									perfModeChoiceIntNew := &ves_io_schema_views.L3PerformanceEnhancementType_NoJumbo{}
									perfModeChoiceIntNew.NoJumbo = &ves_io_schema.Empty{}
									perfModeChoiceInt.PerfModeL3Enhanced.PerfModeChoice = perfModeChoiceIntNew
								}

							}

						}

					}

					if v, ok := performanceEnhancementModeMapStrToI["perf_mode_l7_enhanced"]; ok && !isIntfNil(v) && !perfModeChoiceTypeFound {

						perfModeChoiceTypeFound = true

						if v.(bool) {
							perfModeChoiceInt := &ves_io_schema_views.PerformanceEnhancementModeType_PerfModeL7Enhanced{}
							perfModeChoiceInt.PerfModeL7Enhanced = &ves_io_schema.Empty{}
							performanceEnhancementMode.PerfModeChoice = perfModeChoiceInt
						}

					}

				}

			}

		}

	}

	if v, ok := d.GetOk("voltstack_cluster"); ok && !siteTypeTypeFound {

		siteTypeTypeFound = true
		siteTypeInt := &ves_io_schema_views_gcp_vpc_site.ReplaceSpecType_VoltstackCluster{}
		siteTypeInt.VoltstackCluster = &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType{}
		updateSpec.SiteType = siteTypeInt

		sl := v.(*schema.Set).List()
		for _, set := range sl {
			cs := set.(map[string]interface{})

			dcClusterGroupChoiceTypeFound := false

			if v, ok := cs["dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true
				dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_DcClusterGroup{}
				dcClusterGroupChoiceInt.DcClusterGroup = &ves_io_schema_views.ObjectRefType{}
				siteTypeInt.VoltstackCluster.DcClusterGroupChoice = dcClusterGroupChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["name"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroup.Name = v.(string)

					}

					if v, ok := cs["namespace"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroup.Namespace = v.(string)

					}

					if v, ok := cs["tenant"]; ok && !isIntfNil(v) {

						dcClusterGroupChoiceInt.DcClusterGroup.Tenant = v.(string)

					}

				}

			}

			if v, ok := cs["no_dc_cluster_group"]; ok && !isIntfNil(v) && !dcClusterGroupChoiceTypeFound {

				dcClusterGroupChoiceTypeFound = true

				if v.(bool) {
					dcClusterGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_NoDcClusterGroup{}
					dcClusterGroupChoiceInt.NoDcClusterGroup = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.DcClusterGroupChoice = dcClusterGroupChoiceInt
				}

			}

			forwardProxyChoiceTypeFound := false

			if v, ok := cs["active_forward_proxy_policies"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true
				forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_ActiveForwardProxyPolicies{}
				forwardProxyChoiceInt.ActiveForwardProxyPolicies = &ves_io_schema_network_firewall.ActiveForwardProxyPoliciesType{}
				siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["forward_proxy_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						forwardProxyPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						forwardProxyChoiceInt.ActiveForwardProxyPolicies.ForwardProxyPolicies = forwardProxyPoliciesInt
						for i, ps := range sl {

							fppMapToStrVal := ps.(map[string]interface{})
							forwardProxyPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := fppMapToStrVal["name"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Name = v.(string)
							}

							if v, ok := fppMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := fppMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								forwardProxyPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["forward_proxy_allow_all"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_ForwardProxyAllowAll{}
					forwardProxyChoiceInt.ForwardProxyAllowAll = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			if v, ok := cs["no_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

				forwardProxyChoiceTypeFound = true

				if v.(bool) {
					forwardProxyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_NoForwardProxy{}
					forwardProxyChoiceInt.NoForwardProxy = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.ForwardProxyChoice = forwardProxyChoiceInt
				}

			}

			globalNetworkChoiceTypeFound := false

			if v, ok := cs["global_network_list"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true
				globalNetworkChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_GlobalNetworkList{}
				globalNetworkChoiceInt.GlobalNetworkList = &ves_io_schema_views.GlobalNetworkConnectionListType{}
				siteTypeInt.VoltstackCluster.GlobalNetworkChoice = globalNetworkChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["global_network_connections"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						globalNetworkConnections := make([]*ves_io_schema_views.GlobalNetworkConnectionType, len(sl))
						globalNetworkChoiceInt.GlobalNetworkList.GlobalNetworkConnections = globalNetworkConnections
						for i, set := range sl {
							globalNetworkConnections[i] = &ves_io_schema_views.GlobalNetworkConnectionType{}
							globalNetworkConnectionsMapStrToI := set.(map[string]interface{})

							connectionChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["sli_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SliToGlobalDr{}
								connectionChoiceInt.SliToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SliToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["slo_to_global_dr"]; ok && !isIntfNil(v) && !connectionChoiceTypeFound {

								connectionChoiceTypeFound = true
								connectionChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_SloToGlobalDr{}
								connectionChoiceInt.SloToGlobalDr = &ves_io_schema_views.GlobalConnectorType{}
								globalNetworkConnections[i].ConnectionChoice = connectionChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["global_vn"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										globalVn := &ves_io_schema_views.ObjectRefType{}
										connectionChoiceInt.SloToGlobalDr.GlobalVn = globalVn
										for _, set := range sl {
											globalVnMapStrToI := set.(map[string]interface{})

											if w, ok := globalVnMapStrToI["name"]; ok && !isIntfNil(w) {
												globalVn.Name = w.(string)
											}

											if w, ok := globalVnMapStrToI["namespace"]; ok && !isIntfNil(w) {
												globalVn.Namespace = w.(string)
											}

											if w, ok := globalVnMapStrToI["tenant"]; ok && !isIntfNil(w) {
												globalVn.Tenant = w.(string)
											}

										}

									}

								}

							}

							forwardProxyChoiceTypeFound := false

							if v, ok := globalNetworkConnectionsMapStrToI["disable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true

								if v.(bool) {
									forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_DisableForwardProxy{}
									forwardProxyChoiceInt.DisableForwardProxy = &ves_io_schema.Empty{}
									globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt
								}

							}

							if v, ok := globalNetworkConnectionsMapStrToI["enable_forward_proxy"]; ok && !isIntfNil(v) && !forwardProxyChoiceTypeFound {

								forwardProxyChoiceTypeFound = true
								forwardProxyChoiceInt := &ves_io_schema_views.GlobalNetworkConnectionType_EnableForwardProxy{}
								forwardProxyChoiceInt.EnableForwardProxy = &ves_io_schema.ForwardProxyConfigType{}
								globalNetworkConnections[i].ForwardProxyChoice = forwardProxyChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["connection_timeout"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.ConnectionTimeout = uint32(v.(int))

									}

									if v, ok := cs["max_connect_attempts"]; ok && !isIntfNil(v) {

										forwardProxyChoiceInt.EnableForwardProxy.MaxConnectAttempts = uint32(v.(int))

									}

									tlsInterceptionChoiceTypeFound := false

									if v, ok := cs["no_interception"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true

										if v.(bool) {
											tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_NoInterception{}
											tlsInterceptionChoiceInt.NoInterception = &ves_io_schema.Empty{}
											forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt
										}

									}

									if v, ok := cs["tls_intercept"]; ok && !isIntfNil(v) && !tlsInterceptionChoiceTypeFound {

										tlsInterceptionChoiceTypeFound = true
										tlsInterceptionChoiceInt := &ves_io_schema.ForwardProxyConfigType_TlsIntercept{}
										tlsInterceptionChoiceInt.TlsIntercept = &ves_io_schema.TlsInterceptionType{}
										forwardProxyChoiceInt.EnableForwardProxy.TlsInterceptionChoice = tlsInterceptionChoiceInt

										sl := v.(*schema.Set).List()
										for _, set := range sl {
											cs := set.(map[string]interface{})

											interceptionPolicyChoiceTypeFound := false

											if v, ok := cs["enable_for_all_domains"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true

												if v.(bool) {
													interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_EnableForAllDomains{}
													interceptionPolicyChoiceInt.EnableForAllDomains = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt
												}

											}

											if v, ok := cs["policy"]; ok && !isIntfNil(v) && !interceptionPolicyChoiceTypeFound {

												interceptionPolicyChoiceTypeFound = true
												interceptionPolicyChoiceInt := &ves_io_schema.TlsInterceptionType_Policy{}
												interceptionPolicyChoiceInt.Policy = &ves_io_schema.TlsInterceptionPolicy{}
												tlsInterceptionChoiceInt.TlsIntercept.InterceptionPolicyChoice = interceptionPolicyChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["interception_rules"]; ok && !isIntfNil(v) {

														sl := v.([]interface{})
														interceptionRules := make([]*ves_io_schema.TlsInterceptionRule, len(sl))
														interceptionPolicyChoiceInt.Policy.InterceptionRules = interceptionRules
														for i, set := range sl {
															interceptionRules[i] = &ves_io_schema.TlsInterceptionRule{}
															interceptionRulesMapStrToI := set.(map[string]interface{})

															if v, ok := interceptionRulesMapStrToI["domain_match"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																domainMatch := &ves_io_schema.DomainType{}
																interceptionRules[i].DomainMatch = domainMatch
																for _, set := range sl {
																	domainMatchMapStrToI := set.(map[string]interface{})

																	domainChoiceTypeFound := false

																	if v, ok := domainMatchMapStrToI["exact_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_ExactValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.ExactValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["regex_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_RegexValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.RegexValue = v.(string)

																	}

																	if v, ok := domainMatchMapStrToI["suffix_value"]; ok && !isIntfNil(v) && !domainChoiceTypeFound {

																		domainChoiceTypeFound = true
																		domainChoiceInt := &ves_io_schema.DomainType_SuffixValue{}

																		domainMatch.DomainChoice = domainChoiceInt

																		domainChoiceInt.SuffixValue = v.(string)

																	}

																}

															}

															enableDisableChoiceTypeFound := false

															if v, ok := interceptionRulesMapStrToI["disable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_DisableInterception{}
																	enableDisableChoiceInt.DisableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

															if v, ok := interceptionRulesMapStrToI["enable_interception"]; ok && !isIntfNil(v) && !enableDisableChoiceTypeFound {

																enableDisableChoiceTypeFound = true

																if v.(bool) {
																	enableDisableChoiceInt := &ves_io_schema.TlsInterceptionRule_EnableInterception{}
																	enableDisableChoiceInt.EnableInterception = &ves_io_schema.Empty{}
																	interceptionRules[i].EnableDisableChoice = enableDisableChoiceInt
																}

															}

														}

													}

												}

											}

											signingCertChoiceTypeFound := false

											if v, ok := cs["custom_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true
												signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_CustomCertificate{}
												signingCertChoiceInt.CustomCertificate = &ves_io_schema.TlsCertificateType{}
												tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["certificate_url"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.CertificateUrl = v.(string)

													}

													if v, ok := cs["description"]; ok && !isIntfNil(v) {

														signingCertChoiceInt.CustomCertificate.Description = v.(string)

													}

													ocspStaplingChoiceTypeFound := false

													if v, ok := cs["custom_hash_algorithms"]; ok && !isIntfNil(v) && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_CustomHashAlgorithms{}
														ocspStaplingChoiceInt.CustomHashAlgorithms = &ves_io_schema.HashAlgorithms{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["hash_algorithms"]; ok && !isIntfNil(v) {

																hash_algorithmsList := []ves_io_schema.HashAlgorithm{}
																for _, j := range v.([]interface{}) {
																	hash_algorithmsList = append(hash_algorithmsList, ves_io_schema.HashAlgorithm(ves_io_schema.HashAlgorithm_value[j.(string)]))
																}
																ocspStaplingChoiceInt.CustomHashAlgorithms.HashAlgorithms = hash_algorithmsList

															}

														}

													}

													if _, ok := cs["disable_ocsp_stapling"]; ok && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_DisableOcspStapling{}
														ocspStaplingChoiceInt.DisableOcspStapling = &ves_io_schema.Empty{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

													}

													if _, ok := cs["use_system_defaults"]; ok && !ocspStaplingChoiceTypeFound {

														ocspStaplingChoiceTypeFound = true
														ocspStaplingChoiceInt := &ves_io_schema.TlsCertificateType_UseSystemDefaults{}
														ocspStaplingChoiceInt.UseSystemDefaults = &ves_io_schema.Empty{}
														signingCertChoiceInt.CustomCertificate.OcspStaplingChoice = ocspStaplingChoiceInt

													}

													if v, ok := cs["private_key"]; ok && !isIntfNil(v) {

														sl := v.(*schema.Set).List()
														privateKey := &ves_io_schema.SecretType{}
														signingCertChoiceInt.CustomCertificate.PrivateKey = privateKey
														for _, set := range sl {
															privateKeyMapStrToI := set.(map[string]interface{})

															if v, ok := privateKeyMapStrToI["blindfold_secret_info_internal"]; ok && !isIntfNil(v) {

																sl := v.(*schema.Set).List()
																blindfoldSecretInfoInternal := &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.BlindfoldSecretInfoInternal = blindfoldSecretInfoInternal
																for _, set := range sl {
																	blindfoldSecretInfoInternalMapStrToI := set.(map[string]interface{})

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["decryption_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.DecryptionProvider = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["location"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.Location = w.(string)
																	}

																	if w, ok := blindfoldSecretInfoInternalMapStrToI["store_provider"]; ok && !isIntfNil(w) {
																		blindfoldSecretInfoInternal.StoreProvider = w.(string)
																	}

																}

															}

															if v, ok := privateKeyMapStrToI["secret_encoding_type"]; ok && !isIntfNil(v) {

																privateKey.SecretEncodingType = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

															}

															secretInfoOneofTypeFound := false

															if v, ok := privateKeyMapStrToI["blindfold_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_BlindfoldSecretInfo{}
																secretInfoOneofInt.BlindfoldSecretInfo = &ves_io_schema.BlindfoldSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["decryption_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.DecryptionProvider = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["store_provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.BlindfoldSecretInfo.StoreProvider = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["clear_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_ClearSecretInfo{}
																secretInfoOneofInt.ClearSecretInfo = &ves_io_schema.ClearSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["url"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.ClearSecretInfo.Url = v.(string)

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["vault_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_VaultSecretInfo{}
																secretInfoOneofInt.VaultSecretInfo = &ves_io_schema.VaultSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["key"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Key = v.(string)

																	}

																	if v, ok := cs["location"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Location = v.(string)

																	}

																	if v, ok := cs["provider"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Provider = v.(string)

																	}

																	if v, ok := cs["secret_encoding"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.SecretEncoding = ves_io_schema.SecretEncodingType(ves_io_schema.SecretEncodingType_value[v.(string)])

																	}

																	if v, ok := cs["version"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.VaultSecretInfo.Version = uint32(v.(int))

																	}

																}

															}

															if v, ok := privateKeyMapStrToI["wingman_secret_info"]; ok && !isIntfNil(v) && !secretInfoOneofTypeFound {

																secretInfoOneofTypeFound = true
																secretInfoOneofInt := &ves_io_schema.SecretType_WingmanSecretInfo{}
																secretInfoOneofInt.WingmanSecretInfo = &ves_io_schema.WingmanSecretInfoType{}
																privateKey.SecretInfoOneof = secretInfoOneofInt

																sl := v.(*schema.Set).List()
																for _, set := range sl {
																	cs := set.(map[string]interface{})

																	if v, ok := cs["name"]; ok && !isIntfNil(v) {

																		secretInfoOneofInt.WingmanSecretInfo.Name = v.(string)

																	}

																}

															}

														}

													}

												}

											}

											if v, ok := cs["volterra_certificate"]; ok && !isIntfNil(v) && !signingCertChoiceTypeFound {

												signingCertChoiceTypeFound = true

												if v.(bool) {
													signingCertChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraCertificate{}
													signingCertChoiceInt.VolterraCertificate = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.SigningCertChoice = signingCertChoiceInt
												}

											}

											trustedCaChoiceTypeFound := false

											if v, ok := cs["trusted_ca_url"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true
												trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_TrustedCaUrl{}

												tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt

												trustedCaChoiceInt.TrustedCaUrl = v.(string)

											}

											if v, ok := cs["volterra_trusted_ca"]; ok && !isIntfNil(v) && !trustedCaChoiceTypeFound {

												trustedCaChoiceTypeFound = true

												if v.(bool) {
													trustedCaChoiceInt := &ves_io_schema.TlsInterceptionType_VolterraTrustedCa{}
													trustedCaChoiceInt.VolterraTrustedCa = &ves_io_schema.Empty{}
													tlsInterceptionChoiceInt.TlsIntercept.TrustedCaChoice = trustedCaChoiceInt
												}

											}

										}

									}

									if v, ok := cs["white_listed_ports"]; ok && !isIntfNil(v) {

										ls := make([]uint32, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = uint32(v.(int))
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPorts = ls

									}

									if v, ok := cs["white_listed_prefixes"]; ok && !isIntfNil(v) {

										ls := make([]string, len(v.([]interface{})))
										for i, v := range v.([]interface{}) {
											ls[i] = v.(string)
										}
										forwardProxyChoiceInt.EnableForwardProxy.WhiteListedPrefixes = ls

									}

								}

							}

						}

					}

				}

			}

			if v, ok := cs["no_global_network"]; ok && !isIntfNil(v) && !globalNetworkChoiceTypeFound {

				globalNetworkChoiceTypeFound = true

				if v.(bool) {
					globalNetworkChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_NoGlobalNetwork{}
					globalNetworkChoiceInt.NoGlobalNetwork = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.GlobalNetworkChoice = globalNetworkChoiceInt
				}

			}

			networkPolicyChoiceTypeFound := false

			if v, ok := cs["active_enhanced_firewall_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_ActiveEnhancedFirewallPolicies{}
				networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies = &ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesType{}
				siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["enhanced_firewall_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						enhancedFirewallPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies = enhancedFirewallPoliciesInt
						for i, ps := range sl {

							efpMapToStrVal := ps.(map[string]interface{})
							enhancedFirewallPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := efpMapToStrVal["name"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Name = v.(string)
							}

							if v, ok := efpMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := efpMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								enhancedFirewallPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["active_network_policies"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true
				networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_ActiveNetworkPolicies{}
				networkPolicyChoiceInt.ActiveNetworkPolicies = &ves_io_schema_network_firewall.ActiveNetworkPoliciesType{}
				siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["network_policies"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						networkPoliciesInt := make([]*ves_io_schema_views.ObjectRefType, len(sl))
						networkPolicyChoiceInt.ActiveNetworkPolicies.NetworkPolicies = networkPoliciesInt
						for i, ps := range sl {

							npMapToStrVal := ps.(map[string]interface{})
							networkPoliciesInt[i] = &ves_io_schema_views.ObjectRefType{}

							if v, ok := npMapToStrVal["name"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Name = v.(string)
							}

							if v, ok := npMapToStrVal["namespace"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Namespace = v.(string)
							}

							if v, ok := npMapToStrVal["tenant"]; ok && !isIntfNil(v) {
								networkPoliciesInt[i].Tenant = v.(string)
							}

						}

					}

				}

			}

			if v, ok := cs["no_network_policy"]; ok && !isIntfNil(v) && !networkPolicyChoiceTypeFound {

				networkPolicyChoiceTypeFound = true

				if v.(bool) {
					networkPolicyChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_NoNetworkPolicy{}
					networkPolicyChoiceInt.NoNetworkPolicy = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.NetworkPolicyChoice = networkPolicyChoiceInt
				}

			}

			outsideStaticRouteChoiceTypeFound := false

			if v, ok := cs["no_outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

				outsideStaticRouteChoiceTypeFound = true

				if v.(bool) {
					outsideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_NoOutsideStaticRoutes{}
					outsideStaticRouteChoiceInt.NoOutsideStaticRoutes = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt
				}

			}

			if v, ok := cs["outside_static_routes"]; ok && !isIntfNil(v) && !outsideStaticRouteChoiceTypeFound {

				outsideStaticRouteChoiceTypeFound = true
				outsideStaticRouteChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_OutsideStaticRoutes{}
				outsideStaticRouteChoiceInt.OutsideStaticRoutes = &ves_io_schema_views.SiteStaticRoutesListType{}
				siteTypeInt.VoltstackCluster.OutsideStaticRouteChoice = outsideStaticRouteChoiceInt

				sl := v.(*schema.Set).List()
				for _, set := range sl {
					cs := set.(map[string]interface{})

					if v, ok := cs["static_route_list"]; ok && !isIntfNil(v) {

						sl := v.([]interface{})
						staticRouteList := make([]*ves_io_schema_views.SiteStaticRoutesType, len(sl))
						outsideStaticRouteChoiceInt.OutsideStaticRoutes.StaticRouteList = staticRouteList
						for i, set := range sl {
							staticRouteList[i] = &ves_io_schema_views.SiteStaticRoutesType{}
							staticRouteListMapStrToI := set.(map[string]interface{})

							configModeChoiceTypeFound := false

							if v, ok := staticRouteListMapStrToI["custom_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_CustomStaticRoute{}
								configModeChoiceInt.CustomStaticRoute = &ves_io_schema.StaticRouteType{}
								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								sl := v.(*schema.Set).List()
								for _, set := range sl {
									cs := set.(map[string]interface{})

									if v, ok := cs["attrs"]; ok && !isIntfNil(v) {

										attrsList := []ves_io_schema.RouteAttrType{}
										for _, j := range v.([]interface{}) {
											attrsList = append(attrsList, ves_io_schema.RouteAttrType(ves_io_schema.RouteAttrType_value[j.(string)]))
										}
										configModeChoiceInt.CustomStaticRoute.Attrs = attrsList

									}

									if v, ok := cs["labels"]; ok && !isIntfNil(v) {

										ms := map[string]string{}
										for k, v := range v.(map[string]interface{}) {
											ms[k] = v.(string)
										}
										configModeChoiceInt.CustomStaticRoute.Labels = ms
									}

									if v, ok := cs["nexthop"]; ok && !isIntfNil(v) {

										sl := v.(*schema.Set).List()
										nexthop := &ves_io_schema.NextHopType{}
										configModeChoiceInt.CustomStaticRoute.Nexthop = nexthop
										for _, set := range sl {
											nexthopMapStrToI := set.(map[string]interface{})

											if v, ok := nexthopMapStrToI["interface"]; ok && !isIntfNil(v) {

												sl := v.([]interface{})
												intfInt := make([]*ves_io_schema.ObjectRefType, len(sl))
												nexthop.Interface = intfInt
												for i, ps := range sl {

													iMapToStrVal := ps.(map[string]interface{})
													intfInt[i] = &ves_io_schema.ObjectRefType{}

													intfInt[i].Kind = "network_interface"

													if v, ok := iMapToStrVal["name"]; ok && !isIntfNil(v) {
														intfInt[i].Name = v.(string)
													}

													if v, ok := iMapToStrVal["namespace"]; ok && !isIntfNil(v) {
														intfInt[i].Namespace = v.(string)
													}

													if v, ok := iMapToStrVal["tenant"]; ok && !isIntfNil(v) {
														intfInt[i].Tenant = v.(string)
													}

													if v, ok := iMapToStrVal["uid"]; ok && !isIntfNil(v) {
														intfInt[i].Uid = v.(string)
													}

												}

											}

											if v, ok := nexthopMapStrToI["nexthop_address"]; ok && !isIntfNil(v) {

												sl := v.(*schema.Set).List()
												nexthopAddress := &ves_io_schema.IpAddressType{}
												nexthop.NexthopAddress = nexthopAddress
												for _, set := range sl {
													nexthopAddressMapStrToI := set.(map[string]interface{})

													verTypeFound := false

													if v, ok := nexthopAddressMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv4{}
														verInt.Ipv4 = &ves_io_schema.Ipv4AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv4.Addr = v.(string)

															}

														}

													}

													if v, ok := nexthopAddressMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

														verTypeFound = true
														verInt := &ves_io_schema.IpAddressType_Ipv6{}
														verInt.Ipv6 = &ves_io_schema.Ipv6AddressType{}
														nexthopAddress.Ver = verInt

														sl := v.(*schema.Set).List()
														for _, set := range sl {
															cs := set.(map[string]interface{})

															if v, ok := cs["addr"]; ok && !isIntfNil(v) {

																verInt.Ipv6.Addr = v.(string)

															}

														}

													}

												}

											}

											if v, ok := nexthopMapStrToI["type"]; ok && !isIntfNil(v) {

												nexthop.Type = ves_io_schema.NextHopTypes(ves_io_schema.NextHopTypes_value[v.(string)])

											}

										}

									}

									if v, ok := cs["subnets"]; ok && !isIntfNil(v) {

										sl := v.([]interface{})
										subnets := make([]*ves_io_schema.IpSubnetType, len(sl))
										configModeChoiceInt.CustomStaticRoute.Subnets = subnets
										for i, set := range sl {
											subnets[i] = &ves_io_schema.IpSubnetType{}
											subnetsMapStrToI := set.(map[string]interface{})

											verTypeFound := false

											if v, ok := subnetsMapStrToI["ipv4"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv4{}
												verInt.Ipv4 = &ves_io_schema.Ipv4SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv4.Prefix = v.(string)

													}

												}

											}

											if v, ok := subnetsMapStrToI["ipv6"]; ok && !isIntfNil(v) && !verTypeFound {

												verTypeFound = true
												verInt := &ves_io_schema.IpSubnetType_Ipv6{}
												verInt.Ipv6 = &ves_io_schema.Ipv6SubnetType{}
												subnets[i].Ver = verInt

												sl := v.(*schema.Set).List()
												for _, set := range sl {
													cs := set.(map[string]interface{})

													if v, ok := cs["plen"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Plen = uint32(v.(int))

													}

													if v, ok := cs["prefix"]; ok && !isIntfNil(v) {

														verInt.Ipv6.Prefix = v.(string)

													}

												}

											}

										}

									}

								}

							}

							if v, ok := staticRouteListMapStrToI["simple_static_route"]; ok && !isIntfNil(v) && !configModeChoiceTypeFound {

								configModeChoiceTypeFound = true
								configModeChoiceInt := &ves_io_schema_views.SiteStaticRoutesType_SimpleStaticRoute{}

								staticRouteList[i].ConfigModeChoice = configModeChoiceInt

								configModeChoiceInt.SimpleStaticRoute = v.(string)

							}

						}

					}

				}

			}

			siteMeshGroupChoiceTypeFound := false

			if v, ok := cs["sm_connection_public_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_SmConnectionPublicIp{}
					siteMeshGroupChoiceInt.SmConnectionPublicIp = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

			if v, ok := cs["sm_connection_pvt_ip"]; ok && !isIntfNil(v) && !siteMeshGroupChoiceTypeFound {

				siteMeshGroupChoiceTypeFound = true

				if v.(bool) {
					siteMeshGroupChoiceInt := &ves_io_schema_views_gcp_vpc_site.GCPVPCVoltstackClusterReplaceType_SmConnectionPvtIp{}
					siteMeshGroupChoiceInt.SmConnectionPvtIp = &ves_io_schema.Empty{}
					siteTypeInt.VoltstackCluster.SiteMeshGroupChoice = siteMeshGroupChoiceInt
				}

			}

		}

	}

	log.Printf("[DEBUG] Updating Volterra GcpVpcSite obj with struct: %+v", updateReq)

	err := client.ReplaceObject(context.Background(), ves_io_schema_views_gcp_vpc_site.ObjectType, updateReq)
	if err != nil {
		return fmt.Errorf("error updating GcpVpcSite: %s", err)
	}

	return resourceVolterraGcpVpcSiteRead(d, meta)
}

func resourceVolterraGcpVpcSiteDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*APIClient)
	name := d.Get("name").(string)
	namespace := d.Get("namespace").(string)

	_, err := client.GetObject(context.Background(), ves_io_schema_views_gcp_vpc_site.ObjectType, namespace, name)
	if err != nil {
		if strings.Contains(err.Error(), "status code 404") {
			log.Printf("[INFO] GcpVpcSite %s no longer exists", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error finding Volterra GcpVpcSite before deleting %q: %s", d.Id(), err)
	}

	log.Printf("[DEBUG] Deleting Volterra GcpVpcSite obj with name %+v in namespace %+v", name, namespace)
	return client.DeleteObject(context.Background(), ves_io_schema_views_gcp_vpc_site.ObjectType, namespace, name)
}
